// ============================================================================
// PolyGen Grammar
// ============================================================================
// 이 파일은 PolyGen 스키마 언어의 문법을 정의합니다.
// pest 파서 생성기가 이 파일을 사용하여 파서를 생성합니다.

// Whitespace and Comments
// =======================
// `_` 접두사가 붙은 규칙(silent rule)은 파싱 트리에서 생략됩니다.
WHITESPACE = _{ " " | "\t" | NEWLINE }
NEWLINE    = _{ "\n" | "\r\n" | "\r" }

// Comments - position-based semantics:
// - Comments BEFORE an item (on their own line) → doc_comment (attached to next item)
// - Comments AFTER ; or , on the SAME line → inline_comment (attached to current item)
// Both // and /// are treated the same - meaning is determined by position, not syntax.
doc_comment   =  { block_comment | line_comment }
block_comment =  { "/*" ~ (!"*/" ~ ANY)* ~ "*/" }
line_comment  = @{ "//" ~ (!NEWLINE ~ ANY)* }

// Main entry point
// ================
// 스키마 파일은 파일 임포트와 최상위 정의들을 포함할 수 있습니다.
main = { SOI ~ (toplevel_item | WHITESPACE)* ~ EOI }

toplevel_item = { file_import | definition }

// File Import: `import "path/to/file.poly";`
// ==========================================
file_import = { "import" ~ STRING_LITERAL ~ ";" }

// Namespace Import: `import game.common.*;` or `import game.common.Type;`
// =======================================================================
namespace_import = { "import" ~ path ~ (".*")? ~ ";" }

// Top-level definitions
// =====================
definition = { (doc_comment | annotation)* ~ (namespace | table | embed_def | enum_def) }

// Namespace
// =========
// 네임스페이스는 다른 정의들이나 네임스페이스 임포트를 포함할 수 있습니다.
namespace           = { "namespace" ~ path ~ "{" ~ (namespace_body_item | WHITESPACE | doc_comment)* ~ "}" }
namespace_body_item = { namespace_import | definition }

// Table / Embed
// =============
table     = { "table" ~ IDENT ~ "{" ~ (table_member | WHITESPACE | doc_comment)* ~ "}" }
embed_def = { "embed" ~ IDENT ~ "{" ~ (table_member | WHITESPACE | doc_comment)* ~ "}" }

table_member = { doc_comment* ~ annotation* ~ (embed_def | enum_def | (field_definition ~ ";")) }

field_definition = { inline_enum_field | inline_embed_field | regular_field }

regular_field      = { IDENT ~ ":" ~ type_with_cardinality ~ constraint* ~ field_number? }
inline_embed_field = { IDENT ~ ":" ~ "embed" ~ "{" ~ (table_member | WHITESPACE | doc_comment)* ~ "}" ~ cardinality? ~ field_number? }
inline_enum_field = { IDENT ~ ":" ~ "enum" ~ "{" ~ enum_variant* ~ "}" ~ cardinality? ~ field_number? }

field_number = { "=" ~ INTEGER }

// Enum
// ====
enum_def           = { "enum" ~ IDENT ~ "{" ~ enum_variant* ~ "}" }
anonymous_enum_def = { "enum" ~ "{" ~ enum_variant* ~ "}" }
enum_variant       = { doc_comment* ~ annotation* ~ IDENT ~ ("=" ~ INTEGER)? ~ enum_variant_end? }
// Atomic rule to capture terminator and inline comment together (no whitespace skipping)
// This ensures comments after ; or , stay with the current item, not the next one
enum_variant_end   = @{ (";" | ",") ~ (" " | "\t")* ~ inline_comment? }
inline_comment     = @{ "//" ~ (!NEWLINE ~ ANY)* }

// Types
// =====
type_with_cardinality = { type_name ~ cardinality? }
cardinality           = { "[]" | "?" }
type_name             = { basic_type | path | anonymous_enum_def }
basic_type            = { "string" | "u8" | "u16" | "u32" | "u64" | "i8" | "i16" | "i32" | "i64" | "f32" | "f64" | "bool" | "bytes" | "timestamp" }

// Constraints
// ===========
constraint      = { primary_key | unique | index | max_length | default_val | range_val | regex_val | foreign_key_val | auto_create | auto_update }
primary_key     = { "primary_key" }
unique          = { "unique" }
index           = { "index" }
max_length      = { "max_length" ~ "(" ~ INTEGER ~ ")" }
default_val     = { "default" ~ "(" ~ literal ~ ")" }
range_val       = { "range" ~ "(" ~ literal ~ "," ~ literal ~ ")" }
regex_val       = { "regex" ~ "(" ~ STRING_LITERAL ~ ")" }
foreign_key_val = { "foreign_key" ~ "(" ~ path ~ ")" ~ ("as" ~ IDENT)? }

// Auto-timestamp constraints
// Timezone can be:
//   - utc, local (reserved keywords)
//   - +9, -5, +5:30 (UTC offset)
//   - "Korea Standard Time" (Windows TimeZone ID)
auto_create     = { "auto_create" ~ ("(" ~ timezone ~ ")")? }
auto_update     = { "auto_update" ~ ("(" ~ timezone ~ ")")? }
timezone        = { tz_utc | tz_local | tz_offset | STRING_LITERAL }
tz_utc          = { "utc" }
tz_local        = { "local" }
tz_offset       = @{ ("+" | "-") ~ ASCII_DIGIT+ ~ (":" ~ ASCII_DIGIT{2})? }

// Annotations
// ===========
// Annotations support both positional arguments and key-value parameters:
//   @load(csv: "data.csv")           - key-value only
//   @index(name, level)              - positional only (field names)
//   @index(name, level, unique: true) - mixed
annotation             = { "@" ~ IDENT ~ ("(" ~ annotation_args_list? ~ ")")? }
annotation_args_list   = { annotation_arg ~ ("," ~ annotation_arg)* }
annotation_arg         = { annotation_param | literal }
annotation_param       = { IDENT ~ ":" ~ literal }

// Literals
// ========
literal = { STRING_LITERAL | FLOAT | INTEGER | BOOLEAN | IDENT }

// Primitives
// ==========
// 경로는 점(.)으로 구분된 식별자입니다. 예: `game.common.Type`
path = { IDENT ~ ("." ~ IDENT)* }
// 식별자는 알파벳이나 밑줄로 시작해야 합니다.
IDENT          = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }
FLOAT          = @{ "-"? ~ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }
INTEGER        = @{ "-"? ~ ASCII_DIGIT+ }
STRING_LITERAL = @{ "\"" ~ ("\\" ~ ANY | !("\"") ~ ANY)* ~ "\"" }
BOOLEAN        = @{ "true" | "false" }

// ============================================================================
// Renames File Grammar (for .renames files)
// ============================================================================
// Renames files define schema migrations:
//   Player -> User                    (table rename)
//   User.user_name -> name            (field rename)
//
// Entry point for .renames files
// Note: Uses explicit whitespace handling to avoid silent WHITESPACE rule issues
renames_file = { SOI ~ renames_content ~ EOI }
renames_content = _{ (rename_rule | rename_comment_line | renames_ws)* }
renames_ws = _{ " " | "\t" | "\n" | "\r" }

// Comments in rename files (atomic to prevent whitespace skipping)
rename_comment_line = @{ "#" ~ (!("\n" | "\r") ~ ANY)* }

// Rename rule: path -> identifier
// Examples:
//   Player -> User                    (table rename)
//   User.user_name -> name            (field rename within same table)
//   game.Player -> game.User          (with namespace)
rename_rule = { path ~ "->" ~ IDENT ~ ";" }
