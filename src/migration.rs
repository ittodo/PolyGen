//! Schema migration diff module.
//!
//! Compares two schema versions and generates migration SQL.

use crate::ir_model::{NamespaceDef, NamespaceItem, SchemaContext, StructDef};
use std::collections::{HashMap, HashSet};

/// Represents a detected schema change.
#[derive(Debug, Clone)]
pub enum SchemaChange {
    /// A new table was added.
    TableAdded {
        table_name: String,
        namespace: String,
        struct_def: StructDef,
    },
    /// A table was removed (warning).
    TableRemoved {
        table_name: String,
        namespace: String,
    },
    /// A new column was added to a table.
    ColumnAdded {
        table_name: String,
        namespace: String,
        column_name: String,
        column_type: String,
        is_nullable: bool,
    },
    /// A column was removed from a table (warning).
    ColumnRemoved {
        table_name: String,
        namespace: String,
        column_name: String,
    },
    /// A column type changed (requires table recreation in SQLite).
    ColumnTypeChanged {
        table_name: String,
        namespace: String,
        column_name: String,
        old_type: String,
        new_type: String,
    },
}

/// Result of comparing two schemas.
#[derive(Debug, Default)]
pub struct MigrationDiff {
    /// List of detected changes.
    pub changes: Vec<SchemaChange>,
    /// Warnings about potentially destructive operations.
    pub warnings: Vec<String>,
}

/// Represents a table for comparison purposes.
#[derive(Debug, Clone)]
struct TableInfo {
    name: String,
    namespace: String,
    full_name: String, // namespace_prefixed name for SQLite
    columns: HashMap<String, ColumnInfo>,
    struct_def: StructDef,
}

/// Represents a column for comparison purposes.
#[derive(Debug, Clone)]
struct ColumnInfo {
    name: String,
    type_name: String,
    is_nullable: bool,
}

impl MigrationDiff {
    /// Compare two schema contexts and generate a diff.
    pub fn compare(baseline: &SchemaContext, current: &SchemaContext) -> Self {
        let mut diff = MigrationDiff::default();

        // Extract tables from both schemas
        let baseline_tables = extract_tables(baseline);
        let current_tables = extract_tables(current);

        let baseline_names: HashSet<_> = baseline_tables.keys().collect();
        let current_names: HashSet<_> = current_tables.keys().collect();

        // Find added tables
        for name in current_names.difference(&baseline_names) {
            if let Some(table) = current_tables.get(*name) {
                diff.changes.push(SchemaChange::TableAdded {
                    table_name: table.name.clone(),
                    namespace: table.namespace.clone(),
                    struct_def: table.struct_def.clone(),
                });
            }
        }

        // Find removed tables
        for name in baseline_names.difference(&current_names) {
            if let Some(table) = baseline_tables.get(*name) {
                diff.changes.push(SchemaChange::TableRemoved {
                    table_name: table.name.clone(),
                    namespace: table.namespace.clone(),
                });
                diff.warnings.push(format!(
                    "Table '{}' will be dropped. This is a destructive operation!",
                    table.full_name
                ));
            }
        }

        // Find column changes in existing tables
        for name in baseline_names.intersection(&current_names) {
            let baseline_table = baseline_tables.get(*name).unwrap();
            let current_table = current_tables.get(*name).unwrap();

            compare_columns(&mut diff, baseline_table, current_table);
        }

        diff
    }

    /// Generate SQLite migration SQL from the diff.
    pub fn to_sqlite_sql(&self) -> String {
        let mut sql = String::new();
        sql.push_str("-- Generated by PolyGen - Migration Diff\n");
        sql.push_str("-- Compare baseline schema with current schema\n\n");

        // Add warnings as comments
        if !self.warnings.is_empty() {
            sql.push_str("-- WARNINGS:\n");
            for warning in &self.warnings {
                sql.push_str(&format!("-- ⚠️  {}\n", warning));
            }
            sql.push('\n');
        }

        if self.changes.is_empty() {
            sql.push_str("-- No changes detected.\n");
            return sql;
        }

        for change in &self.changes {
            match change {
                SchemaChange::TableAdded {
                    table_name,
                    namespace,
                    struct_def,
                } => {
                    sql.push_str(&format!("-- Add new table: {}\n", table_name));
                    sql.push_str(&generate_create_table(namespace, struct_def));
                    sql.push('\n');
                }
                SchemaChange::TableRemoved {
                    table_name,
                    namespace,
                } => {
                    let full_name = make_table_name(namespace, table_name);
                    sql.push_str(&format!("-- ⚠️  Drop table: {} (DESTRUCTIVE)\n", full_name));
                    sql.push_str(&format!("-- DROP TABLE IF EXISTS {};\n\n", full_name));
                }
                SchemaChange::ColumnAdded {
                    table_name,
                    namespace,
                    column_name,
                    column_type,
                    is_nullable,
                } => {
                    let full_name = make_table_name(namespace, table_name);
                    let null_clause = if *is_nullable { "" } else { " NOT NULL" };
                    sql.push_str(&format!(
                        "ALTER TABLE {} ADD COLUMN {} {}{};\n\n",
                        full_name, column_name, column_type, null_clause
                    ));
                }
                SchemaChange::ColumnRemoved {
                    table_name,
                    namespace,
                    column_name,
                } => {
                    let full_name = make_table_name(namespace, table_name);
                    sql.push_str(&format!(
                        "-- ⚠️  Column '{}' removed from {} (requires table recreation in SQLite < 3.35)\n",
                        column_name, full_name
                    ));
                    sql.push_str(&format!(
                        "-- ALTER TABLE {} DROP COLUMN {};\n\n",
                        full_name, column_name
                    ));
                }
                SchemaChange::ColumnTypeChanged {
                    table_name,
                    namespace,
                    column_name,
                    old_type,
                    new_type,
                } => {
                    let full_name = make_table_name(namespace, table_name);
                    sql.push_str(&format!(
                        "-- ⚠️  Column '{}' type changed from {} to {} in {} (requires table recreation)\n\n",
                        column_name, old_type, new_type, full_name
                    ));
                }
            }
        }

        sql
    }
}

/// Extract all tables from a schema context.
fn extract_tables(schema: &SchemaContext) -> HashMap<String, TableInfo> {
    let mut tables = HashMap::new();

    for file in &schema.files {
        for ns in &file.namespaces {
            extract_tables_from_namespace(ns, &mut tables);
        }
    }

    tables
}

/// Recursively extract tables from a namespace.
fn extract_tables_from_namespace(ns: &NamespaceDef, tables: &mut HashMap<String, TableInfo>) {
    for item in &ns.items {
        match item {
            NamespaceItem::Struct(s) => {
                let full_name = make_table_name(&ns.name, &s.name);
                let mut columns = HashMap::new();

                for struct_item in &s.items {
                    if let crate::ir_model::StructItem::Field(f) = struct_item {
                        columns.insert(
                            f.name.clone(),
                            ColumnInfo {
                                name: f.name.clone(),
                                type_name: f.field_type.type_name.clone(),
                                is_nullable: f.field_type.is_option,
                            },
                        );
                    }
                }

                tables.insert(
                    full_name.clone(),
                    TableInfo {
                        name: s.name.clone(),
                        namespace: ns.name.clone(),
                        full_name,
                        columns,
                        struct_def: s.clone(),
                    },
                );
            }
            NamespaceItem::Namespace(nested) => {
                extract_tables_from_namespace(nested, tables);
            }
            _ => {}
        }
    }
}

/// Compare columns between two tables.
fn compare_columns(diff: &mut MigrationDiff, baseline: &TableInfo, current: &TableInfo) {
    let baseline_cols: HashSet<_> = baseline.columns.keys().collect();
    let current_cols: HashSet<_> = current.columns.keys().collect();

    // Find added columns
    for name in current_cols.difference(&baseline_cols) {
        if let Some(col) = current.columns.get(*name) {
            diff.changes.push(SchemaChange::ColumnAdded {
                table_name: current.name.clone(),
                namespace: current.namespace.clone(),
                column_name: col.name.clone(),
                column_type: map_to_sqlite_type(&col.type_name),
                is_nullable: col.is_nullable,
            });
        }
    }

    // Find removed columns
    for name in baseline_cols.difference(&current_cols) {
        if let Some(col) = baseline.columns.get(*name) {
            diff.changes.push(SchemaChange::ColumnRemoved {
                table_name: baseline.name.clone(),
                namespace: baseline.namespace.clone(),
                column_name: col.name.clone(),
            });
            diff.warnings.push(format!(
                "Column '{}' will be removed from '{}'. This is a destructive operation!",
                col.name, baseline.full_name
            ));
        }
    }

    // Find type changes
    for name in baseline_cols.intersection(&current_cols) {
        let baseline_col = baseline.columns.get(*name).unwrap();
        let current_col = current.columns.get(*name).unwrap();

        if baseline_col.type_name != current_col.type_name {
            diff.changes.push(SchemaChange::ColumnTypeChanged {
                table_name: baseline.name.clone(),
                namespace: baseline.namespace.clone(),
                column_name: baseline_col.name.clone(),
                old_type: map_to_sqlite_type(&baseline_col.type_name),
                new_type: map_to_sqlite_type(&current_col.type_name),
            });
            diff.warnings.push(format!(
                "Column '{}' type changed in '{}'. This requires table recreation in SQLite!",
                baseline_col.name, baseline.full_name
            ));
        }
    }
}

/// Generate SQLite table name with namespace prefix.
fn make_table_name(namespace: &str, table_name: &str) -> String {
    if namespace.is_empty() {
        table_name.to_string()
    } else {
        format!("{}_{}", namespace.replace('.', "_"), table_name)
    }
}

/// Map poly type to SQLite type.
fn map_to_sqlite_type(type_name: &str) -> String {
    match type_name {
        "string" => "TEXT".to_string(),
        "bool" => "INTEGER".to_string(),
        "u8" | "u16" | "u32" | "u64" | "i8" | "i16" | "i32" | "i64" => "INTEGER".to_string(),
        "f32" | "f64" => "REAL".to_string(),
        "bytes" => "BLOB".to_string(),
        _ => "TEXT".to_string(),
    }
}

/// Generate CREATE TABLE SQL for a struct.
fn generate_create_table(namespace: &str, s: &StructDef) -> String {
    let table_name = make_table_name(namespace, &s.name);
    let mut sql = format!("CREATE TABLE IF NOT EXISTS {} (\n", table_name);

    let mut columns = Vec::new();
    let mut pk_columns = Vec::new();

    for item in &s.items {
        if let crate::ir_model::StructItem::Field(f) = item {
            let col_type = map_to_sqlite_type(&f.field_type.type_name);
            let null_clause = if f.field_type.is_option {
                ""
            } else {
                " NOT NULL"
            };

            // Check for primary key attribute
            let is_pk = f.attributes.iter().any(|a| a == "Key");
            if is_pk {
                pk_columns.push(f.name.clone());
            }

            columns.push(format!("    {} {}{}", f.name, col_type, null_clause));
        }
    }

    sql.push_str(&columns.join(",\n"));

    if !pk_columns.is_empty() {
        sql.push_str(",\n    PRIMARY KEY (");
        sql.push_str(&pk_columns.join(", "));
        sql.push(')');
    }

    sql.push_str("\n);\n");
    sql
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_make_table_name() {
        assert_eq!(make_table_name("game.data", "ItemTable"), "game_data_ItemTable");
        assert_eq!(make_table_name("", "Player"), "Player");
    }

    #[test]
    fn test_map_to_sqlite_type() {
        assert_eq!(map_to_sqlite_type("string"), "TEXT");
        assert_eq!(map_to_sqlite_type("u32"), "INTEGER");
        assert_eq!(map_to_sqlite_type("f64"), "REAL");
        assert_eq!(map_to_sqlite_type("bytes"), "BLOB");
    }
}
