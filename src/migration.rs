//! Schema migration diff module.
//!
//! Compares two schema versions and generates migration SQL.
//! Supports two comparison modes:
//! 1. Schema-to-Schema: Compare two .poly schemas (baseline vs current)
//! 2. DB-to-Schema: Compare actual database state with .poly schema

use crate::db_introspection::{DbSchema, DbTable};
use crate::ir_model::{NamespaceDef, NamespaceItem, SchemaContext, StructDef};
use std::collections::{HashMap, HashSet};

/// Represents a detected schema change.
#[derive(Debug, Clone)]
pub enum SchemaChange {
    /// A new table was added.
    TableAdded {
        table_name: String,
        namespace: String,
        struct_def: StructDef,
    },
    /// A table was removed (warning).
    TableRemoved {
        table_name: String,
        namespace: String,
    },
    /// A new column was added to a table.
    ColumnAdded {
        table_name: String,
        namespace: String,
        column_name: String,
        column_type: String,
        is_nullable: bool,
    },
    /// A column was removed from a table (warning).
    ColumnRemoved {
        table_name: String,
        namespace: String,
        column_name: String,
    },
    /// A column type changed (requires table recreation in SQLite).
    ColumnTypeChanged {
        table_name: String,
        namespace: String,
        column_name: String,
        old_type: String,
        new_type: String,
    },
}

/// Result of comparing two schemas.
#[derive(Debug, Default)]
pub struct MigrationDiff {
    /// List of detected changes.
    pub changes: Vec<SchemaChange>,
    /// Warnings about potentially destructive operations.
    pub warnings: Vec<String>,
}

/// Represents a table for comparison purposes.
#[derive(Debug, Clone)]
struct TableInfo {
    name: String,
    namespace: String,
    full_name: String, // namespace_prefixed name for SQLite
    columns: HashMap<String, ColumnInfo>,
    struct_def: StructDef,
}

/// Represents a column for comparison purposes.
#[derive(Debug, Clone)]
struct ColumnInfo {
    name: String,
    type_name: String,
    is_nullable: bool,
}

impl MigrationDiff {
    /// Compare two schema contexts and generate a diff.
    pub fn compare(baseline: &SchemaContext, current: &SchemaContext) -> Self {
        let mut diff = MigrationDiff::default();

        // Extract tables from both schemas
        let baseline_tables = extract_tables(baseline);
        let current_tables = extract_tables(current);

        let baseline_names: HashSet<_> = baseline_tables.keys().collect();
        let current_names: HashSet<_> = current_tables.keys().collect();

        // Find added tables
        for name in current_names.difference(&baseline_names) {
            if let Some(table) = current_tables.get(*name) {
                diff.changes.push(SchemaChange::TableAdded {
                    table_name: table.name.clone(),
                    namespace: table.namespace.clone(),
                    struct_def: table.struct_def.clone(),
                });
            }
        }

        // Find removed tables
        for name in baseline_names.difference(&current_names) {
            if let Some(table) = baseline_tables.get(*name) {
                diff.changes.push(SchemaChange::TableRemoved {
                    table_name: table.name.clone(),
                    namespace: table.namespace.clone(),
                });
                diff.warnings.push(format!(
                    "Table '{}' will be dropped. This is a destructive operation!",
                    table.full_name
                ));
            }
        }

        // Find column changes in existing tables
        for name in baseline_names.intersection(&current_names) {
            let baseline_table = baseline_tables.get(*name).unwrap();
            let current_table = current_tables.get(*name).unwrap();

            compare_columns(&mut diff, baseline_table, current_table);
        }

        diff
    }

    /// Generate SQLite migration SQL from the diff.
    pub fn to_sqlite_sql(&self) -> String {
        let mut sql = String::new();
        sql.push_str("-- Generated by PolyGen - Migration Diff\n");
        sql.push_str("-- Compare baseline schema with current schema\n\n");

        // Add warnings as comments
        if !self.warnings.is_empty() {
            sql.push_str("-- WARNINGS:\n");
            for warning in &self.warnings {
                sql.push_str(&format!("-- ⚠️  {}\n", warning));
            }
            sql.push('\n');
        }

        if self.changes.is_empty() {
            sql.push_str("-- No changes detected.\n");
            return sql;
        }

        for change in &self.changes {
            match change {
                SchemaChange::TableAdded {
                    table_name,
                    namespace,
                    struct_def,
                } => {
                    sql.push_str(&format!("-- Add new table: {}\n", table_name));
                    sql.push_str(&generate_create_table(namespace, struct_def));
                    sql.push('\n');
                }
                SchemaChange::TableRemoved {
                    table_name,
                    namespace,
                } => {
                    let full_name = make_table_name(namespace, table_name);
                    sql.push_str(&format!("-- ⚠️  Drop table: {} (DESTRUCTIVE)\n", full_name));
                    sql.push_str(&format!("-- DROP TABLE IF EXISTS {};\n\n", full_name));
                }
                SchemaChange::ColumnAdded {
                    table_name,
                    namespace,
                    column_name,
                    column_type,
                    is_nullable,
                } => {
                    let full_name = make_table_name(namespace, table_name);
                    let null_clause = if *is_nullable { "" } else { " NOT NULL" };
                    sql.push_str(&format!(
                        "ALTER TABLE {} ADD COLUMN {} {}{};\n\n",
                        full_name, column_name, column_type, null_clause
                    ));
                }
                SchemaChange::ColumnRemoved {
                    table_name,
                    namespace,
                    column_name,
                } => {
                    let full_name = make_table_name(namespace, table_name);
                    sql.push_str(&format!(
                        "-- ⚠️  Column '{}' removed from {} (requires table recreation in SQLite < 3.35)\n",
                        column_name, full_name
                    ));
                    sql.push_str(&format!(
                        "-- ALTER TABLE {} DROP COLUMN {};\n\n",
                        full_name, column_name
                    ));
                }
                SchemaChange::ColumnTypeChanged {
                    table_name,
                    namespace,
                    column_name,
                    old_type,
                    new_type,
                } => {
                    let full_name = make_table_name(namespace, table_name);
                    sql.push_str(&format!(
                        "-- ⚠️  Column '{}' type changed from {} to {} in {} (requires table recreation)\n\n",
                        column_name, old_type, new_type, full_name
                    ));
                }
            }
        }

        sql
    }

    /// Generate MySQL migration SQL from the diff.
    pub fn to_mysql_sql(&self) -> String {
        let mut sql = String::new();
        sql.push_str("-- Generated by PolyGen - Migration Diff (MySQL)\n");
        sql.push_str("-- Compare baseline schema with current schema\n\n");

        // Add warnings as comments
        if !self.warnings.is_empty() {
            sql.push_str("-- WARNINGS:\n");
            for warning in &self.warnings {
                sql.push_str(&format!("-- ⚠️  {}\n", warning));
            }
            sql.push('\n');
        }

        if self.changes.is_empty() {
            sql.push_str("-- No changes detected.\n");
            return sql;
        }

        for change in &self.changes {
            match change {
                SchemaChange::TableAdded {
                    table_name,
                    namespace,
                    struct_def,
                } => {
                    sql.push_str(&format!("-- Add new table: {}\n", table_name));
                    sql.push_str(&generate_create_table_mysql(namespace, struct_def));
                    sql.push('\n');
                }
                SchemaChange::TableRemoved {
                    table_name,
                    namespace,
                } => {
                    let full_name = make_table_name(namespace, table_name);
                    sql.push_str(&format!("-- ⚠️  Drop table: {} (DESTRUCTIVE)\n", full_name));
                    sql.push_str(&format!("-- DROP TABLE IF EXISTS {};\n\n", full_name));
                }
                SchemaChange::ColumnAdded {
                    table_name,
                    namespace,
                    column_name,
                    column_type,
                    is_nullable,
                } => {
                    let full_name = make_table_name(namespace, table_name);
                    let mysql_type = map_to_mysql_type(column_type);
                    let null_clause = if *is_nullable { " NULL" } else { " NOT NULL" };
                    sql.push_str(&format!(
                        "ALTER TABLE {} ADD COLUMN {} {}{};\n\n",
                        full_name, column_name, mysql_type, null_clause
                    ));
                }
                SchemaChange::ColumnRemoved {
                    table_name,
                    namespace,
                    column_name,
                } => {
                    let full_name = make_table_name(namespace, table_name);
                    sql.push_str(&format!(
                        "-- ⚠️  Drop column: {}.{} (DESTRUCTIVE)\n",
                        full_name, column_name
                    ));
                    sql.push_str(&format!(
                        "-- ALTER TABLE {} DROP COLUMN {};\n\n",
                        full_name, column_name
                    ));
                }
                SchemaChange::ColumnTypeChanged {
                    table_name,
                    namespace,
                    column_name,
                    old_type,
                    new_type,
                } => {
                    let full_name = make_table_name(namespace, table_name);
                    let mysql_new_type = map_to_mysql_type(new_type);
                    sql.push_str(&format!(
                        "-- Column '{}' type changed from {} to {}\n",
                        column_name, old_type, new_type
                    ));
                    sql.push_str(&format!(
                        "ALTER TABLE {} MODIFY COLUMN {} {};\n\n",
                        full_name, column_name, mysql_new_type
                    ));
                }
            }
        }

        sql
    }

    /// Compare a database schema with a poly schema context.
    ///
    /// This is the DB-to-Schema comparison mode:
    /// - `db_schema`: Current state read from actual database
    /// - `poly_schema`: Target state defined in .poly files
    ///
    /// Returns changes needed to migrate DB to match .poly schema.
    pub fn compare_db(db_schema: &DbSchema, poly_schema: &SchemaContext) -> Self {
        let mut diff = MigrationDiff::default();

        // Extract target tables from poly schema
        let poly_tables = extract_tables(poly_schema);

        // Convert DB tables to comparable format
        let db_table_names: HashSet<_> = db_schema.tables.keys().cloned().collect();
        let poly_table_names: HashSet<_> = poly_tables.keys().cloned().collect();

        // Find tables in poly but not in DB (need to CREATE)
        for name in poly_table_names.difference(&db_table_names) {
            if let Some(table) = poly_tables.get(name) {
                diff.changes.push(SchemaChange::TableAdded {
                    table_name: table.name.clone(),
                    namespace: table.namespace.clone(),
                    struct_def: table.struct_def.clone(),
                });
            }
        }

        // Find tables in DB but not in poly (may need to DROP)
        for name in db_table_names.difference(&poly_table_names) {
            // Try to extract namespace and table name from full name
            let (namespace, table_name) = parse_full_table_name(name);
            diff.changes.push(SchemaChange::TableRemoved {
                table_name,
                namespace,
            });
            diff.warnings.push(format!(
                "Table '{}' exists in DB but not in schema. Consider dropping it.",
                name
            ));
        }

        // Find column changes in tables that exist in both
        for name in db_table_names.intersection(&poly_table_names) {
            let db_table = db_schema.tables.get(name).unwrap();
            let poly_table = poly_tables.get(name).unwrap();

            compare_db_columns(&mut diff, db_table, poly_table);
        }

        diff
    }
}

/// Parse a full table name (namespace_TableName) back into parts.
fn parse_full_table_name(full_name: &str) -> (String, String) {
    // Try to find the last underscore followed by a capital letter
    // e.g., "game_data_ItemTable" -> ("game.data", "ItemTable")
    let mut last_ns_end = 0;
    let chars: Vec<char> = full_name.chars().collect();

    for i in 0..chars.len() {
        if chars[i] == '_' && i + 1 < chars.len() && chars[i + 1].is_uppercase() {
            last_ns_end = i;
        }
    }

    if last_ns_end > 0 {
        let namespace = full_name[..last_ns_end].replace('_', ".");
        let table_name = full_name[last_ns_end + 1..].to_string();
        (namespace, table_name)
    } else {
        // No namespace prefix
        (String::new(), full_name.to_string())
    }
}

/// Compare columns between a DB table and a poly table.
fn compare_db_columns(diff: &mut MigrationDiff, db_table: &DbTable, poly_table: &TableInfo) {
    let db_col_names: HashSet<_> = db_table.columns.keys().cloned().collect();
    let poly_col_names: HashSet<_> = poly_table.columns.keys().cloned().collect();

    // Columns in poly but not in DB (need to ADD)
    for name in poly_col_names.difference(&db_col_names) {
        if let Some(col) = poly_table.columns.get(name) {
            diff.changes.push(SchemaChange::ColumnAdded {
                table_name: poly_table.name.clone(),
                namespace: poly_table.namespace.clone(),
                column_name: col.name.clone(),
                column_type: map_to_sqlite_type(&col.type_name),
                is_nullable: col.is_nullable,
            });
        }
    }

    // Columns in DB but not in poly (may need to DROP)
    for name in db_col_names.difference(&poly_col_names) {
        diff.changes.push(SchemaChange::ColumnRemoved {
            table_name: poly_table.name.clone(),
            namespace: poly_table.namespace.clone(),
            column_name: name.clone(),
        });
        diff.warnings.push(format!(
            "Column '{}' in table '{}' exists in DB but not in schema.",
            name, poly_table.full_name
        ));
    }

    // Check for type changes in columns that exist in both
    for name in db_col_names.intersection(&poly_col_names) {
        let db_col = db_table.columns.get(name).unwrap();
        let poly_col = poly_table.columns.get(name).unwrap();

        let db_type_normalized = normalize_sqlite_type(&db_col.db_type);
        let poly_type_sqlite = map_to_sqlite_type(&poly_col.type_name);

        if db_type_normalized != poly_type_sqlite {
            diff.changes.push(SchemaChange::ColumnTypeChanged {
                table_name: poly_table.name.clone(),
                namespace: poly_table.namespace.clone(),
                column_name: name.clone(),
                old_type: db_col.db_type.clone(),
                new_type: poly_type_sqlite,
            });
            diff.warnings.push(format!(
                "Column '{}' type mismatch in '{}': DB has '{}', schema wants '{}'",
                name, poly_table.full_name, db_col.db_type, poly_col.type_name
            ));
        }
    }
}

/// Normalize SQLite type names for comparison.
fn normalize_sqlite_type(db_type: &str) -> String {
    match db_type.to_uppercase().as_str() {
        "INT" | "INTEGER" | "BIGINT" | "SMALLINT" | "TINYINT" => "INTEGER".to_string(),
        "REAL" | "FLOAT" | "DOUBLE" => "REAL".to_string(),
        "TEXT" | "VARCHAR" | "CHAR" | "CLOB" => "TEXT".to_string(),
        "BLOB" => "BLOB".to_string(),
        other => other.to_uppercase(),
    }
}

/// Extract all tables from a schema context.
fn extract_tables(schema: &SchemaContext) -> HashMap<String, TableInfo> {
    let mut tables = HashMap::new();

    for file in &schema.files {
        for ns in &file.namespaces {
            extract_tables_from_namespace(ns, &mut tables);
        }
    }

    tables
}

/// Recursively extract tables from a namespace.
fn extract_tables_from_namespace(ns: &NamespaceDef, tables: &mut HashMap<String, TableInfo>) {
    for item in &ns.items {
        match item {
            NamespaceItem::Struct(s) => {
                let full_name = make_table_name(&ns.name, &s.name);
                let mut columns = HashMap::new();

                for struct_item in &s.items {
                    if let crate::ir_model::StructItem::Field(f) = struct_item {
                        columns.insert(
                            f.name.clone(),
                            ColumnInfo {
                                name: f.name.clone(),
                                type_name: f.field_type.type_name.clone(),
                                is_nullable: f.field_type.is_option,
                            },
                        );
                    }
                }

                tables.insert(
                    full_name.clone(),
                    TableInfo {
                        name: s.name.clone(),
                        namespace: ns.name.clone(),
                        full_name,
                        columns,
                        struct_def: s.clone(),
                    },
                );
            }
            NamespaceItem::Namespace(nested) => {
                extract_tables_from_namespace(nested, tables);
            }
            _ => {}
        }
    }
}

/// Compare columns between two tables.
fn compare_columns(diff: &mut MigrationDiff, baseline: &TableInfo, current: &TableInfo) {
    let baseline_cols: HashSet<_> = baseline.columns.keys().collect();
    let current_cols: HashSet<_> = current.columns.keys().collect();

    // Find added columns
    for name in current_cols.difference(&baseline_cols) {
        if let Some(col) = current.columns.get(*name) {
            diff.changes.push(SchemaChange::ColumnAdded {
                table_name: current.name.clone(),
                namespace: current.namespace.clone(),
                column_name: col.name.clone(),
                column_type: map_to_sqlite_type(&col.type_name),
                is_nullable: col.is_nullable,
            });
        }
    }

    // Find removed columns
    for name in baseline_cols.difference(&current_cols) {
        if let Some(col) = baseline.columns.get(*name) {
            diff.changes.push(SchemaChange::ColumnRemoved {
                table_name: baseline.name.clone(),
                namespace: baseline.namespace.clone(),
                column_name: col.name.clone(),
            });
            diff.warnings.push(format!(
                "Column '{}' will be removed from '{}'. This is a destructive operation!",
                col.name, baseline.full_name
            ));
        }
    }

    // Find type changes
    for name in baseline_cols.intersection(&current_cols) {
        let baseline_col = baseline.columns.get(*name).unwrap();
        let current_col = current.columns.get(*name).unwrap();

        if baseline_col.type_name != current_col.type_name {
            diff.changes.push(SchemaChange::ColumnTypeChanged {
                table_name: baseline.name.clone(),
                namespace: baseline.namespace.clone(),
                column_name: baseline_col.name.clone(),
                old_type: map_to_sqlite_type(&baseline_col.type_name),
                new_type: map_to_sqlite_type(&current_col.type_name),
            });
            diff.warnings.push(format!(
                "Column '{}' type changed in '{}'. This requires table recreation in SQLite!",
                baseline_col.name, baseline.full_name
            ));
        }
    }
}

/// Generate SQLite table name with namespace prefix.
fn make_table_name(namespace: &str, table_name: &str) -> String {
    if namespace.is_empty() {
        table_name.to_string()
    } else {
        format!("{}_{}", namespace.replace('.', "_"), table_name)
    }
}

/// Map poly type to SQLite type.
fn map_to_sqlite_type(type_name: &str) -> String {
    match type_name {
        "string" => "TEXT".to_string(),
        "bool" => "INTEGER".to_string(),
        "u8" | "u16" | "u32" | "u64" | "i8" | "i16" | "i32" | "i64" => "INTEGER".to_string(),
        "f32" | "f64" => "REAL".to_string(),
        "bytes" => "BLOB".to_string(),
        _ => "TEXT".to_string(),
    }
}

/// Generate CREATE TABLE SQL for a struct.
fn generate_create_table(namespace: &str, s: &StructDef) -> String {
    let table_name = make_table_name(namespace, &s.name);
    let mut sql = format!("CREATE TABLE IF NOT EXISTS {} (\n", table_name);

    let mut columns = Vec::new();
    let mut pk_columns = Vec::new();

    for item in &s.items {
        if let crate::ir_model::StructItem::Field(f) = item {
            let col_type = map_to_sqlite_type(&f.field_type.type_name);
            let null_clause = if f.field_type.is_option {
                ""
            } else {
                " NOT NULL"
            };

            // Check for primary key attribute
            let is_pk = f.attributes.iter().any(|a| a == "Key");
            if is_pk {
                pk_columns.push(f.name.clone());
            }

            columns.push(format!("    {} {}{}", f.name, col_type, null_clause));
        }
    }

    sql.push_str(&columns.join(",\n"));

    if !pk_columns.is_empty() {
        sql.push_str(",\n    PRIMARY KEY (");
        sql.push_str(&pk_columns.join(", "));
        sql.push(')');
    }

    sql.push_str("\n);\n");
    sql
}

/// Map poly type to MySQL type.
fn map_to_mysql_type(type_name: &str) -> String {
    match type_name {
        "string" | "TEXT" => "VARCHAR(255)".to_string(),
        "bool" | "INTEGER" => "INT".to_string(),
        "u8" | "i8" => "TINYINT".to_string(),
        "u16" | "i16" => "SMALLINT".to_string(),
        "u32" | "i32" => "INT".to_string(),
        "u64" | "i64" => "BIGINT".to_string(),
        "f32" | "REAL" => "FLOAT".to_string(),
        "f64" => "DOUBLE".to_string(),
        "bytes" | "BLOB" => "BLOB".to_string(),
        _ => "VARCHAR(255)".to_string(),
    }
}

/// Generate CREATE TABLE SQL for MySQL.
fn generate_create_table_mysql(namespace: &str, s: &StructDef) -> String {
    let table_name = make_table_name(namespace, &s.name);
    let mut sql = format!("CREATE TABLE IF NOT EXISTS {} (\n", table_name);

    let mut columns = Vec::new();
    let mut pk_columns = Vec::new();

    for item in &s.items {
        if let crate::ir_model::StructItem::Field(f) = item {
            let col_type = map_to_mysql_type(&f.field_type.type_name);
            let null_clause = if f.field_type.is_option {
                " NULL"
            } else {
                " NOT NULL"
            };

            // Check for primary key attribute
            let is_pk = f.attributes.iter().any(|a| a == "Key");
            if is_pk {
                pk_columns.push(f.name.clone());
            }

            columns.push(format!("    {} {}{}", f.name, col_type, null_clause));
        }
    }

    sql.push_str(&columns.join(",\n"));

    if !pk_columns.is_empty() {
        sql.push_str(",\n    PRIMARY KEY (");
        sql.push_str(&pk_columns.join(", "));
        sql.push(')');
    }

    sql.push_str("\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n");
    sql
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_make_table_name() {
        assert_eq!(
            make_table_name("game.data", "ItemTable"),
            "game_data_ItemTable"
        );
        assert_eq!(make_table_name("", "Player"), "Player");
    }

    #[test]
    fn test_map_to_sqlite_type() {
        assert_eq!(map_to_sqlite_type("string"), "TEXT");
        assert_eq!(map_to_sqlite_type("u32"), "INTEGER");
        assert_eq!(map_to_sqlite_type("f64"), "REAL");
        assert_eq!(map_to_sqlite_type("bytes"), "BLOB");
    }
}
