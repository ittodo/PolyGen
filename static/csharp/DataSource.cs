// This file is a part of the Polygen common utility library.
// It is not generated by the Polygen tool, and can be safely modified.
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace Polygen.Common
{
    /// <summary>
    /// Defines a common interface for reading data from various sources.
    /// </summary>
    public interface IDataSourceReader
    {
        /// <summary>
        /// Reads all rows from the data source.
        /// </summary>
        /// <returns>An enumerable of dictionaries, where each dictionary represents a row (key=column name, value=cell value).</returns>
        IEnumerable<IDictionary<string, string>> ReadRows();
    }

    /// <summary>
    /// A factory class to create an appropriate data source reader based on the file extension.
    /// </summary>
    public static class DataSourceFactory
    {
        public static IDataSourceReader CreateReader(string filePath)
        {
            var extension = Path.GetExtension(filePath).ToLowerInvariant();
            switch (extension)
            {
                case ".csv":
                    return new CsvReader(filePath);
                // Future readers can be added here, e.g.:
                // case ".json":
                //     return new JsonReader(filePath);
                default:
                    throw new NotSupportedException($"File type '{extension}' is not supported.");
            }
        }

        public static T ConvertSingleValue<T>(IDictionary<string, string> row, string columnName)
        {
            if (!row.TryGetValue(columnName, out var value) || string.IsNullOrEmpty(value))
            {
                return default(T);
            }

            try
            {
                var targetType = Nullable.GetUnderlyingType(typeof(T)) ?? typeof(T);

                if (targetType.IsEnum)
                {
                    return (T)Enum.Parse(targetType, value, true); // true for ignoreCase
                }

                return (T)Convert.ChangeType(value, targetType, CultureInfo.InvariantCulture);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error converting value ''{value}'' for column ''{columnName}'' to type {typeof(T).Name}: {ex.Message}");
                return default(T);
            }
        }

        public static List<T> ConvertListValue<T>(IDictionary<string, string> row, string columnName, char separator = ';')
        {
            if (!row.TryGetValue(columnName, out var value) || string.IsNullOrEmpty(value))
            {
                return new List<T>();
            }

            var list = new List<T>();
            foreach (var itemString in value.Split(separator, StringSplitOptions.RemoveEmptyEntries))
            {
                try
                {
                    // Recursively call ConvertSingleValue for each item in the list
                    list.Add(ConvertSingleValue<T>(new Dictionary<string, string> { { "temp", itemString.Trim() } }, "temp"));
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error converting list item ''{itemString}'' for column ''{columnName}'': {ex.Message}");
                }
            }
            return list;
        }
    }

    /// <summary>
    /// Reads data from a CSV file.
    /// Assumes the first line of the CSV is the header row.
    /// </summary>
    public class CsvReader : IDataSourceReader
    {
        private readonly string _filePath;

        public CsvReader(string filePath)
        {
            if (!File.Exists(filePath))
            {
                throw new FileNotFoundException("The specified CSV file was not found.", filePath);
            }
            _filePath = filePath;
        }

        public IEnumerable<IDictionary<string, string>> ReadRows()
        {
            var lines = File.ReadAllLines(_filePath);
            if (lines.Length == 0)
            {
                yield break;
            }

            var headers = lines[0].Split(',').Select(h => h.Trim()).ToArray();

            for (int i = 1; i < lines.Length; i++)
            {
                var values = lines[i].Split(',');
                var row = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

                for (int j = 0; j < headers.Length && j < values.Length; j++)
                {
                    row[headers[j]] = values[j];
                }
                yield return row;
            }
        }
    }
}
