// This file is a part of the Polygen common utility library.
// It is not generated by the Polygen tool, and can be safely modified.
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Globalization;

namespace Polygen.Common
{
    /// <summary>
    /// Defines a common interface for reading data from various sources.
    /// </summary>
    public interface IDataSourceReader
    {
        /// <summary>
        /// Reads all rows from the data source.
        /// </summary>
        /// <returns>An enumerable of dictionaries, where each dictionary represents a row (key=column name, value=cell value).</returns>
        IEnumerable<IDictionary<string, string>> ReadRows();
    }

    /// <summary>
    /// A factory class to create an appropriate data source reader based on the file extension.
    /// </summary>
    public static class DataSourceFactory
    {
        public static IDataSourceReader CreateReader(string filePath)
        {
            var extension = Path.GetExtension(filePath).ToLowerInvariant();
            switch (extension)
            {
                case ".csv":
                    return new CsvReader(filePath);
                // Future readers can be added here, e.g.:
                // case ".json":
                //     return new JsonReader(filePath);
                default:
                    throw new NotSupportedException($"File type '{extension}' is not supported.");
            }
        }

        public static IDataSourceReader CreateReader(string filePath, char separator)
        {
            var extension = Path.GetExtension(filePath).ToLowerInvariant();
            switch (extension)
            {
                case ".csv":
                    return new CsvReader(filePath, separator);
                default:
                    throw new NotSupportedException($"File type '{extension}' is not supported.");
            }
        }

        public static T ConvertSingleValue<T>(IDictionary<string, string> row, string columnName)
        {
            if (!row.TryGetValue(columnName, out var value) || string.IsNullOrEmpty(value))
            {
                return default(T);
            }
            return ConvertValue<T>(value);
        }

        public static List<T> ConvertListValue<T>(IDictionary<string, string> row, string columnName, char separator = ';')
        {
            if (!row.TryGetValue(columnName, out var value) || string.IsNullOrEmpty(value))
            {
                return new List<T>();
            }

            var list = new List<T>();
            foreach (var itemString in value.Split(separator, StringSplitOptions.RemoveEmptyEntries))
            {
                try
                {
                    list.Add(ConvertValue<T>(itemString.Trim()));
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error converting list item ''{itemString}'' for column ''{columnName}'': {ex.Message}");
                }
            }
            return list;
        }

        public static T ConvertValue<T>(string valueString)
        {
            if (string.IsNullOrEmpty(valueString))
            {
                return default(T);
            }
            var targetType = Nullable.GetUnderlyingType(typeof(T)) ?? typeof(T);

            // Fast-paths for common primitives and enums
            object boxed;
            if (targetType == typeof(string)) return (T)(object)valueString;
            if (targetType == typeof(bool)) { if (bool.TryParse(valueString, out var v)) return (T)(object)v; if (valueString == "1") return (T)(object)true; if (valueString == "0") return (T)(object)false; return default(T); }
            if (targetType == typeof(byte)) { if (byte.TryParse(valueString, NumberStyles.Integer, CultureInfo.InvariantCulture, out var v)) return (T)(object)v; return default(T); }
            if (targetType == typeof(sbyte)) { if (sbyte.TryParse(valueString, NumberStyles.Integer, CultureInfo.InvariantCulture, out var v)) return (T)(object)v; return default(T); }
            if (targetType == typeof(short)) { if (short.TryParse(valueString, NumberStyles.Integer, CultureInfo.InvariantCulture, out var v)) return (T)(object)v; return default(T); }
            if (targetType == typeof(ushort)) { if (ushort.TryParse(valueString, NumberStyles.Integer, CultureInfo.InvariantCulture, out var v)) return (T)(object)v; return default(T); }
            if (targetType == typeof(int)) { if (int.TryParse(valueString, NumberStyles.Integer, CultureInfo.InvariantCulture, out var v)) return (T)(object)v; return default(T); }
            if (targetType == typeof(uint)) { if (uint.TryParse(valueString, NumberStyles.Integer, CultureInfo.InvariantCulture, out var v)) return (T)(object)v; return default(T); }
            if (targetType == typeof(long)) { if (long.TryParse(valueString, NumberStyles.Integer, CultureInfo.InvariantCulture, out var v)) return (T)(object)v; return default(T); }
            if (targetType == typeof(ulong)) { if (ulong.TryParse(valueString, NumberStyles.Integer, CultureInfo.InvariantCulture, out var v)) return (T)(object)v; return default(T); }
            if (targetType == typeof(float)) { if (float.TryParse(valueString, NumberStyles.Float | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out var v)) return (T)(object)v; return default(T); }
            if (targetType == typeof(double)) { if (double.TryParse(valueString, NumberStyles.Float | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out var v)) return (T)(object)v; return default(T); }
            if (targetType == typeof(decimal)) { if (decimal.TryParse(valueString, NumberStyles.Float | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out var v)) return (T)(object)v; return default(T); }

            if (targetType.IsEnum)
            {
                if (Enum.TryParse(targetType, valueString, true, out object? enumVal) && enumVal != null)
                {
                    return (T)enumVal;
                }
                // also allow numeric enums
                if (long.TryParse(valueString, NumberStyles.Integer, CultureInfo.InvariantCulture, out var lv))
                {
                    try { boxed = Enum.ToObject(targetType, lv); return (T)boxed; } catch { return default(T); }
                }
                return default(T);
            }

            // Fallback for other reference types
            try { boxed = Convert.ChangeType(valueString, targetType, CultureInfo.InvariantCulture); return (T)boxed; }
            catch { return default(T); }
        }
    }

    /// <summary>
    /// Reads data from a CSV file.
    /// Assumes the first line of the CSV is the header row.
    /// </summary>
    public class CsvReader : IDataSourceReader
    {
        private readonly string _filePath;
        private readonly char _sep;

        public CsvReader(string filePath)
            : this(filePath, ',')
        {
        }

        public CsvReader(string filePath, char separator)
        {
            if (!File.Exists(filePath))
            {
                throw new FileNotFoundException("The specified CSV file was not found.", filePath);
            }
            _filePath = filePath;
            _sep = separator;
        }

        public IEnumerable<IDictionary<string, string>> ReadRows()
        {
            var lines = File.ReadAllLines(_filePath);
            if (lines.Length == 0)
            {
                yield break;
            }

            var headers = lines[0].Split(_sep).Select(h => h.Trim()).ToArray();

            for (int i = 1; i < lines.Length; i++)
            {
                var values = lines[i].Split(_sep);
                var row = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

                for (int j = 0; j < headers.Length && j < values.Length; j++)
                {
                    row[headers[j]] = values[j];
                }
                yield return row;
            }
        }
    }
}
