%logic
// TypeScript Zod Schema Generator
// Generates Zod validation schemas from .poly schema files

import "templates/rhai_utils/indent" as indent_utils;
import "templates/typescript/rhai_utils/type_mapping" as ts_types;

fn generate_zod_enum(e, current_ts_path) {
    let ts_path = if current_ts_path != () && current_ts_path != "" {
        current_ts_path
    } else {
        ""
    };

    let types_ref = if ts_path != "" {
        "Types." + ts_path + "." + e.name
    } else {
        "Types." + e.name
    };

    let result = "";
    result += "export const " + e.name + "Schema = z.nativeEnum(" + types_ref + ");\n";
    result
}

fn generate_zod_interface(s, current_ns, current_ts_path) {
    let ns_fqn = if current_ns != () { current_ns } else { "" };
    let ts_path = if current_ts_path != () && current_ts_path != "" { current_ts_path } else { "" };

    // Generate fields
    let fields = "";
    let field_count = 0;
    for item in s.items {
        if item.is_field() {
            let f = item.as_field();
            let field_name = to_camel_case(f.name);
            let zod_type = ts_types::map_field_to_zod_with_constraints(f, ns_fqn);

            if field_count > 0 {
                fields += ",\n";
            }
            fields += "    " + field_name + ": " + zod_type;
            field_count += 1;
        }
    }

    // Generate embedded schemas (before parent)
    let embedded = "";
    for item in s.items {
        if item.is_embedded_struct() {
            let es = item.as_embedded_struct();
            let res = generate_zod_interface(es, ns_fqn, ts_path);
            embedded += res + "\n";
        } else if item.is_inline_enum() {
            let ie = item.as_inline_enum();
            let res = generate_zod_enum(ie, ts_path);
            embedded += res + "\n";
        }
    }

    let result = "";
    result += embedded;
    result += "export const " + s.name + "Schema = z.object({\n";
    result += fields;
    if field_count > 0 {
        result += "\n";
    }
    result += "});\n";
    result += "export type " + s.name + " = z.infer<typeof " + s.name + "Schema>;\n";

    // Add Pack/Unpack functions for embeds with @pack annotation
    if s.is_embed && s.pack_separator != () {
        let sep = s.pack_separator;
        let field_list = [];

        for item in s.items {
            if item.is_field() {
                let f = item.as_field();
                field_list.push(f);
            }
        }

        if field_list.len() > 0 {
            // Pack function
            result += "\n/** Packs all fields into a single string using '" + sep + "' as separator. */\n";
            result += "export function pack" + s.name + "(value: " + s.name + "): string {\n";
            result += "    return [";
            for i in 0..field_list.len() {
                let f = field_list[i];
                let field_name = to_camel_case(f.name);
                if i > 0 {
                    result += ", ";
                }
                result += "value." + field_name;
            }
            result += "].join('" + sep + "');\n";
            result += "}\n";

            // Unpack function
            result += "\n/** Unpacks a string into fields using '" + sep + "' as separator. */\n";
            result += "export function unpack" + s.name + "(value: string): " + s.name + " {\n";
            result += "    const parts = value.split('" + sep + "');\n";
            result += "    if (parts.length !== " + field_list.len() + ") {\n";
            result += "        throw new Error(`Expected " + field_list.len() + " parts but got ${parts.length} when unpacking " + s.name + "`);\n";
            result += "    }\n";
            result += "    return {\n";

            for i in 0..field_list.len() {
                let f = field_list[i];
                let field_name = to_camel_case(f.name);
                let type_name = f.field_type.type_name;
                let parse_expr = "";

                if type_name == "string" {
                    parse_expr = "parts[" + i + "]";
                } else if type_name == "bool" {
                    parse_expr = "parts[" + i + "] === 'true'";
                } else if type_name == "f32" || type_name == "f64" {
                    parse_expr = "parseFloat(parts[" + i + "])";
                } else if type_name == "u8" || type_name == "u16" || type_name == "u32" || type_name == "u64" || type_name == "i8" || type_name == "i16" || type_name == "i32" || type_name == "i64" {
                    parse_expr = "parseInt(parts[" + i + "], 10)";
                } else {
                    parse_expr = "parts[" + i + "]";
                }

                result += "        " + field_name + ": " + parse_expr;
                if i < field_list.len() - 1 {
                    result += ",";
                }
                result += "\n";
            }

            result += "    };\n";
            result += "}\n";

            // TryUnpack function
            result += "\n/** Tries to unpack a string. Returns null on failure. */\n";
            result += "export function tryUnpack" + s.name + "(value: string): " + s.name + " | null {\n";
            result += "    try {\n";
            result += "        return unpack" + s.name + "(value);\n";
            result += "    } catch {\n";
            result += "        return null;\n";
            result += "    }\n";
            result += "}\n";
        }
    }

    result
}

fn generate_zod_namespace(ns, parent_ns_path) {
    let ns_name = to_pascal_case(ns.name);

    let parent_path = if parent_ns_path != () && parent_ns_path != "" { parent_ns_path } else { "" };
    let current_ts_path = if parent_path != "" {
        parent_path + "." + ns_name
    } else {
        ns_name
    };

    let members = "";
    let nested_ns = "";

    let current_ns = ns.name;

    for item in ns.items {
        if item.is_struct() {
            let s = item.as_struct();
            let res = generate_zod_interface(s, current_ns, current_ts_path);
            members += indent_utils::indent_text(res, 1) + "\n";
        } else if item.is_enum() {
            let e = item.as_enum();
            let res = generate_zod_enum(e, current_ts_path);
            members += indent_utils::indent_text(res, 1) + "\n";
        } else if item.is_namespace() {
            let child = item.as_namespace();
            let res = generate_zod_namespace(child, current_ts_path);
            nested_ns += indent_utils::indent_text(res, 1) + "\n";
        }
    }

    let block = "";
    block += "export namespace " + ns_name + " {\n";
    block += members;
    block += nested_ns;
    block += "}\n";

    block
}

for file in schema.files {
    if file.path == () || file.path == "" {
        continue;
    }

    let parts = file.path.split("/");
    let filename = parts[parts.len - 1];

    let output_filename = filename;
    output_filename.replace(".poly", ".schema.ts");
    let final_path = output_dir + "/typescript/" + output_filename;

    let file_content = "";

    file_content += "// Generated by PolyGen - Zod Schemas\n";
    file_content += "// Source: " + file.path + "\n";
    file_content += "// Do not edit manually!\n";
    file_content += "\n";

    file_content += "import { z } from 'zod';\n";

    let types_file = filename;
    types_file.replace(".poly", "");
    file_content += "import * as Types from './" + types_file + "';\n";
    file_content += "\n";

    for ns in file.namespaces {
        file_content += generate_zod_namespace(ns, "");
        file_content += "\n";
    }

    print("Generating file: " + final_path);
    write_file(final_path, file_content);
}
%endlogic
