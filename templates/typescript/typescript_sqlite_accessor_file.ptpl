%logic
// TypeScript SQLite Accessor Generator
// Generates a typed SQLite accessor for @datasource("sqlite") tables
// Uses better-sqlite3 package
// Converted to 방식 A

import "templates/typescript/rhai_utils/type_mapping" as ts_types;

fn join_with(arr, sep) {
    let result = "";
    let i = 0;
    for item in arr {
        if i > 0 { result += sep; }
        result += item;
        i += 1;
    }
    result
}

fn is_sqlite_table(struct_datasource, ns_datasource) {
    if struct_datasource != () && struct_datasource != "" {
        return struct_datasource == "sqlite";
    }
    if ns_datasource != () && ns_datasource != "" {
        return ns_datasource == "sqlite";
    }
    return false;
}

fn ts_type(type_name) {
    switch type_name {
        "string" => "string",
        "bool" => "boolean",
        "bytes" => "Buffer",
        "u8" | "u16" | "u32" | "u64" | "i8" | "i16" | "i32" | "i64" | "f32" | "f64" => "number",
        _ => type_name
    }
}

fn remove_poly_extension(filename) {
    let len = filename.len();
    let poly_len = 5;
    if len > poly_len {
        let suffix_start = len - poly_len;
        let suffix = filename.sub_string(suffix_start, poly_len);
        if suffix == ".poly" {
            return filename.sub_string(0, suffix_start);
        }
    }
    filename
}

fn to_camel(name) {
    let result = "";
    let capitalize_next = false;

    for i in 0..name.len() {
        let c = name.sub_string(i, 1);
        if c == "_" {
            capitalize_next = true;
        } else if capitalize_next {
            result += c.to_upper();
            capitalize_next = false;
        } else if i == 0 {
            result += c.to_lower();
        } else {
            result += c;
        }
    }
    result
}

// Generate typed table class body for a single table
fn generate_table_class(tbl) {
    let s = tbl.struct_def;
    let result = "";

    result += "/** Table accessor for " + tbl.name + ". */\n";
    result += "export class " + tbl.name + "Table extends DbTable<" + tbl.full_type + "> {\n";
    result += "  constructor() { super('" + tbl.table_name + "'); }\n\n";

    result += "  /** Loads all records from the database. */\n";
    result += "  load(db: Database.Database): void {\n";
    result += "    this.cache = [];\n";
    result += "    const stmt = db.prepare(`SELECT * FROM ${this.tableName}`);\n";
    result += "    for (const row of stmt.iterate()) {\n";
    result += "      this.cache.push(this.mapRow(row as Record<string, unknown>));\n";
    result += "    }\n";
    result += "  }\n";

    if tbl.has_id {
        result += "\n";
        result += "  /** Gets a record by its ID. */\n";
        result += "  getById(db: Database.Database, id: " + tbl.id_type + "): " + tbl.full_type + " | undefined {\n";
        result += "    const stmt = db.prepare(`SELECT * FROM ${this.tableName} WHERE " + tbl.id_field + " = ?`);\n";
        result += "    const row = stmt.get(id) as Record<string, unknown> | undefined;\n";
        result += "    return row ? this.mapRow(row) : undefined;\n";
        result += "  }\n";
    }

    result += "\n  private mapRow(row: Record<string, unknown>): " + tbl.full_type + " {\n";
    result += "    return {\n";

    let field_idx = 0;
    for item in s.items {
        if item.is_field() {
            let f = item.as_field();
            let type_name = f.field_type.type_name;
            let ts_t = ts_type(type_name);
            let camel_name = to_camel(f.name);

            let accessor = "row['" + f.name + "']";
            if ts_t == "boolean" {
                accessor = "Boolean(" + accessor + ")";
            } else {
                accessor = accessor + " as " + ts_t;
            }

            if field_idx > 0 { result += ",\n"; }
            result += "      " + camel_name + ": " + accessor;
            field_idx += 1;
        }
    }

    result += "\n    };\n";
    result += "  }\n";
    result += "}";

    return result;
}

// ============================================================
// Data preparation
// ============================================================

// Collect all SQLite tables
let sqlite_tables = [];

for file in schema.files {
    if file.path == () || file.path == "" { continue; }

    for ns in file.namespaces {
        let ns_datasource = ns.datasource;

        for item in ns.items {
            if item.is_struct() {
                let s = item.as_struct();
                if is_sqlite_table(s.datasource, ns_datasource) {
                    let ns_parts = ns.name.split(".");
                    let table_name = join_with(ns_parts, "_") + "_" + s.name;

                    // Determine type path
                    let ns_type_path = "";
                    for part in ns_parts {
                        let pascal_part = part.sub_string(0, 1).to_upper() + part.sub_string(1, part.len() - 1);
                        ns_type_path += pascal_part;
                    }
                    let full_type = "Types." + ns_type_path + "." + s.name;

                    sqlite_tables.push(#{
                        name: s.name,
                        fqn: s.fqn,
                        ns_name: ns.name,
                        table_name: table_name,
                        full_type: full_type,
                        struct_def: s
                    });
                }
            }
        }
    }
}

let has_tables = sqlite_tables.len() > 0;

// Determine main module import path
let main_module = "./schema";
for file in schema.files {
    let fp = file.path;
    if fp != () && fp != "" {
        let base_name = fp;
        if fp.contains("/") {
            let parts = fp.split("/");
            base_name = parts[parts.len() - 1];
        }
        let name_without_ext = remove_poly_extension(base_name);
        main_module = "./" + name_without_ext;
        break;
    }
}

// Pre-compute per-table data (using index-based mutation)
let tidx = 0;
for tbl in sqlite_tables {
    let s = tbl.struct_def;

    // Find first field for getById
    let id_field = ();
    let id_type = "number";
    for item in s.items {
        if item.is_field() {
            let f = item.as_field();
            id_field = f.name;
            id_type = ts_type(f.field_type.type_name);
            break;
        }
    }
    sqlite_tables[tidx].id_field = id_field;
    sqlite_tables[tidx].id_type = id_type;
    sqlite_tables[tidx].has_id = id_field != ();
    sqlite_tables[tidx].camel_name = to_camel(tbl.name) + "s";

    // Pre-compute table class body
    sqlite_tables[tidx].class_body = generate_table_class(sqlite_tables[tidx]);

    tidx += 1;
}
%endlogic
%if has_tables
// Generated by PolyGen - SQLite Database Accessor
// This module provides typed access to SQLite tables.
// Requires: npm install better-sqlite3 @types/better-sqlite3
%blank
import Database from 'better-sqlite3';
import * as Types from '{{main_module}}';
%blank
/** Provides typed access to a SQLite table. */
export class DbTable<T> {
  protected cache: T[] = [];
  constructor(protected readonly tableName: string) {}
%blank
  /** Returns all loaded records. */
  get all(): readonly T[] { return this.cache; }
%blank
  /** Returns the number of loaded records. */
  get length(): number { return this.cache.length; }
%blank
  /** Returns true if no records are loaded. */
  get isEmpty(): boolean { return this.cache.length === 0; }
%blank
  /** Clears the cache. */
  clear(): void { this.cache = []; }
}
%blank
%for tbl in sqlite_tables
{{tbl.class_body}}
%blank
%endfor
/** SQLite database accessor for game data. */
export class SqliteDb {
  private db: Database.Database | null = null;
%blank
%for tbl in sqlite_tables
  readonly {{tbl.camel_name}} = new {{tbl.name}}Table();
%endfor
%blank
  /** Opens a connection to the SQLite database. */
  open(path: string): void {
    this.close();
    this.db = new Database(path, { readonly: true });
  }
%blank
  /** Closes the database connection. */
  close(): void {
    if (this.db) {
      this.db.close();
      this.db = null;
    }
  }
%blank
  /** Returns true if the database is open. */
  get isOpen(): boolean { return this.db !== null; }
%blank
  /** Loads all tables into memory. */
  loadAll(): void {
    if (!this.db) throw new Error('Database not open');
%for tbl in sqlite_tables
    this.{{tbl.camel_name}}.load(this.db);
%endfor
  }
}
%endif
