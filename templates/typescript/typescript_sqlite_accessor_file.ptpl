%logic
// TypeScript SQLite Accessor Generator
// Generates a typed SQLite accessor for @datasource("sqlite") tables
// Uses better-sqlite3 package

import "templates/typescript/rhai_utils/type_mapping" as ts_types;

fn join_with(arr, sep) {
    let result = "";
    let i = 0;
    for item in arr {
        if i > 0 { result += sep; }
        result += item;
        i += 1;
    }
    result
}

fn is_sqlite_table(struct_datasource, ns_datasource) {
    if struct_datasource != () && struct_datasource != "" {
        return struct_datasource == "sqlite";
    }
    if ns_datasource != () && ns_datasource != "" {
        return ns_datasource == "sqlite";
    }
    return false;
}

fn ts_type(type_name) {
    switch type_name {
        "string" => "string",
        "bool" => "boolean",
        "bytes" => "Buffer",
        "u8" | "u16" | "u32" | "u64" | "i8" | "i16" | "i32" | "i64" | "f32" | "f64" => "number",
        _ => type_name
    }
}

fn remove_poly_extension(filename) {
    let len = filename.len();
    let poly_len = 5;
    if len > poly_len {
        let suffix_start = len - poly_len;
        let suffix = filename.sub_string(suffix_start, poly_len);
        if suffix == ".poly" {
            return filename.sub_string(0, suffix_start);
        }
    }
    filename
}

fn to_camel(name) {
    let result = "";
    let capitalize_next = false;

    for i in 0..name.len() {
        let c = name.sub_string(i, 1);
        if c == "_" {
            capitalize_next = true;
        } else if capitalize_next {
            result += c.to_upper();
            capitalize_next = false;
        } else if i == 0 {
            result += c.to_lower();
        } else {
            result += c;
        }
    }
    result
}

// Collect all SQLite tables
let sqlite_tables = [];

for file in schema.files {
    if file.path == () || file.path == "" { continue; }

    for ns in file.namespaces {
        let ns_datasource = ns.datasource;

        for item in ns.items {
            if item.is_struct() {
                let s = item.as_struct();
                if is_sqlite_table(s.datasource, ns_datasource) {
                    let ns_parts = ns.name.split(".");

                    sqlite_tables.push(#{
                        name: s.name,
                        fqn: s.fqn,
                        ns_name: ns.name,
                        struct_def: s
                    });
                }
            }
        }
    }
}

// Only generate if there are SQLite tables
if sqlite_tables.len() == 0 {
    return "";
}

// Generate the accessor code
let code = "// Generated by PolyGen - SQLite Database Accessor\n";
code += "// This module provides typed access to SQLite tables.\n";
code += "// Requires: npm install better-sqlite3 @types/better-sqlite3\n\n";

code += "import Database from 'better-sqlite3';\n";

// Import types from main file
let main_module = "./schema";
for file in schema.files {
    let fp = file.path;
    if fp != () && fp != "" {
        let base_name = fp;
        if fp.contains("/") {
            let parts = fp.split("/");
            base_name = parts[parts.len() - 1];
        }
        let name_without_ext = remove_poly_extension(base_name);
        main_module = "./" + name_without_ext;
        break;
    }
}
code += "import * as Types from '" + main_module + "';\n\n";

// Generate DbTable class
code += "/** Provides typed access to a SQLite table. */\n";
code += "export class DbTable<T> {\n";
code += "  protected cache: T[] = [];\n";
code += "  constructor(protected readonly tableName: string) {}\n\n";

code += "  /** Returns all loaded records. */\n";
code += "  get all(): readonly T[] { return this.cache; }\n\n";

code += "  /** Returns the number of loaded records. */\n";
code += "  get length(): number { return this.cache.length; }\n\n";

code += "  /** Returns true if no records are loaded. */\n";
code += "  get isEmpty(): boolean { return this.cache.length === 0; }\n\n";

code += "  /** Clears the cache. */\n";
code += "  clear(): void { this.cache = []; }\n";
code += "}\n\n";

// Generate typed table classes
for tbl in sqlite_tables {
    let s = tbl.struct_def;
    let ns_parts = tbl.ns_name.split(".");
    let table_name = join_with(ns_parts, "_") + "_" + tbl.name;

    // Determine type path
    let ns_type_path = "";
    for part in ns_parts {
        let pascal_part = part.sub_string(0, 1).to_upper() + part.sub_string(1, part.len() - 1);
        ns_type_path += pascal_part;
    }
    let full_type = "Types." + ns_type_path + "." + tbl.name;

    code += "/** Table accessor for " + tbl.name + ". */\n";
    code += "export class " + tbl.name + "Table extends DbTable<" + full_type + "> {\n";
    code += "  constructor() { super('" + table_name + "'); }\n\n";

    code += "  /** Loads all records from the database. */\n";
    code += "  load(db: Database.Database): void {\n";
    code += "    this.cache = [];\n";
    code += "    const stmt = db.prepare(`SELECT * FROM ${this.tableName}`);\n";
    code += "    for (const row of stmt.iterate()) {\n";
    code += "      this.cache.push(this.mapRow(row as Record<string, unknown>));\n";
    code += "    }\n";
    code += "  }\n\n";

    // Find ID field for getById
    let id_field = ();
    let id_type = "number";
    for item in s.items {
        if item.is_field() {
            let f = item.as_field();
            id_field = f.name;
            id_type = ts_type(f.field_type.type_name);
            break;
        }
    }

    if id_field != () {
        code += "  /** Gets a record by its ID. */\n";
        code += "  getById(db: Database.Database, id: " + id_type + "): " + full_type + " | undefined {\n";
        code += "    const stmt = db.prepare(`SELECT * FROM ${this.tableName} WHERE " + id_field + " = ?`);\n";
        code += "    const row = stmt.get(id) as Record<string, unknown> | undefined;\n";
        code += "    return row ? this.mapRow(row) : undefined;\n";
        code += "  }\n\n";
    }

    code += "  private mapRow(row: Record<string, unknown>): " + full_type + " {\n";
    code += "    return {\n";

    let field_idx = 0;
    for item in s.items {
        if item.is_field() {
            let f = item.as_field();
            let type_name = f.field_type.type_name;
            let ts_t = ts_type(type_name);
            let camel_name = to_camel(f.name);

            let accessor = "row['" + f.name + "']";
            if ts_t == "boolean" {
                accessor = "Boolean(" + accessor + ")";
            } else {
                accessor = accessor + " as " + ts_t;
            }

            if field_idx > 0 { code += ",\n"; }
            code += "      " + camel_name + ": " + accessor;
            field_idx += 1;
        }
    }

    code += "\n    };\n";
    code += "  }\n";
    code += "}\n\n";
}

// Generate main SqliteDb class
code += "/** SQLite database accessor for game data. */\n";
code += "export class SqliteDb {\n";
code += "  private db: Database.Database | null = null;\n\n";

// Table instances
for tbl in sqlite_tables {
    let field_name = to_camel(tbl.name) + "s";
    code += "  readonly " + field_name + " = new " + tbl.name + "Table();\n";
}
code += "\n";

code += "  /** Opens a connection to the SQLite database. */\n";
code += "  open(path: string): void {\n";
code += "    this.close();\n";
code += "    this.db = new Database(path, { readonly: true });\n";
code += "  }\n\n";

code += "  /** Closes the database connection. */\n";
code += "  close(): void {\n";
code += "    if (this.db) {\n";
code += "      this.db.close();\n";
code += "      this.db = null;\n";
code += "    }\n";
code += "  }\n\n";

code += "  /** Returns true if the database is open. */\n";
code += "  get isOpen(): boolean { return this.db !== null; }\n\n";

code += "  /** Loads all tables into memory. */\n";
code += "  loadAll(): void {\n";
code += "    if (!this.db) throw new Error('Database not open');\n";
for tbl in sqlite_tables {
    let field_name = to_camel(tbl.name) + "s";
    code += "    this." + field_name + ".load(this.db);\n";
}
code += "  }\n";

code += "}\n";

// Determine output filename
let out_filename = "schema_sqlite_accessor.ts";
for file in schema.files {
    let fp = file.path;
    if fp != () && fp != "" {
        let base_name = fp;
        if fp.contains("/") {
            let parts = fp.split("/");
            base_name = parts[parts.len() - 1];
        }
        let name_without_ext = remove_poly_extension(base_name);
        out_filename = name_without_ext + "_sqlite_accessor.ts";
        break;
    }
}

let out_path = output_dir + "/typescript/" + out_filename;
print("Generating file: " + out_path);
write_file(out_path, code);
%endlogic
