%logic
// Unreal Loaders File Template for PolyGen
// Generates DataTable row structures and CSV/JSON loading utilities

import "templates/unreal/rhai_utils/type_mapping" as ue_types;

// Check if type name looks like an enum
fn is_likely_enum(type_name) {
    if type_name == "Element" || type_name == "Status" || type_name == "ItemType" ||
       type_name == "PlayerClass" || type_name == "Status__Enum" {
        return true;
    }
    if type_name.contains("Type") || type_name.contains("Status") ||
       type_name.contains("Kind") || type_name.contains("Mode") ||
       type_name.contains("State") {
        return true;
    }
    return false;
}

// Generate CSV parsing helper for a field type
fn csv_parse_expr(type_ref, column_expr) {
    let n = type_ref.type_name;
    if n == "string" { return column_expr; }
    if n == "bool" { return column_expr + ".ToBool()"; }
    if n == "u8" || n == "u16" || n == "u32" || n == "i8" || n == "i16" || n == "i32" {
        return "FCString::Atoi(*" + column_expr + ")";
    }
    if n == "u64" || n == "i64" {
        return "FCString::Atoi64(*" + column_expr + ")";
    }
    if n == "f32" || n == "f64" {
        return "FCString::Atof(*" + column_expr + ")";
    }

    // For enums, parse as int and cast (check is_enum flag OR common patterns)
    if type_ref.is_enum || is_likely_enum(n) {
        let enum_name = "E" + n;
        return "static_cast<" + enum_name + ">(FCString::Atoi(*" + column_expr + "))";
    }

    return column_expr;
}

// Generate JSON parsing for a struct
fn generate_json_loader(s, namespace_fqn) {
    let struct_name = ue_types::get_struct_name(s.name);
    let result = "";

    result += "// JSON loader for " + struct_name + "\n";
    result += "inline bool LoadFromJson(const FString& JsonString, " + struct_name + "& OutStruct)\n";
    result += "{\n";
    result += "    TSharedPtr<FJsonObject> JsonObject;\n";
    result += "    TSharedRef<TJsonReader<>> Reader = TJsonReaderFactory<>::Create(JsonString);\n";
    result += "    \n";
    result += "    if (!FJsonSerializer::Deserialize(Reader, JsonObject) || !JsonObject.IsValid())\n";
    result += "    {\n";
    result += "        return false;\n";
    result += "    }\n";
    result += "    \n";
    result += "    return FJsonObjectConverter::JsonObjectToUStruct(JsonObject.ToSharedRef(), &OutStruct);\n";
    result += "}\n\n";

    result += "// JSON array loader for " + struct_name + "\n";
    result += "inline bool LoadArrayFromJson(const FString& JsonString, TArray<" + struct_name + ">& OutArray)\n";
    result += "{\n";
    result += "    return FJsonObjectConverter::JsonArrayStringToUStruct(JsonString, &OutArray);\n";
    result += "}\n\n";

    return result;
}

// Generate CSV writer for a struct
fn generate_csv_writer(s, namespace_fqn) {
    let struct_name = ue_types::get_struct_name(s.name);
    let result = "";

    result += "// CSV writer for " + struct_name + "\n";
    result += "inline bool SaveToCsv(const FString& CsvPath, const TArray<" + struct_name + ">& InArray)\n";
    result += "{\n";
    result += "    if (InArray.Num() == 0)\n";
    result += "    {\n";
    result += "        return true; // Nothing to write\n";
    result += "    }\n";
    result += "    \n";
    result += "    FString CsvContent;\n";
    result += "    \n";

    // Build header row
    result += "    // Header row\n";
    result += "    CsvContent += TEXT(\"";

    let field_names = [];
    let field_defs = #{};
    for item in s.items {
        if item.is_field() {
            let f = item.as_field();
            if !f.field_type.is_list {
                field_names.push(f.name);
                field_defs[f.name] = f;
            }
        }
    }

    for i in 0..field_names.len() {
        if i > 0 {
            result += ",";
        }
        result += field_names[i];
    }
    result += "\");\n    CsvContent += LINE_TERMINATOR;\n";
    result += "    \n";

    // Write data rows
    result += "    // Data rows\n";
    result += "    for (const " + struct_name + "& Row : InArray)\n";
    result += "    {\n";

    for i in 0..field_names.len() {
        let field_name = field_names[i];
        if i > 0 {
            result += "        CsvContent += TEXT(\",\");\n";
        }

        let f = field_defs[field_name];
        let n = f.field_type.type_name;
        if n == "string" {
            result += "        {\n";
            result += "            FString EscapedValue = Row." + field_name + ".Replace(TEXT(\"\\\"\"), TEXT(\"\\\"\\\"\"));\n";
            result += "            if (EscapedValue.Contains(TEXT(\",\")) || EscapedValue.Contains(TEXT(\"\\\"\")))\n";
            result += "            {\n";
            result += "                CsvContent += TEXT(\"\\\"\") + EscapedValue + TEXT(\"\\\"\");\n";
            result += "            }\n";
            result += "            else\n";
            result += "            {\n";
            result += "                CsvContent += EscapedValue;\n";
            result += "            }\n";
            result += "        }\n";
        } else if n == "bool" {
            result += "        CsvContent += Row." + field_name + " ? TEXT(\"true\") : TEXT(\"false\");\n";
        } else if n == "f32" || n == "f64" {
            result += "        CsvContent += FString::SanitizeFloat(Row." + field_name + ");\n";
        } else if f.field_type.is_enum || is_likely_enum(n) {
            result += "        CsvContent += FString::FromInt(static_cast<int32>(Row." + field_name + "));\n";
        } else if f.field_type.is_struct && !ue_types::is_primitive_name(n) && !f.field_type.is_enum {
            result += "        CsvContent += Row." + field_name + ".Pack();\n";
        } else {
            result += "        CsvContent += FString::FromInt(Row." + field_name + ");\n";
        }
    }

    result += "        CsvContent += LINE_TERMINATOR;\n";
    result += "    }\n";
    result += "    \n";
    result += "    return FFileHelper::SaveStringToFile(CsvContent, *CsvPath);\n";
    result += "}\n\n";

    return result;
}

// Generate CSV loader for a struct
fn generate_csv_loader(s, namespace_fqn) {
    let struct_name = ue_types::get_struct_name(s.name);
    let result = "";

    result += "// CSV loader for " + struct_name + "\n";
    result += "inline bool LoadFromCsv(const FString& CsvPath, TArray<" + struct_name + ">& OutArray)\n";
    result += "{\n";
    result += "    FString FileContent;\n";
    result += "    if (!FFileHelper::LoadFileToString(FileContent, *CsvPath))\n";
    result += "    {\n";
    result += "        UE_LOG(LogTemp, Error, TEXT(\"Failed to load CSV file: %s\"), *CsvPath);\n";
    result += "        return false;\n";
    result += "    }\n";
    result += "    \n";
    result += "    TArray<FString> Lines;\n";
    result += "    FileContent.ParseIntoArrayLines(Lines);\n";
    result += "    \n";
    result += "    if (Lines.Num() < 2) // Need at least header + 1 row\n";
    result += "    {\n";
    result += "        return true; // Empty but valid\n";
    result += "    }\n";
    result += "    \n";
    result += "    // Parse header to get column indices\n";
    result += "    TArray<FString> Headers;\n";
    result += "    Lines[0].ParseIntoArray(Headers, TEXT(\",\"));\n";
    result += "    \n";

    result += "    TMap<FString, int32> ColumnMap;\n";
    result += "    for (int32 i = 0; i < Headers.Num(); ++i)\n";
    result += "    {\n";
    result += "        ColumnMap.Add(Headers[i].TrimStartAndEnd(), i);\n";
    result += "    }\n";
    result += "    \n";

    result += "    // Parse data rows\n";
    result += "    for (int32 RowIdx = 1; RowIdx < Lines.Num(); ++RowIdx)\n";
    result += "    {\n";
    result += "        if (Lines[RowIdx].IsEmpty()) continue;\n";
    result += "        \n";
    result += "        TArray<FString> Columns;\n";
    result += "        Lines[RowIdx].ParseIntoArray(Columns, TEXT(\",\"));\n";
    result += "        \n";
    result += "        " + struct_name + " Row;\n";

    for item in s.items {
        if item.is_field() {
            let f = item.as_field();
            let field_name = f.name;

            if !f.field_type.is_list {
                result += "        if (const int32* ColIdx = ColumnMap.Find(TEXT(\"" + field_name + "\")))\n";
                result += "        {\n";
                if f.field_type.is_option {
                    result += "            if (*ColIdx < Columns.Num() && !Columns[*ColIdx].IsEmpty())\n";
                } else {
                    result += "            if (*ColIdx < Columns.Num())\n";
                }
                result += "            {\n";
                if f.field_type.is_struct && !ue_types::is_primitive_name(f.field_type.type_name) && !f.field_type.is_enum {
                    let ue_struct_name = ue_types::get_struct_name(f.field_type.type_name);
                    result += "                Row." + field_name + " = " + ue_struct_name + "::Unpack(Columns[*ColIdx]);\n";
                } else {
                    result += "                Row." + field_name + " = " + csv_parse_expr(f.field_type, "Columns[*ColIdx]") + ";\n";
                }
                result += "            }\n";
                result += "        }\n";
            }
        }
    }

    result += "        OutArray.Add(Row);\n";
    result += "    }\n";
    result += "    \n";
    result += "    return true;\n";
    result += "}\n\n";

    return result;
}

// ============================================================
// Data preparation
// ============================================================

let has_file = file.path != () && file.path != "";

let pascal_name = "";
let json_loaders_body = "";
let csv_loaders_body = "";
let csv_writers_body = "";

if has_file {
    let parts = file.path.split("/");
    let filename = parts[parts.len - 1];
    let base_name = filename + "";
    base_name.replace(".poly", "");

    let first_char = base_name.sub_string(0, 1);
    let rest = base_name.sub_string(1, base_name.len() - 1);
    pascal_name = first_char.to_upper() + rest;

    // Collect all structs from all namespaces in this file
    let all_structs = [];
    for ns in file.namespaces {
        for item in ns.items {
            if item.is_struct() {
                let s = item.as_struct();
                all_structs.push(#{ struct_def: s, namespace_name: ns.name });

                for si in s.items {
                    if si.is_embedded_struct() {
                        let es = si.as_embedded_struct();
                        all_structs.push(#{ struct_def: es, namespace_name: ns.name });
                    }
                }
            } else if item.is_namespace() {
                let child_ns = item.as_namespace();
                for child_item in child_ns.items {
                    if child_item.is_struct() {
                        let cs = child_item.as_struct();
                        all_structs.push(#{ struct_def: cs, namespace_name: child_ns.name });
                    }
                }
            }
        }
    }

    for entry in all_structs {
        let s = entry.struct_def;
        let ns = entry.namespace_name;
        json_loaders_body += generate_json_loader(s, ns);
        csv_loaders_body += generate_csv_loader(s, ns);
        csv_writers_body += generate_csv_writer(s, ns);
    }
}

let has_content = json_loaders_body != "" || csv_loaders_body != "" || csv_writers_body != "";
%endlogic
%if has_file && has_content
// Generated by PolyGen - DO NOT EDIT
// Loaders for {{file.path}}
#pragma once
%blank
#include "Polygen{{pascal_name}}.h"
#include "Misc/FileHelper.h"
#include "JsonObjectConverter.h"
#include "Serialization/JsonReader.h"
#include "Serialization/JsonSerializer.h"
%blank
#ifndef LINE_TERMINATOR
#define LINE_TERMINATOR TEXT("\n")
#endif
%blank
namespace PolygenLoaders
{
%blank
// ============================================================================
// JSON Loaders
// ============================================================================
%blank
{{json_loaders_body}}// ============================================================================
// CSV Loaders
// ============================================================================
%blank
{{csv_loaders_body}}// ============================================================================
// CSV Writers
// ============================================================================
%blank
{{csv_writers_body}}} // namespace PolygenLoaders
%endif
