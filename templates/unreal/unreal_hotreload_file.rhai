// Unreal Hot Reload Utility Template for PolyGen
// Generates file watcher and auto-reload functionality

import "templates/unreal/rhai_utils/type_mapping" as ue_types;

// Main entry point - generates a single hot reload utility file
let output_filename = "PolygenHotReload.h";
let final_path = output_dir + "/unreal/" + output_filename;

// Collect all table structs that have @load annotation
let loadable_structs = [];
for file in schema.files {
    if file.path == () || file.path == "" {
        continue;
    }

    // Extract filename for include
    let parts = file.path.split("/");
    let filename = parts[parts.len - 1];
    let base_name = filename + "";
    base_name.replace(".poly", "");

    let first_char = base_name.sub_string(0, 1);
    let rest = base_name.sub_string(1, base_name.len() - 1);
    let pascal_name = first_char.to_upper() + rest;

    for ns in file.namespaces {
        for item in ns.items {
            if item.is_struct() {
                let s = item.as_struct();
                // Check if struct has load annotation in header
                let has_load = false;
                let csv_path = "";
                let json_path = "";

                for header_item in s.header {
                    if header_item.is_annotation() {
                        let ann = header_item.as_annotation();
                        if ann.name == "load" {
                            has_load = true;
                            for param in ann.params {
                                if param.key == "csv" {
                                    csv_path = param.value;
                                } else if param.key == "json" {
                                    json_path = param.value;
                                } else if param.key == "path" && csv_path == "" && json_path == "" {
                                    // Generic path - assume CSV if extension present or .csv by default
                                    let path_val = param.value;
                                    if path_val.ends_with(".json") {
                                        json_path = path_val;
                                    } else if path_val.ends_with(".csv") {
                                        csv_path = path_val;
                                    } else {
                                        // Assume CSV format and add .csv extension
                                        csv_path = path_val + ".csv";
                                    }
                                }
                            }
                        }
                    }
                }

                if has_load {
                    loadable_structs.push(#{
                        struct_def: s,
                        namespace_name: ns.name,
                        include_file: "Polygen" + pascal_name + "Loaders.h",
                        csv_path: csv_path,
                        json_path: json_path
                    });
                }
            }
        }
    }
}

let result = "";

// File header
result += "// Generated by PolyGen - DO NOT EDIT\n";
result += "// Hot Reload Utilities\n";
result += "#pragma once\n\n";

// Includes
result += "#include \"CoreMinimal.h\"\n";
result += "#include \"HAL/FileManager.h\"\n";
result += "#include \"HAL/PlatformFileManager.h\"\n";
result += "#include \"Misc/FileHelper.h\"\n";
result += "#include \"Misc/Paths.h\"\n";
result += "#include \"Async/Async.h\"\n";

// Include all loader headers
let included_headers = [];
for entry in loadable_structs {
    let header = entry.include_file;
    let already_included = false;
    for h in included_headers {
        if h == header {
            already_included = true;
            break;
        }
    }
    if !already_included {
        result += "#include \"" + header + "\"\n";
        included_headers.push(header);
    }
}

result += "\n";

// Delegate declarations
result += "// ============================================================================\n";
result += "// Delegate Declarations\n";
result += "// ============================================================================\n\n";

for entry in loadable_structs {
    let s = entry.struct_def;
    let struct_name = ue_types::get_struct_name(s.name);
    result += "DECLARE_MULTICAST_DELEGATE_OneParam(FOn" + s.name + "DataReloaded, const TArray<" + struct_name + ">&);\n";
}

result += "\n";

// Hot reload manager class
result += "// ============================================================================\n";
result += "// Hot Reload Manager\n";
result += "// ============================================================================\n\n";

result += "/**\n";
result += " * Manages hot reload of data files.\n";
result += " * Watches for file changes and automatically reloads data.\n";
result += " * Use in editor or development builds only.\n";
result += " */\n";
result += "class FPolygenHotReloadManager\n";
result += "{\n";
result += "public:\n";
result += "    static FPolygenHotReloadManager& Get()\n";
result += "    {\n";
result += "        static FPolygenHotReloadManager Instance;\n";
result += "        return Instance;\n";
result += "    }\n\n";

// Data storage and delegates for each struct
result += "    // Data storage and reload delegates\n";
for entry in loadable_structs {
    let s = entry.struct_def;
    let struct_name = ue_types::get_struct_name(s.name);
    result += "    TArray<" + struct_name + "> " + s.name + "Data;\n";
    result += "    FOn" + s.name + "DataReloaded On" + s.name + "Reloaded;\n\n";
}

// Initialize function
result += "    /**\n";
result += "     * Initialize hot reload system with base content path.\n";
result += "     * @param ContentPath - Base path for data files (e.g., FPaths::ProjectContentDir())\n";
result += "     */\n";
result += "    void Initialize(const FString& ContentPath)\n";
result += "    {\n";
result += "        BasePath = ContentPath;\n";
result += "        \n";
result += "        // Initial load of all data\n";
result += "        LoadAllData();\n";
result += "        \n";
result += "#if WITH_EDITOR\n";
result += "        // Start file watching in editor\n";
result += "        StartFileWatching();\n";
result += "#endif\n";
result += "    }\n\n";

// Shutdown function
result += "    void Shutdown()\n";
result += "    {\n";
result += "#if WITH_EDITOR\n";
result += "        StopFileWatching();\n";
result += "#endif\n";
result += "    }\n\n";

// LoadAllData function
result += "    void LoadAllData()\n";
result += "    {\n";
for entry in loadable_structs {
    let s = entry.struct_def;
    // Call load for any struct with a file path
    if entry.csv_path != "" || entry.json_path != "" {
        result += "        Load" + s.name + "Data();\n";
    }
}
result += "    }\n\n";

// Individual load functions
for entry in loadable_structs {
    let s = entry.struct_def;
    let struct_name = ue_types::get_struct_name(s.name);

    // Determine file path (prefer csv, fallback to json, then generic path)
    let file_path = entry.csv_path;
    let use_csv = true;
    if file_path == "" {
        file_path = entry.json_path;
        use_csv = false;
    }

    result += "    bool Load" + s.name + "Data()\n";
    result += "    {\n";

    if file_path != "" {
        if use_csv {
            result += "        FString FilePath = BasePath / TEXT(\"" + file_path + "\");\n";
            result += "        TArray<" + struct_name + "> NewData;\n";
            result += "        \n";
            result += "        if (PolygenLoaders::LoadFromCsv(FilePath, NewData))\n";
            result += "        {\n";
            result += "            " + s.name + "Data = MoveTemp(NewData);\n";
            result += "            \n";
            result += "            // Update last modified time\n";
            result += "            IFileManager& FileManager = IFileManager::Get();\n";
            result += "            " + s.name + "LastModified = FileManager.GetTimeStamp(*FilePath);\n";
            result += "            \n";
            result += "            // Broadcast reload event\n";
            result += "            On" + s.name + "Reloaded.Broadcast(" + s.name + "Data);\n";
            result += "            \n";
            result += "            UE_LOG(LogTemp, Log, TEXT(\"Loaded %d " + s.name + " entries from %s\"), " + s.name + "Data.Num(), *FilePath);\n";
            result += "            return true;\n";
            result += "        }\n";
            result += "        \n";
            result += "        UE_LOG(LogTemp, Warning, TEXT(\"Failed to load " + s.name + " data from %s\"), *FilePath);\n";
            result += "        return false;\n";
        } else {
            result += "        FString FilePath = BasePath / TEXT(\"" + file_path + "\");\n";
            result += "        FString JsonContent;\n";
            result += "        \n";
            result += "        if (FFileHelper::LoadFileToString(JsonContent, *FilePath))\n";
            result += "        {\n";
            result += "            TArray<" + struct_name + "> NewData;\n";
            result += "            if (PolygenLoaders::LoadArrayFromJson(JsonContent, NewData))\n";
            result += "            {\n";
            result += "                " + s.name + "Data = MoveTemp(NewData);\n";
            result += "                \n";
            result += "                // Update last modified time\n";
            result += "                IFileManager& FileManager = IFileManager::Get();\n";
            result += "                " + s.name + "LastModified = FileManager.GetTimeStamp(*FilePath);\n";
            result += "                \n";
            result += "                On" + s.name + "Reloaded.Broadcast(" + s.name + "Data);\n";
            result += "                return true;\n";
            result += "            }\n";
            result += "        }\n";
            result += "        UE_LOG(LogTemp, Warning, TEXT(\"Failed to load " + s.name + " data from %s\"), *FilePath);\n";
            result += "        return false;\n";
        }
    } else {
        result += "        // No load path specified in @load annotation\n";
        result += "        UE_LOG(LogTemp, Warning, TEXT(\"No file path specified for " + s.name + " in schema\"));\n";
        result += "        return false;\n";
    }

    result += "    }\n\n";
}

// Save functions
result += "    // Save functions\n";
for entry in loadable_structs {
    let s = entry.struct_def;
    let struct_name = ue_types::get_struct_name(s.name);

    if entry.csv_path != "" {
        result += "    bool Save" + s.name + "Data()\n";
        result += "    {\n";
        result += "        FString FilePath = BasePath / TEXT(\"" + entry.csv_path + "\");\n";
        result += "        return PolygenLoaders::SaveToCsv(FilePath, " + s.name + "Data);\n";
        result += "    }\n\n";
    }
}

// Private section
result += "private:\n";
result += "    FPolygenHotReloadManager() = default;\n";
result += "    ~FPolygenHotReloadManager() = default;\n\n";

result += "    FString BasePath;\n\n";

// Last modified timestamps
for entry in loadable_structs {
    let s = entry.struct_def;
    result += "    FDateTime " + s.name + "LastModified;\n";
}

result += "\n";

// File watching implementation
result += "#if WITH_EDITOR\n";
result += "    FDelegateHandle TickDelegateHandle;\n";
result += "    float TimeSinceLastCheck = 0.0f;\n";
result += "    static constexpr float CheckInterval = 1.0f; // Check every second\n\n";

result += "    void StartFileWatching()\n";
result += "    {\n";
result += "        TickDelegateHandle = FTSTicker::GetCoreTicker().AddTicker(\n";
result += "            FTickerDelegate::CreateRaw(this, &FPolygenHotReloadManager::CheckForFileChanges),\n";
result += "            CheckInterval\n";
result += "        );\n";
result += "        UE_LOG(LogTemp, Log, TEXT(\"PolyGen Hot Reload: File watching started\"));\n";
result += "    }\n\n";

result += "    void StopFileWatching()\n";
result += "    {\n";
result += "        if (TickDelegateHandle.IsValid())\n";
result += "        {\n";
result += "            FTSTicker::GetCoreTicker().RemoveTicker(TickDelegateHandle);\n";
result += "            TickDelegateHandle.Reset();\n";
result += "        }\n";
result += "    }\n\n";

result += "    bool CheckForFileChanges(float DeltaTime)\n";
result += "    {\n";
result += "        IFileManager& FileManager = IFileManager::Get();\n\n";

for entry in loadable_structs {
    let s = entry.struct_def;
    // Get file path (prefer csv, fallback to json)
    let file_path = entry.csv_path;
    if file_path == "" {
        file_path = entry.json_path;
    }
    if file_path != "" {
        result += "        // Check " + s.name + "\n";
        result += "        {\n";
        result += "            FString FilePath = BasePath / TEXT(\"" + file_path + "\");\n";
        result += "            FDateTime CurrentModified = FileManager.GetTimeStamp(*FilePath);\n";
        result += "            if (CurrentModified > " + s.name + "LastModified)\n";
        result += "            {\n";
        result += "                UE_LOG(LogTemp, Log, TEXT(\"PolyGen Hot Reload: Detected change in %s\"), *FilePath);\n";
        result += "                Load" + s.name + "Data();\n";
        result += "            }\n";
        result += "        }\n\n";
    }
}

result += "        return true; // Continue ticking\n";
result += "    }\n";
result += "#endif // WITH_EDITOR\n";

result += "};\n\n";

// Convenience macros
result += "// ============================================================================\n";
result += "// Convenience Macros\n";
result += "// ============================================================================\n\n";

result += "// Initialize hot reload in your game module or subsystem\n";
result += "#define POLYGEN_HOTRELOAD_INIT(ContentPath) \\\n";
result += "    FPolygenHotReloadManager::Get().Initialize(ContentPath)\n\n";

result += "// Shutdown hot reload\n";
result += "#define POLYGEN_HOTRELOAD_SHUTDOWN() \\\n";
result += "    FPolygenHotReloadManager::Get().Shutdown()\n\n";

result += "// Get data reference\n";
for entry in loadable_structs {
    let s = entry.struct_def;
    result += "#define POLYGEN_GET_" + s.name.to_upper() + "_DATA() \\\n";
    result += "    FPolygenHotReloadManager::Get()." + s.name + "Data\n\n";
}

print("Generating hot reload file: " + final_path);
write_file(final_path, result);

""
