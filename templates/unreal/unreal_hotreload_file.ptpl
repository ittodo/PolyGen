%logic
// Unreal Hot Reload Utility Template for PolyGen
// Generates file watcher and auto-reload functionality

import "templates/unreal/rhai_utils/type_mapping" as ue_types;

// Main entry point - generates a single hot reload utility file

// Collect all table structs that have @load annotation
let loadable_structs = [];
for file in schema.files {
    if file.path == () || file.path == "" {
        continue;
    }

    // Extract filename for include
    let parts = file.path.split("/");
    let filename = parts[parts.len - 1];
    let base_name = filename + "";
    base_name.replace(".poly", "");

    let first_char = base_name.sub_string(0, 1);
    let rest = base_name.sub_string(1, base_name.len() - 1);
    let pascal_name = first_char.to_upper() + rest;

    for ns in file.namespaces {
        for item in ns.items {
            if item.is_struct() {
                let s = item.as_struct();
                let has_load = false;
                let csv_path = "";
                let json_path = "";

                for header_item in s.header {
                    if header_item.is_annotation() {
                        let ann = header_item.as_annotation();
                        if ann.name == "load" {
                            has_load = true;
                            for param in ann.params {
                                if param.key == "csv" {
                                    csv_path = param.value;
                                } else if param.key == "json" {
                                    json_path = param.value;
                                } else if param.key == "path" && csv_path == "" && json_path == "" {
                                    let path_val = param.value;
                                    if path_val.ends_with(".json") {
                                        json_path = path_val;
                                    } else if path_val.ends_with(".csv") {
                                        csv_path = path_val;
                                    } else {
                                        csv_path = path_val + ".csv";
                                    }
                                }
                            }
                        }
                    }
                }

                if has_load {
                    loadable_structs.push(#{
                        struct_def: s,
                        namespace_name: ns.name,
                        include_file: "Polygen" + pascal_name + "Loaders.h",
                        csv_path: csv_path,
                        json_path: json_path
                    });
                }
            }
        }
    }
}

// Pre-compute include headers (deduplicated)
let include_headers = [];
let included_set = [];
for entry in loadable_structs {
    let header = entry.include_file;
    let already = false;
    for h in included_set {
        if h == header { already = true; break; }
    }
    if !already {
        include_headers.push(header);
        included_set.push(header);
    }
}

// Pre-compute delegate declarations
let delegate_decls = "";
for entry in loadable_structs {
    let s = entry.struct_def;
    let struct_name = ue_types::get_struct_name(s.name);
    delegate_decls += "DECLARE_MULTICAST_DELEGATE_OneParam(FOn" + s.name + "DataReloaded, const TArray<" + struct_name + ">&);\n";
}

// Pre-compute data storage and delegates
let data_storage = "";
for entry in loadable_structs {
    let s = entry.struct_def;
    let struct_name = ue_types::get_struct_name(s.name);
    data_storage += "    TArray<" + struct_name + "> " + s.name + "Data;\n";
    data_storage += "    FOn" + s.name + "DataReloaded On" + s.name + "Reloaded;\n\n";
}

// Pre-compute LoadAllData body
let load_all_body = "";
for entry in loadable_structs {
    let s = entry.struct_def;
    if entry.csv_path != "" || entry.json_path != "" {
        load_all_body += "        Load" + s.name + "Data();\n";
    }
}

// Pre-compute individual load functions
let load_functions = "";
for entry in loadable_structs {
    let s = entry.struct_def;
    let struct_name = ue_types::get_struct_name(s.name);

    let file_path = entry.csv_path;
    let use_csv = true;
    if file_path == "" {
        file_path = entry.json_path;
        use_csv = false;
    }

    load_functions += "    bool Load" + s.name + "Data()\n";
    load_functions += "    {\n";

    if file_path != "" {
        if use_csv {
            load_functions += "        FString FilePath = BasePath / TEXT(\"" + file_path + "\");\n";
            load_functions += "        TArray<" + struct_name + "> NewData;\n";
            load_functions += "        \n";
            load_functions += "        if (PolygenLoaders::LoadFromCsv(FilePath, NewData))\n";
            load_functions += "        {\n";
            load_functions += "            " + s.name + "Data = MoveTemp(NewData);\n";
            load_functions += "            \n";
            load_functions += "            // Update last modified time\n";
            load_functions += "            IFileManager& FileManager = IFileManager::Get();\n";
            load_functions += "            " + s.name + "LastModified = FileManager.GetTimeStamp(*FilePath);\n";
            load_functions += "            \n";
            load_functions += "            // Broadcast reload event\n";
            load_functions += "            On" + s.name + "Reloaded.Broadcast(" + s.name + "Data);\n";
            load_functions += "            \n";
            load_functions += "            UE_LOG(LogTemp, Log, TEXT(\"Loaded %d " + s.name + " entries from %s\"), " + s.name + "Data.Num(), *FilePath);\n";
            load_functions += "            return true;\n";
            load_functions += "        }\n";
            load_functions += "        \n";
            load_functions += "        UE_LOG(LogTemp, Warning, TEXT(\"Failed to load " + s.name + " data from %s\"), *FilePath);\n";
            load_functions += "        return false;\n";
        } else {
            load_functions += "        FString FilePath = BasePath / TEXT(\"" + file_path + "\");\n";
            load_functions += "        FString JsonContent;\n";
            load_functions += "        \n";
            load_functions += "        if (FFileHelper::LoadFileToString(JsonContent, *FilePath))\n";
            load_functions += "        {\n";
            load_functions += "            TArray<" + struct_name + "> NewData;\n";
            load_functions += "            if (PolygenLoaders::LoadArrayFromJson(JsonContent, NewData))\n";
            load_functions += "            {\n";
            load_functions += "                " + s.name + "Data = MoveTemp(NewData);\n";
            load_functions += "                \n";
            load_functions += "                // Update last modified time\n";
            load_functions += "                IFileManager& FileManager = IFileManager::Get();\n";
            load_functions += "                " + s.name + "LastModified = FileManager.GetTimeStamp(*FilePath);\n";
            load_functions += "                \n";
            load_functions += "                On" + s.name + "Reloaded.Broadcast(" + s.name + "Data);\n";
            load_functions += "                return true;\n";
            load_functions += "            }\n";
            load_functions += "        }\n";
            load_functions += "        UE_LOG(LogTemp, Warning, TEXT(\"Failed to load " + s.name + " data from %s\"), *FilePath);\n";
            load_functions += "        return false;\n";
        }
    } else {
        load_functions += "        // No load path specified in @load annotation\n";
        load_functions += "        UE_LOG(LogTemp, Warning, TEXT(\"No file path specified for " + s.name + " in schema\"));\n";
        load_functions += "        return false;\n";
    }

    load_functions += "    }\n\n";
}

// Pre-compute save functions
let save_functions = "    // Save functions\n";
for entry in loadable_structs {
    let s = entry.struct_def;
    let struct_name = ue_types::get_struct_name(s.name);

    if entry.csv_path != "" {
        save_functions += "    bool Save" + s.name + "Data()\n";
        save_functions += "    {\n";
        save_functions += "        FString FilePath = BasePath / TEXT(\"" + entry.csv_path + "\");\n";
        save_functions += "        return PolygenLoaders::SaveToCsv(FilePath, " + s.name + "Data);\n";
        save_functions += "    }\n\n";
    }
}

// Pre-compute last modified timestamps
let last_modified_fields = "";
for entry in loadable_structs {
    let s = entry.struct_def;
    last_modified_fields += "    FDateTime " + s.name + "LastModified;\n";
}

// Pre-compute file change check body
let file_check_body = "";
for entry in loadable_structs {
    let s = entry.struct_def;
    let file_path = entry.csv_path;
    if file_path == "" {
        file_path = entry.json_path;
    }
    if file_path != "" {
        file_check_body += "        // Check " + s.name + "\n";
        file_check_body += "        {\n";
        file_check_body += "            FString FilePath = BasePath / TEXT(\"" + file_path + "\");\n";
        file_check_body += "            FDateTime CurrentModified = FileManager.GetTimeStamp(*FilePath);\n";
        file_check_body += "            if (CurrentModified > " + s.name + "LastModified)\n";
        file_check_body += "            {\n";
        file_check_body += "                UE_LOG(LogTemp, Log, TEXT(\"PolyGen Hot Reload: Detected change in %s\"), *FilePath);\n";
        file_check_body += "                Load" + s.name + "Data();\n";
        file_check_body += "            }\n";
        file_check_body += "        }\n\n";
    }
}

// Pre-compute convenience macros
let convenience_macros = "";
for entry in loadable_structs {
    let s = entry.struct_def;
    convenience_macros += "#define POLYGEN_GET_" + s.name.to_upper() + "_DATA() \\\n";
    convenience_macros += "    FPolygenHotReloadManager::Get()." + s.name + "Data\n\n";
}

let has_loadable = loadable_structs.len() > 0;
%endlogic
// Generated by PolyGen - DO NOT EDIT
// Hot Reload Utilities
#pragma once
%blank
#include "CoreMinimal.h"
#include "HAL/FileManager.h"
#include "HAL/PlatformFileManager.h"
#include "Misc/FileHelper.h"
#include "Misc/Paths.h"
#include "Async/Async.h"
%for hdr in include_headers
#include "{{hdr}}"
%endfor
%blank
// ============================================================================
// Delegate Declarations
// ============================================================================
%blank
{{delegate_decls}}
// ============================================================================
// Hot Reload Manager
// ============================================================================
%blank
/**
 * Manages hot reload of data files.
 * Watches for file changes and automatically reloads data.
 * Use in editor or development builds only.
 */
class FPolygenHotReloadManager
{
public:
    static FPolygenHotReloadManager& Get()
    {
        static FPolygenHotReloadManager Instance;
        return Instance;
    }
%blank
    // Data storage and reload delegates
{{data_storage}}    /**
     * Initialize hot reload system with base content path.
     * @param ContentPath - Base path for data files (e.g., FPaths::ProjectContentDir())
     */
    void Initialize(const FString& ContentPath)
    {
        BasePath = ContentPath;

        // Initial load of all data
        LoadAllData();

#if WITH_EDITOR
        // Start file watching in editor
        StartFileWatching();
#endif
    }
%blank
    void Shutdown()
    {
#if WITH_EDITOR
        StopFileWatching();
#endif
    }
%blank
    void LoadAllData()
    {
{{load_all_body}}    }
%blank
{{load_functions}}{{save_functions}}private:
    FPolygenHotReloadManager() = default;
    ~FPolygenHotReloadManager() = default;
%blank
    FString BasePath;
%blank
{{last_modified_fields}}
#if WITH_EDITOR
    FDelegateHandle TickDelegateHandle;
    float TimeSinceLastCheck = 0.0f;
    static constexpr float CheckInterval = 1.0f; // Check every second
%blank
    void StartFileWatching()
    {
        TickDelegateHandle = FTSTicker::GetCoreTicker().AddTicker(
            FTickerDelegate::CreateRaw(this, &FPolygenHotReloadManager::CheckForFileChanges),
            CheckInterval
        );
        UE_LOG(LogTemp, Log, TEXT("PolyGen Hot Reload: File watching started"));
    }
%blank
    void StopFileWatching()
    {
        if (TickDelegateHandle.IsValid())
        {
            FTSTicker::GetCoreTicker().RemoveTicker(TickDelegateHandle);
            TickDelegateHandle.Reset();
        }
    }
%blank
    bool CheckForFileChanges(float DeltaTime)
    {
        IFileManager& FileManager = IFileManager::Get();
%blank
{{file_check_body}}        return true; // Continue ticking
    }
#endif // WITH_EDITOR
};
%blank
// ============================================================================
// Convenience Macros
// ============================================================================
%blank
// Initialize hot reload in your game module or subsystem
#define POLYGEN_HOTRELOAD_INIT(ContentPath) \
    FPolygenHotReloadManager::Get().Initialize(ContentPath)
%blank
// Shutdown hot reload
#define POLYGEN_HOTRELOAD_SHUTDOWN() \
    FPolygenHotReloadManager::Get().Shutdown()
%blank
// Get data reference
{{convenience_macros}}
