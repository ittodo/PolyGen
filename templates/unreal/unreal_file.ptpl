%logic
// Unreal Engine Generator Entry Point
// Generates Unreal header files with USTRUCT/UENUM from .poly schema files

// Functions for generating struct and enum code
fn generate_enum(e) {
    let result = "";

    // Add E prefix for Unreal enum naming convention
    let enum_name = "E" + e.name;

    result += "UENUM(BlueprintType)\n";
    result += "enum class " + enum_name + " : uint8\n";
    result += "{\n";

    for enum_item in e.items {
        if enum_item.is_member() {
            let m = enum_item.as_member();
            if m.value != () {
                result += "    " + m.name + " = " + m.value + " UMETA(DisplayName = \"" + m.name + "\"),\n";
            } else {
                result += "    " + m.name + " UMETA(DisplayName = \"" + m.name + "\"),\n";
            }
        } else if enum_item.is_comment() {
            result += "    // " + enum_item.as_comment() + "\n";
        }
    }

    result += "};\n";
    return result;
}

fn generate_struct(s, ns_fqn) {
    let result = "";

    // Add F prefix for struct name
    let base_struct_name = s.name;
    let first_char = base_struct_name.sub_string(0, 1);
    let struct_name = if first_char == "F" { base_struct_name } else { "F" + base_struct_name };

    // Generate embedded structs FIRST (they must be declared before parent struct uses them)
    for item in s.items {
        if item.is_embedded_struct() {
            let es = item.as_embedded_struct();
            result += generate_struct(es, ns_fqn) + "\n";
        }
    }

    // Generate inline enums FIRST (they must be declared before the struct that uses them)
    for item in s.items {
        if item.is_inline_enum() {
            let ie = item.as_inline_enum();
            result += generate_enum(ie) + "\n\n";
        }
    }

    // Generate doc comments from header
    for item in s.header {
        if item.is_comment() {
            result += "/** " + item.as_comment() + " */\n";
        }
    }

    // USTRUCT declaration with BlueprintType
    result += "USTRUCT(BlueprintType)\n";
    result += "struct " + struct_name + "\n";
    result += "{\n";
    result += "    GENERATED_BODY()\n\n";

    // Generate fields with UPROPERTY
    for item in s.items {
        if item.is_field() {
            let f = item.as_field();
            let t = f.field_type;

            // Inline type mapping
            let ue_type = "";
            let type_name = t.type_name;

            // Check if primitive or enum
            let is_prim = false;
            let is_enum_type = false;
            if type_name == "string" || type_name == "bool" || type_name == "bytes" ||
               type_name == "u8" || type_name == "u16" || type_name == "u32" || type_name == "u64" ||
               type_name == "i8" || type_name == "i16" || type_name == "i32" || type_name == "i64" ||
               type_name == "f32" || type_name == "f64" {
                is_prim = true;
            }

            if t.is_primitive || is_prim {
                // Map primitive to Unreal type
                if type_name == "string" { ue_type = "FString"; }
                else if type_name == "bool" { ue_type = "bool"; }
                else if type_name == "u8" { ue_type = "uint8"; }
                else if type_name == "u16" { ue_type = "int32"; }
                else if type_name == "u32" { ue_type = "int32"; }
                else if type_name == "u64" { ue_type = "int64"; }
                else if type_name == "i8" { ue_type = "int32"; }
                else if type_name == "i16" { ue_type = "int32"; }
                else if type_name == "i32" { ue_type = "int32"; }
                else if type_name == "i64" { ue_type = "int64"; }
                else if type_name == "f32" { ue_type = "float"; }
                else if type_name == "f64" { ue_type = "double"; }
                else if type_name == "bytes" { ue_type = "TArray<uint8>"; }
                else { ue_type = type_name; }
            } else {
                // Custom type - determine if enum or struct
                let type_first = type_name.sub_string(0, 1);

                if t.is_enum || type_name == "Element" || type_name == "Status" || type_name == "ItemType" ||
                   type_name == "PlayerClass" || type_name == "Status__Enum" {
                    ue_type = "E" + type_name;
                    is_enum_type = true;
                } else if type_name.contains("Type") || type_name.contains("Status") || type_name.contains("Kind") ||
                          type_name.contains("Mode") || type_name.contains("State") {
                    ue_type = "E" + type_name;
                    is_enum_type = true;
                } else {
                    // Struct type - add F prefix if not already present
                    if type_first == "F" {
                        ue_type = type_name;
                    } else {
                        ue_type = "F" + type_name;
                    }
                }
            }

            // Apply array wrapper
            if t.is_list {
                ue_type = "TArray<" + ue_type + ">";
            }

            // UPROPERTY macro with specifiers
            let uprop_spec = "EditAnywhere, BlueprintReadWrite, Category = \"Data\"";

            // Handle optional fields with meta
            if t.is_option {
                uprop_spec += ", meta = (Optional)";
            }

            result += "    UPROPERTY(" + uprop_spec + ")\n";
            result += "    " + ue_type + " " + f.name;

            // Default value - UE5 requires all UPROPERTY to be initialized
            if !t.is_list {
                let default_val = "";
                // Use schema default() if specified
                let schema_default = f.default_value;
                if schema_default != () {
                    if type_name == "string" {
                        default_val = "TEXT(\"" + schema_default + "\")";
                    } else if type_name == "bool" {
                        default_val = if schema_default == "true" || schema_default == "1" { "true" } else { "false" };
                    } else if type_name == "f32" || type_name == "f64" {
                        // Ensure valid C++ float literal (e.g. "1" -> "1.0f", "1.5" -> "1.5f")
                        if !schema_default.contains(".") {
                            default_val = schema_default + ".0f";
                        } else {
                            default_val = schema_default + "f";
                        }
                    } else if is_enum_type {
                        default_val = "static_cast<" + ue_type + ">(" + schema_default + ")";
                    } else {
                        default_val = schema_default;
                    }
                } else if t.is_primitive || is_prim {
                    if type_name == "string" { default_val = "TEXT(\"\")"; }
                    else if type_name == "bool" { default_val = "false"; }
                    else if type_name == "u8" || type_name == "u16" || type_name == "u32" || type_name == "u64" ||
                            type_name == "i8" || type_name == "i16" || type_name == "i32" || type_name == "i64" {
                        default_val = "0";
                    }
                    else if type_name == "f32" || type_name == "f64" { default_val = "0.0f"; }
                } else if is_enum_type {
                    default_val = "static_cast<" + ue_type + ">(0)";
                }
                if default_val != "" {
                    result += " = " + default_val;
                }
            }

            result += ";\n\n";
        } else if item.is_comment() {
            result += "    // " + item.as_comment() + "\n";
        }
    }

    // Default constructor
    result += "    " + struct_name + "() = default;\n";

    // Pack/Unpack for @pack embed types
    if s.is_embed && s.pack_separator != () {
        let sep = s.pack_separator;
        let embed_fields = [];
        for item in s.items {
            if item.is_field() {
                embed_fields.push(item.as_field());
            }
        }

        if embed_fields.len() > 0 {
            // Pack() method
            result += "\n    /** Pack all fields into '" + sep + "'-separated string. */\n";
            result += "    FString Pack() const\n";
            result += "    {\n";

            let fmt_parts = [];
            let fmt_args = [];
            for ef in embed_fields {
                let tn = ef.field_type.type_name;
                let is_enum_type = ef.field_type.is_enum;
                if !is_enum_type {
                    if tn.contains("Type") || tn.contains("Status") || tn.contains("Kind") ||
                       tn.contains("Mode") || tn.contains("State") {
                        is_enum_type = true;
                    }
                }

                if tn == "string" {
                    fmt_parts.push("%s");
                    fmt_args.push("*" + ef.name);
                } else if tn == "f32" || tn == "f64" {
                    fmt_parts.push("%g");
                    fmt_args.push(ef.name);
                } else if tn == "bool" {
                    fmt_parts.push("%s");
                    fmt_args.push(ef.name + " ? TEXT(\"true\") : TEXT(\"false\")");
                } else if is_enum_type {
                    fmt_parts.push("%d");
                    fmt_args.push("static_cast<int32>(" + ef.name + ")");
                } else if tn == "u64" || tn == "i64" {
                    fmt_parts.push("%lld");
                    fmt_args.push("static_cast<int64>(" + ef.name + ")");
                } else {
                    fmt_parts.push("%d");
                    fmt_args.push(ef.name);
                }
            }

            let fmt_str = "";
            for i in 0..fmt_parts.len() {
                if i > 0 { fmt_str += sep; }
                fmt_str += fmt_parts[i];
            }

            result += "        return FString::Printf(TEXT(\"" + fmt_str + "\")";
            for arg in fmt_args {
                result += ", " + arg;
            }
            result += ");\n";
            result += "    }\n";

            // Unpack() static method
            result += "\n    /** Unpack a '" + sep + "'-separated string into fields. */\n";
            result += "    static " + struct_name + " Unpack(const FString& Str)\n";
            result += "    {\n";
            result += "        " + struct_name + " Result;\n";
            result += "        TArray<FString> Parts;\n";
            result += "        Str.ParseIntoArray(Parts, TEXT(\"" + sep + "\"), false);\n";

            for i in 0..embed_fields.len() {
                let ef = embed_fields[i];
                let idx_str = "" + i;
                let tn = ef.field_type.type_name;
                let is_enum_type = ef.field_type.is_enum;
                if !is_enum_type {
                    if tn.contains("Type") || tn.contains("Status") || tn.contains("Kind") ||
                       tn.contains("Mode") || tn.contains("State") {
                        is_enum_type = true;
                    }
                }

                result += "        if (Parts.IsValidIndex(" + idx_str + "))\n";
                result += "        {\n";

                if tn == "string" {
                    result += "            Result." + ef.name + " = Parts[" + idx_str + "];\n";
                } else if tn == "bool" {
                    result += "            Result." + ef.name + " = Parts[" + idx_str + "].ToBool();\n";
                } else if tn == "f32" || tn == "f64" {
                    result += "            Result." + ef.name + " = FCString::Atof(*Parts[" + idx_str + "]);\n";
                } else if is_enum_type {
                    let enum_name = "E" + tn;
                    result += "            Result." + ef.name + " = static_cast<" + enum_name + ">(FCString::Atoi(*Parts[" + idx_str + "]));\n";
                } else if tn == "u64" || tn == "i64" {
                    result += "            Result." + ef.name + " = FCString::Atoi64(*Parts[" + idx_str + "]);\n";
                } else {
                    result += "            Result." + ef.name + " = FCString::Atoi(*Parts[" + idx_str + "]);\n";
                }

                result += "        }\n";
            }

            result += "        return Result;\n";
            result += "    }\n";
        }
    }

    result += "};\n";

    return result;
}

fn generate_namespace(ns) {
    let result = "";
    let current_ns = ns.name;

    // Add namespace comment for organization
    if ns.name != "" {
        result += "// ============================================================================\n";
        result += "// Namespace: " + ns.name + "\n";
        result += "// ============================================================================\n\n";
    }

    // First pass: Generate standalone enums
    for item in ns.items {
        if item.is_enum() {
            let e = item.as_enum();
            result += generate_enum(e) + "\n\n";
        } else if item.is_comment() {
            let c = item.as_comment();
            result += "// " + c + "\n";
        }
    }

    // Second pass: Generate structs (which may contain inline enums)
    for item in ns.items {
        if item.is_struct() {
            let s = item.as_struct();
            result += generate_struct(s, current_ns) + "\n";
        }
    }

    // Third pass: Handle nested namespaces
    for item in ns.items {
        if item.is_namespace() {
            let child = item.as_namespace();
            result += generate_namespace(child);
        }
    }

    return result;
}

// ============================================================
// Data preparation
// ============================================================

let has_file = file.path != () && file.path != "";

let pascal_name = "";
let ns_bodies = "";
let is_common = false;

if has_file {
    let parts = file.path.split("/");
    let filename = parts[parts.len - 1];

    let base_name = filename + "";
    base_name.replace(".poly", "");

    let first_char = base_name.sub_string(0, 1);
    let rest = base_name.sub_string(1, base_name.len() - 1);
    pascal_name = first_char.to_upper() + rest;
    is_common = pascal_name == "Common";

    for ns in file.namespaces {
        ns_bodies += generate_namespace(ns);
    }
}
%endlogic
%if has_file
// Generated by PolyGen - DO NOT EDIT
// Source: {{file.path}}
%blank
#pragma once
%blank
#include "CoreMinimal.h"
%if !is_common
#include "PolygenCommon.h"
%endif
#include "Polygen{{pascal_name}}.generated.h"
%blank
{{ns_bodies}}
%endif
