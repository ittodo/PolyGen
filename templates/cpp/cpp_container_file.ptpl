%logic
// C++ Container File Template for PolyGen
// Generates data containers with indexes
// Ported from cpp_container_file.rhai → converted to 방식 A

import "templates/cpp/rhai_utils/type_mapping" as cpp_types;

// Check if struct has indexes defined
fn has_indexes(s) {
    if s.indexes != () && s.indexes.len() > 0 {
        return true;
    }
    return false;
}

// Get the fully qualified C++ type name
fn get_full_cpp_type(namespace_fqn, type_name) {
    if namespace_fqn == "" {
        return type_name;
    }
    let ns_cpp = namespace_fqn + "";
    ns_cpp.replace(".", "::");
    return "::" + ns_cpp + "::" + type_name;
}

// Pluralize a name (simple version)
fn pluralize(name) {
    if name.ends_with("y") {
        return name.sub_string(0, name.len() - 1) + "ies";
    } else if name.ends_with("s") || name.ends_with("x") || name.ends_with("ch") || name.ends_with("sh") {
        return name + "es";
    } else {
        return name + "s";
    }
}

// Get C++ type for a single field type
fn get_field_cpp_type(t) {
    if t.is_primitive || cpp_types::is_primitive_name(t.type_name) {
        return cpp_types::map_primitive_type(t.type_name);
    } else {
        return t.type_name;
    }
}

// Get C++ type for index key (supports composite indexes)
fn get_index_key_type(index) {
    if index.is_composite {
        let types = [];
        for f in index.fields {
            types.push(get_field_cpp_type(f.field_type));
        }
        let result = "std::tuple<";
        for i in 0..types.len() {
            if i > 0 { result += ", "; }
            result += types[i];
        }
        result += ">";
        return result;
    } else {
        let t = index.field_type;
        return get_field_cpp_type(t);
    }
}

// Get field accessor expression for index insert
fn get_index_key_expr(index, row_var) {
    if index.is_composite {
        let result = "std::make_tuple(";
        for i in 0..index.fields.len() {
            if i > 0 { result += ", "; }
            result += row_var + "." + index.fields[i].name;
        }
        result += ")";
        return result;
    } else {
        return row_var + "." + index.field_name;
    }
}

// Generate a table wrapper with indexes
fn generate_table_wrapper(s, namespace_fqn) {
    let result = "";
    let full_type = get_full_cpp_type(namespace_fqn, s.name);
    let table_name = s.name + "Table";
    let member_name = cpp_types::to_snake_case(pluralize(s.name));

    result += "// Table wrapper for " + s.name + " with indexes\n";
    result += "class " + table_name + " {\n";
    result += "public:\n";

    // Data storage
    result += "    polygen::DataTable<" + full_type + "> data;\n\n";

    // Index members
    if s.indexes != () {
        for idx in s.indexes {
            let key_type = get_index_key_type(idx);
            let index_member = idx.name;
            if idx.is_unique {
                result += "    polygen::UniqueIndex<" + key_type + ", " + full_type + "> " + index_member + ";\n";
            } else {
                result += "    polygen::GroupIndex<" + key_type + ", " + full_type + "> " + index_member + ";\n";
            }
        }
    }

    result += "\n";

    // add_row method
    result += "    void add_row(" + full_type + "&& row) {\n";
    result += "        data.add_row(std::move(row));\n";
    result += "        auto& added = data[data.count() - 1];\n";

    if s.indexes != () {
        for idx in s.indexes {
            let key_expr = get_index_key_expr(idx, "added");
            result += "        " + idx.name + ".insert(" + key_expr + ", &added);\n";
        }
    }

    result += "    }\n\n";

    result += "    void add_row(const " + full_type + "& row) {\n";
    result += "        add_row(" + full_type + "(row));\n";
    result += "    }\n\n";

    // Accessor methods
    result += "    size_t count() const { return data.count(); }\n";
    result += "    bool empty() const { return data.empty(); }\n\n";

    // get_by_X methods
    if s.indexes != () {
        for idx in s.indexes {
            let key_type = get_index_key_type(idx);
            let getter_name = if idx.is_composite {
                "get_" + idx.name
            } else {
                "get_by_" + idx.field_name
            };

            if idx.is_unique {
                result += "    " + full_type + "* " + getter_name + "(const " + key_type + "& key) {\n";
                result += "        return " + idx.name + ".get(key);\n";
                result += "    }\n\n";
                result += "    const " + full_type + "* " + getter_name + "(const " + key_type + "& key) const {\n";
                result += "        return const_cast<" + table_name + "*>(this)->" + idx.name + ".get(key);\n";
                result += "    }\n\n";
            } else {
                result += "    const std::vector<" + full_type + "*>& " + getter_name + "(const " + key_type + "& key) const {\n";
                result += "        return " + idx.name + ".get(key);\n";
                result += "    }\n\n";
            }
        }
    }

    // Iterator support
    result += "    auto begin() { return data.begin(); }\n";
    result += "    auto end() { return data.end(); }\n";
    result += "    auto begin() const { return data.begin(); }\n";
    result += "    auto end() const { return data.end(); }\n\n";

    // Clear method
    result += "    void clear() {\n";
    result += "        data.clear();\n";
    if s.indexes != () {
        for idx in s.indexes {
            result += "        " + idx.name + ".clear();\n";
        }
    }
    result += "    }\n\n";

    // Validate method
    result += "    /// Validates all rows against field constraints.\n";
    result += "    polygen::ValidationResult validate() const {\n";
    result += "        polygen::ValidationResult result;\n";
    result += "        for (const auto& row : data) {\n";

    // Get primary key expression for error messages
    let pk_expr = "\"\"";
    if s.indexes != () {
        for idx in s.indexes {
            if idx.name == "by_id" || idx.field_name == "id" {
                pk_expr = "std::to_string(row.id)";
                break;
            }
        }
    }

    // Validate each field with constraints
    for item in s.items {
        if item.is_field() {
            let field = item.as_field();
            let field_name = field.name;
            let is_option = field.field_type.is_option;
            let type_name = field.field_type.type_name;

            // MaxLength validation
            if field.max_length != () {
                let max_len = field.max_length;
                if is_option {
                    result += "            if (row." + field_name + ".has_value() && row." + field_name + "->length() > " + max_len + ") {\n";
                    result += "                result.add_error(polygen::validation::max_length_error(\n";
                    result += "                    \"" + s.name + "\", \"" + field_name + "\", " + pk_expr + ", " + max_len + ", row." + field_name + "->length()));\n";
                    result += "            }\n";
                } else if type_name == "string" {
                    result += "            if (row." + field_name + ".length() > " + max_len + ") {\n";
                    result += "                result.add_error(polygen::validation::max_length_error(\n";
                    result += "                    \"" + s.name + "\", \"" + field_name + "\", " + pk_expr + ", " + max_len + ", row." + field_name + ".length()));\n";
                    result += "            }\n";
                }
            }

            // Range validation
            if field.range != () {
                let min_val = field.range.min;
                let max_val = field.range.max;
                result += "            if (!polygen::validation::validate_range(row." + field_name + ", " + min_val + ", " + max_val + ")) {\n";
                result += "                result.add_error(polygen::validation::range_error(\n";
                result += "                    \"" + s.name + "\", \"" + field_name + "\", " + pk_expr + ", " + min_val + ", " + max_val + ", row." + field_name + "));\n";
                result += "            }\n";
            }

            // Regex validation
            if field.regex_pattern != () {
                let pattern = field.regex_pattern;
                let escaped_pattern = pattern;
                escaped_pattern.replace("\\", "\\\\");
                if is_option {
                    result += "            if (row." + field_name + ".has_value() && !polygen::validation::validate_regex(*row." + field_name + ", R\"(" + pattern + ")\")) {\n";
                    result += "                result.add_error(polygen::validation::regex_error(\n";
                    result += "                    \"" + s.name + "\", \"" + field_name + "\", " + pk_expr + ", R\"(" + pattern + ")\", *row." + field_name + "));\n";
                    result += "            }\n";
                } else if type_name == "string" {
                    result += "            if (!polygen::validation::validate_regex(row." + field_name + ", R\"(" + pattern + ")\")) {\n";
                    result += "                result.add_error(polygen::validation::regex_error(\n";
                    result += "                    \"" + s.name + "\", \"" + field_name + "\", " + pk_expr + ", R\"(" + pattern + ")\", row." + field_name + "));\n";
                    result += "            }\n";
                }
            }
        }
    }

    result += "        }\n";
    result += "        return result;\n";
    result += "    }\n\n";

    // ValidateForeignKeys method
    result += "    /// Validates foreign key references exist in related tables.\n";
    result += "    template<typename Container>\n";
    result += "    polygen::ValidationResult validate_foreign_keys(const Container& container) const {\n";
    result += "        polygen::ValidationResult result;\n";

    let has_fk = false;
    for item in s.items {
        if item.is_field() {
            let field = item.as_field();
            if field.foreign_key != () {
                has_fk = true;
            }
        }
    }

    if !has_fk {
        result += "        // No foreign key constraints to validate\n";
        result += "        (void)container; // Suppress unused variable warning\n";
    } else {
        result += "        for (const auto& row : data) {\n";

        for item in s.items {
            if item.is_field() {
                let field = item.as_field();
                if field.foreign_key != () {
                    let fk = field.foreign_key;
                    let target_parts = fk.target_table_fqn.split(".");
                    let target_table = "";
                    for part in target_parts {
                        target_table = part;
                    }
                    let target_member = cpp_types::to_snake_case(pluralize(target_table));

                    if field.field_type.is_option {
                        result += "            if (row." + field.name + ".has_value()) {\n";
                        result += "                // Check FK reference to " + target_table + "\n";
                        result += "                if constexpr (requires { container." + target_member + "; }) {\n";
                        result += "                    if (container." + target_member + ".get_by_" + fk.target_field + "(row." + field.name + ".value()) == nullptr) {\n";
                        result += "                        result.add_error(polygen::validation::foreign_key_error(\n";
                        result += "                            \"" + s.name + "\", \"" + field.name + "\", " + pk_expr + ",\n";
                        result += "                            \"" + target_table + "\", std::to_string(row." + field.name + ".value())));\n";
                        result += "                    }\n";
                        result += "                }\n";
                        result += "            }\n";
                    } else {
                        result += "            // Check FK reference to " + target_table + "\n";
                        result += "            if constexpr (requires { container." + target_member + "; }) {\n";
                        result += "                if (container." + target_member + ".get_by_" + fk.target_field + "(row." + field.name + ") == nullptr) {\n";
                        result += "                    result.add_error(polygen::validation::foreign_key_error(\n";
                        result += "                        \"" + s.name + "\", \"" + field.name + "\", " + pk_expr + ",\n";
                        result += "                        \"" + target_table + "\", std::to_string(row." + field.name + ")));\n";
                        result += "                }\n";
                        result += "            }\n";
                    }
                }
            }
        }

        result += "        }\n";
    }

    result += "        return result;\n";
    result += "    }\n";

    result += "};\n";

    return result;
}

// Convert snake_case or kebab-case to PascalCase
fn to_pascal_case(name) {
    let result = "";
    let capitalize_next = true;
    for i in 0..name.len() {
        let c = name.sub_string(i, 1);
        if c == "_" || c == "-" {
            capitalize_next = true;
        } else if capitalize_next {
            result += c.to_upper();
            capitalize_next = false;
        } else {
            result += c;
        }
    }
    return result;
}

// Generate the main container class body
fn generate_container(base_name, tables) {
    let result = "";
    let container_name = to_pascal_case(base_name) + "Container";

    result += "// Main data container with all tables\n";
    result += "class " + container_name + " {\n";
    result += "public:\n";

    for entry in tables {
        let s = entry.struct_def;
        let member_name = cpp_types::to_snake_case(pluralize(s.name));
        result += "    " + s.name + "Table " + member_name + ";\n";
    }

    result += "\n";

    // Clear all method
    result += "    void clear() {\n";
    for entry in tables {
        let s = entry.struct_def;
        let member_name = cpp_types::to_snake_case(pluralize(s.name));
        result += "        " + member_name + ".clear();\n";
    }
    result += "    }\n\n";

    // ValidateAll method
    result += "    /// Validates all tables and returns combined results.\n";
    result += "    polygen::ValidationResult validate_all() const {\n";
    result += "        polygen::ValidationResult result;\n";
    result += "        // Field constraint validation\n";
    for entry in tables {
        let s = entry.struct_def;
        let member_name = cpp_types::to_snake_case(pluralize(s.name));
        result += "        result.merge(" + member_name + ".validate());\n";
    }
    result += "        // Foreign key validation\n";
    for entry in tables {
        let s = entry.struct_def;
        let member_name = cpp_types::to_snake_case(pluralize(s.name));
        result += "        result.merge(" + member_name + ".validate_foreign_keys(*this));\n";
    }
    result += "        return result;\n";
    result += "    }\n\n";

    // ValidateOrThrow method
    result += "    /// Validates all tables and throws if any errors found.\n";
    result += "    void validate_or_throw() const {\n";
    result += "        auto result = validate_all();\n";
    result += "        if (!result.is_valid()) {\n";
    result += "            throw polygen::ValidationException(result);\n";
    result += "        }\n";
    result += "    }\n";

    result += "};\n";

    return result;
}

// ============================================================
// Data preparation
// ============================================================

// Guard: per_file template needs file.path
let has_file = file.path != () && file.path != "";

// Extract base_name
let base_name = "";
if has_file {
    let parts = file.path.split("/");
    let filename = parts[parts.len - 1];
    base_name = filename + "";
    base_name.replace(".poly", "");
}

// Collect all tables (structs with indexes)
let tables = [];
if has_file {
    for ns in file.namespaces {
        for item in ns.items {
            if item.is_struct() {
                let s = item.as_struct();
                if has_indexes(s) {
                    tables.push(#{ struct_def: s, namespace_name: ns.name });
                }
            } else if item.is_namespace() {
                let child_ns = item.as_namespace();
                for child_item in child_ns.items {
                    if child_item.is_struct() {
                        let cs = child_item.as_struct();
                        if has_indexes(cs) {
                            tables.push(#{ struct_def: cs, namespace_name: child_ns.name });
                        }
                    }
                }
            }
        }
    }
}

let has_tables = tables.len() > 0;

// Pre-compute per-table wrapper bodies
let idx = 0;
for entry in tables {
    let s = entry.struct_def;
    let ns = entry.namespace_name;
    tables[idx].wrapper_body = generate_table_wrapper(s, ns);
    idx += 1;
}

// Pre-compute container body
let container_body = "";
let container_ns = "";
if has_tables {
    container_body = generate_container(base_name, tables);
    container_ns = base_name + "";
    container_ns.replace("-", "_");
    container_ns += "_container";
}
%endlogic
%if has_file && has_tables
// Auto-generated by PolyGen - DO NOT EDIT
// Data container with indexed tables
#pragma once
%blank
#include "{{base_name}}.hpp"
#include "{{base_name}}_loaders.hpp"
#include "polygen_support.hpp"
#include <tuple>
%blank
namespace {{container_ns}} {
%blank
%for entry in tables
{{entry.wrapper_body}}
%endfor
{{container_body}}
} // namespace {{container_ns}}
%endif
