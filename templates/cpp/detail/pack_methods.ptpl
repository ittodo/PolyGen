%-- Pack/Unpack methods for @pack embeds. Context: struct
%logic
let sep = struct.pack_separator;
let fields = [];
for item in struct.items {
    if item.is_field() {
        fields.push(item.as_field());
    }
}

let pack_body = "";
let unpack_body = "";
let sname = struct.name;

if fields.len() > 0 {
    // Pack method body
    pack_body += "        std::ostringstream oss;\n";
    for i in 0..fields.len() {
        let f = fields[i];
        if i > 0 {
            pack_body += "        oss << \"" + sep + "\";\n";
        }
        pack_body += "        oss << " + f.name + ";\n";
    }
    pack_body += "        return oss.str();";

    // Unpack method body
    unpack_body += "        " + sname + " result;\n";
    unpack_body += "        std::istringstream iss(value);\n";
    unpack_body += "        std::string part;\n";

    for i in 0..fields.len() {
        let f = fields[i];
        let type_name = f.field_type.type_name;

        if i < fields.len() - 1 {
            unpack_body += "        if (!std::getline(iss, part, '" + sep + "')) {\n";
        } else {
            unpack_body += "        if (!std::getline(iss, part)) {\n";
        }
        unpack_body += "            throw std::runtime_error(\"Failed to unpack " + sname + ": missing field '" + f.name + "'\");\n";
        unpack_body += "        }\n";

        if type_name == "string" {
            unpack_body += "        result." + f.name + " = part;\n";
        } else if type_name == "bool" {
            unpack_body += "        result." + f.name + " = (part == \"true\" || part == \"1\");\n";
        } else if type_name == "f32" {
            unpack_body += "        result." + f.name + " = std::stof(part);\n";
        } else if type_name == "f64" {
            unpack_body += "        result." + f.name + " = std::stod(part);\n";
        } else if type_name == "i8" || type_name == "i16" || type_name == "i32" {
            let cpp_t = map_type_with_ns(f.field_type, "");
            unpack_body += "        result." + f.name + " = static_cast<" + cpp_t + ">(std::stoi(part));\n";
        } else if type_name == "i64" {
            unpack_body += "        result." + f.name + " = std::stoll(part);\n";
        } else if type_name == "u8" || type_name == "u16" || type_name == "u32" {
            let cpp_t = map_type_with_ns(f.field_type, "");
            unpack_body += "        result." + f.name + " = static_cast<" + cpp_t + ">(std::stoul(part));\n";
        } else if type_name == "u64" {
            unpack_body += "        result." + f.name + " = std::stoull(part);\n";
        } else {
            unpack_body += "        result." + f.name + " = part;\n";
        }
    }
    unpack_body += "        return result;";
}
let has_fields = fields.len() > 0;
%endlogic
%if has_fields

    /// Packs all fields into a single string using '{{struct.pack_separator}}' as separator.
    [[nodiscard]] std::string pack() const {
{{pack_body}}
    }

    /// Unpacks a string into fields using '{{struct.pack_separator}}' as separator.
    static {{struct.name}} unpack(const std::string& value) {
{{unpack_body}}
    }

    /// Tries to unpack a string. Returns true on success.
    static bool try_unpack(const std::string& value, {{struct.name}}& out) noexcept {
        try {
            out = unpack(value);
            return true;
        } catch (...) {
            return false;
        }
    }
%endif
