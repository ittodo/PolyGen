%logic
// C++ SQLite Accessor Generator
// Generates a header-only SQLite accessor for @datasource("sqlite") tables
// Ported from cpp_sqlite_accessor_file.rhai → converted to 방식 A

// Helper function to join array elements
fn join_with(arr, sep) {
    let result = "";
    let i = 0;
    for item in arr {
        if i > 0 { result += sep; }
        result += item;
        i += 1;
    }
    result
}

// Check if a struct should be included for SQLite
fn is_sqlite_table(struct_datasource, ns_datasource) {
    if struct_datasource != () && struct_datasource != "" {
        return struct_datasource == "sqlite";
    }
    if ns_datasource != () && ns_datasource != "" {
        return ns_datasource == "sqlite";
    }
    return false;
}

// Map poly types to C++ types
fn cpp_type(type_name) {
    switch type_name {
        "string" => "std::string",
        "bool" => "bool",
        "bytes" => "std::vector<uint8_t>",
        "u8" => "uint8_t",
        "u16" => "uint16_t",
        "u32" => "uint32_t",
        "u64" => "uint64_t",
        "i8" => "int8_t",
        "i16" => "int16_t",
        "i32" => "int32_t",
        "i64" => "int64_t",
        "f32" => "float",
        "f64" => "double",
        _ => type_name
    }
}

// Map poly types to sqlite3 column getter
fn sqlite_getter(type_name, stmt_var, idx) {
    switch type_name {
        "string" => "reinterpret_cast<const char*>(sqlite3_column_text(" + stmt_var + ", " + idx + "))",
        "bool" => "sqlite3_column_int(" + stmt_var + ", " + idx + ") != 0",
        "u8" => "static_cast<uint8_t>(sqlite3_column_int(" + stmt_var + ", " + idx + "))",
        "u16" => "static_cast<uint16_t>(sqlite3_column_int(" + stmt_var + ", " + idx + "))",
        "u32" => "static_cast<uint32_t>(sqlite3_column_int64(" + stmt_var + ", " + idx + "))",
        "u64" => "static_cast<uint64_t>(sqlite3_column_int64(" + stmt_var + ", " + idx + "))",
        "i8" => "static_cast<int8_t>(sqlite3_column_int(" + stmt_var + ", " + idx + "))",
        "i16" => "static_cast<int16_t>(sqlite3_column_int(" + stmt_var + ", " + idx + "))",
        "i32" => "sqlite3_column_int(" + stmt_var + ", " + idx + ")",
        "i64" => "sqlite3_column_int64(" + stmt_var + ", " + idx + ")",
        "f32" => "static_cast<float>(sqlite3_column_double(" + stmt_var + ", " + idx + "))",
        "f64" => "sqlite3_column_double(" + stmt_var + ", " + idx + ")",
        _ => "sqlite3_column_text(" + stmt_var + ", " + idx + ")"
    }
}

// Helper to remove .poly extension
fn remove_poly_extension(filename) {
    let len = filename.len();
    let poly_len = 5;
    if len > poly_len {
        let suffix_start = len - poly_len;
        let suffix = filename.sub_string(suffix_start, poly_len);
        if suffix == ".poly" {
            return filename.sub_string(0, suffix_start);
        }
    }
    filename
}

// Generate nested table class body for a single table
fn generate_table_class(tbl) {
    let s = tbl.struct_def;
    let result = "";

    result += "    class " + tbl.name + "Table : public DbTable<" + tbl.ns_cpp + "::" + tbl.name + "> {\n";
    result += "    public:\n";
    result += "        " + tbl.name + "Table() : DbTable(\"" + tbl.table_name + "\") {}\n\n";

    result += "        void load(sqlite3* db) {\n";
    result += "            cache_.clear();\n";
    result += "            sqlite3_stmt* stmt;\n";
    result += "            std::string sql = \"SELECT * FROM \" + table_name_;\n";
    result += "            if (sqlite3_prepare_v2(db, sql.c_str(), -1, &stmt, nullptr) != SQLITE_OK) {\n";
    result += "                throw std::runtime_error(\"Failed to prepare statement: \" + std::string(sqlite3_errmsg(db)));\n";
    result += "            }\n";
    result += "            while (sqlite3_step(stmt) == SQLITE_ROW) {\n";
    result += "                cache_.push_back(map_row(stmt));\n";
    result += "            }\n";
    result += "            sqlite3_finalize(stmt);\n";
    result += "        }\n";

    // Generate get_by_id method
    if tbl.has_id {
        result += "\n";
        result += "        std::optional<" + tbl.ns_cpp + "::" + tbl.name + "> get_by_id(sqlite3* db, " + tbl.id_type + " id) const {\n";
        result += "            sqlite3_stmt* stmt;\n";
        result += "            std::string sql = \"SELECT * FROM \" + table_name_ + \" WHERE " + tbl.id_field + " = ?\";\n";
        result += "            if (sqlite3_prepare_v2(db, sql.c_str(), -1, &stmt, nullptr) != SQLITE_OK) {\n";
        result += "                throw std::runtime_error(\"Failed to prepare statement\");\n";
        result += "            }\n";
        result += "            sqlite3_bind_int64(stmt, 1, static_cast<int64_t>(id));\n";
        result += "            std::optional<" + tbl.ns_cpp + "::" + tbl.name + "> result;\n";
        result += "            if (sqlite3_step(stmt) == SQLITE_ROW) {\n";
        result += "                result = map_row(stmt);\n";
        result += "            }\n";
        result += "            sqlite3_finalize(stmt);\n";
        result += "            return result;\n";
        result += "        }\n";
    }

    result += "\n    private:\n";
    result += "        static " + tbl.ns_cpp + "::" + tbl.name + " map_row(sqlite3_stmt* stmt) {\n";
    result += "            " + tbl.ns_cpp + "::" + tbl.name + " obj;\n";

    let field_idx = 0;
    for item in s.items {
        if item.is_field() {
            let f = item.as_field();
            let type_name = f.field_type.type_name;
            let getter = sqlite_getter(type_name, "stmt", field_idx);
            result += "            obj." + f.name + " = " + getter + ";\n";
            field_idx += 1;
        }
    }

    result += "            return obj;\n";
    result += "        }\n";
    result += "    };";

    return result;
}

// ============================================================
// Data preparation
// ============================================================

// Collect all SQLite tables
let sqlite_tables = [];

for f in schema.files {
    if f.path == () || f.path == "" { continue; }

    for ns in f.namespaces {
        let ns_datasource = ns.datasource;

        for item in ns.items {
            if item.is_struct() {
                let s = item.as_struct();
                if is_sqlite_table(s.datasource, ns_datasource) {
                    let ns_parts = ns.name.split(".");
                    let ns_cpp = join_with(ns_parts, "::");
                    let table_name = join_with(ns_parts, "_") + "_" + s.name;

                    sqlite_tables.push(#{
                        name: s.name,
                        fqn: s.fqn,
                        ns_name: ns.name,
                        ns_cpp: ns_cpp,
                        table_name: table_name,
                        struct_def: s
                    });
                }
            }
        }
    }
}

let has_tables = sqlite_tables.len() > 0;

// Determine the main header to include
let main_header = "schema.hpp";
for f in schema.files {
    let fp = f.path;
    if fp != () && fp != "" {
        let base_name = fp;
        if fp.contains("/") {
            let parts = fp.split("/");
            base_name = parts[parts.len() - 1];
        }
        let name_without_ext = remove_poly_extension(base_name);
        main_header = name_without_ext + ".hpp";
        break;
    }
}

// Pre-compute per-table data (using index-based mutation)
let tidx = 0;
for tbl in sqlite_tables {
    let s = tbl.struct_def;

    // Find first field for get_by_id
    let id_field = ();
    let id_type = "int64_t";
    for item in s.items {
        if item.is_field() {
            let f = item.as_field();
            id_field = f.name;
            id_type = cpp_type(f.field_type.type_name);
            break;
        }
    }
    sqlite_tables[tidx].id_field = id_field;
    sqlite_tables[tidx].id_type = id_type;
    sqlite_tables[tidx].has_id = id_field != ();
    sqlite_tables[tidx].field_name = tbl.name + "s";

    // Pre-compute table class body
    sqlite_tables[tidx].class_body = generate_table_class(sqlite_tables[tidx]);

    tidx += 1;
}
%endlogic
%if has_tables
// Generated by PolyGen - SQLite Database Accessor
// This header provides typed access to SQLite tables.
#pragma once
%blank
#include <sqlite3.h>
#include <string>
#include <vector>
#include <optional>
#include <stdexcept>
#include <memory>
%blank
#include "{{main_header}}"
%blank
namespace polygen {
namespace sqlite {
%blank
/// Provides typed access to a SQLite table.
template<typename T>
class DbTable {
public:
    explicit DbTable(const std::string& table_name) : table_name_(table_name) {}
%blank
    const std::vector<T>& all() const { return cache_; }
    size_t size() const { return cache_.size(); }
    bool empty() const { return cache_.empty(); }
    void clear() { cache_.clear(); }
%blank
protected:
    std::string table_name_;
    std::vector<T> cache_;
};
%blank
/// SQLite database accessor for game data.
class SqliteDb {
public:
%for tbl in sqlite_tables
{{tbl.class_body}}
%blank
%endfor
%for tbl in sqlite_tables
    {{tbl.name}}Table {{tbl.field_name}};
%endfor
%blank
private:
    sqlite3* db_ = nullptr;
%blank
public:
    SqliteDb() = default;
    ~SqliteDb() { close(); }
%blank
    // Non-copyable
    SqliteDb(const SqliteDb&) = delete;
    SqliteDb& operator=(const SqliteDb&) = delete;
%blank
    // Movable
    SqliteDb(SqliteDb&& other) noexcept : db_(other.db_) { other.db_ = nullptr; }
    SqliteDb& operator=(SqliteDb&& other) noexcept {
        if (this != &other) { close(); db_ = other.db_; other.db_ = nullptr; }
        return *this;
    }
%blank
    /// Opens a connection to the SQLite database.
    bool open(const std::string& path) {
        close();
        return sqlite3_open(path.c_str(), &db_) == SQLITE_OK;
    }
%blank
    /// Closes the database connection.
    void close() {
        if (db_) {
            sqlite3_close(db_);
            db_ = nullptr;
        }
    }
%blank
    /// Returns true if the database is open.
    bool is_open() const { return db_ != nullptr; }
%blank
    /// Loads all tables into memory.
    void load_all() {
        if (!db_) throw std::runtime_error("Database not open");
%for tbl in sqlite_tables
        {{tbl.field_name}}.load(db_);
%endfor
    }
};
%blank
} // namespace sqlite
} // namespace polygen
%endif
