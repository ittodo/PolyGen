%logic
// C++ SQLite Accessor Generator
// Generates a header-only SQLite accessor for @datasource("sqlite") tables
// Ported from cpp_sqlite_accessor_file.rhai

// Helper function to join array elements
fn join_with(arr, sep) {
    let result = "";
    let i = 0;
    for item in arr {
        if i > 0 { result += sep; }
        result += item;
        i += 1;
    }
    result
}

// Check if a struct should be included for SQLite
fn is_sqlite_table(struct_datasource, ns_datasource) {
    if struct_datasource != () && struct_datasource != "" {
        return struct_datasource == "sqlite";
    }
    if ns_datasource != () && ns_datasource != "" {
        return ns_datasource == "sqlite";
    }
    return false;
}

// Map poly types to C++ types
fn cpp_type(type_name) {
    switch type_name {
        "string" => "std::string",
        "bool" => "bool",
        "bytes" => "std::vector<uint8_t>",
        "u8" => "uint8_t",
        "u16" => "uint16_t",
        "u32" => "uint32_t",
        "u64" => "uint64_t",
        "i8" => "int8_t",
        "i16" => "int16_t",
        "i32" => "int32_t",
        "i64" => "int64_t",
        "f32" => "float",
        "f64" => "double",
        _ => type_name
    }
}

// Map poly types to sqlite3 column getter
fn sqlite_getter(type_name, stmt_var, idx) {
    switch type_name {
        "string" => "reinterpret_cast<const char*>(sqlite3_column_text(" + stmt_var + ", " + idx + "))",
        "bool" => "sqlite3_column_int(" + stmt_var + ", " + idx + ") != 0",
        "u8" => "static_cast<uint8_t>(sqlite3_column_int(" + stmt_var + ", " + idx + "))",
        "u16" => "static_cast<uint16_t>(sqlite3_column_int(" + stmt_var + ", " + idx + "))",
        "u32" => "static_cast<uint32_t>(sqlite3_column_int64(" + stmt_var + ", " + idx + "))",
        "u64" => "static_cast<uint64_t>(sqlite3_column_int64(" + stmt_var + ", " + idx + "))",
        "i8" => "static_cast<int8_t>(sqlite3_column_int(" + stmt_var + ", " + idx + "))",
        "i16" => "static_cast<int16_t>(sqlite3_column_int(" + stmt_var + ", " + idx + "))",
        "i32" => "sqlite3_column_int(" + stmt_var + ", " + idx + ")",
        "i64" => "sqlite3_column_int64(" + stmt_var + ", " + idx + ")",
        "f32" => "static_cast<float>(sqlite3_column_double(" + stmt_var + ", " + idx + "))",
        "f64" => "sqlite3_column_double(" + stmt_var + ", " + idx + ")",
        _ => "sqlite3_column_text(" + stmt_var + ", " + idx + ")"
    }
}

// Helper to remove .poly extension
fn remove_poly_extension(filename) {
    let len = filename.len();
    let poly_len = 5;
    if len > poly_len {
        let suffix_start = len - poly_len;
        let suffix = filename.sub_string(suffix_start, poly_len);
        if suffix == ".poly" {
            return filename.sub_string(0, suffix_start);
        }
    }
    filename
}

// Collect all SQLite tables
let sqlite_tables = [];

for f in schema.files {
    if f.path == () || f.path == "" { continue; }

    for ns in f.namespaces {
        let ns_datasource = ns.datasource;

        for item in ns.items {
            if item.is_struct() {
                let s = item.as_struct();
                if is_sqlite_table(s.datasource, ns_datasource) {
                    let ns_parts = ns.name.split(".");
                    let ns_cpp = join_with(ns_parts, "::");

                    sqlite_tables.push(#{
                        name: s.name,
                        fqn: s.fqn,
                        ns_name: ns.name,
                        ns_cpp: ns_cpp,
                        struct_def: s
                    });
                }
            }
        }
    }
}

let skip_output = true;

// Only generate if there are SQLite tables
if sqlite_tables.len > 0 {
    // Generate the accessor code
    let code = "// Generated by PolyGen - SQLite Database Accessor\n";
    code += "// This header provides typed access to SQLite tables.\n";
    code += "#pragma once\n\n";

    code += "#include <sqlite3.h>\n";
    code += "#include <string>\n";
    code += "#include <vector>\n";
    code += "#include <optional>\n";
    code += "#include <stdexcept>\n";
    code += "#include <memory>\n\n";

    // Determine the main header to include
    let main_header = "schema.hpp";
    for f in schema.files {
        let fp = f.path;
        if fp != () && fp != "" {
            let base_name = fp;
            if fp.contains("/") {
                let parts = fp.split("/");
                base_name = parts[parts.len() - 1];
            }
            let name_without_ext = remove_poly_extension(base_name);
            main_header = name_without_ext + ".hpp";
            break;
        }
    }
    code += "#include \"" + main_header + "\"\n\n";

    code += "namespace polygen {\n";
    code += "namespace sqlite {\n\n";

    // Generate DbTable template class
    code += "/// Provides typed access to a SQLite table.\n";
    code += "template<typename T>\n";
    code += "class DbTable {\n";
    code += "public:\n";
    code += "    explicit DbTable(const std::string& table_name) : table_name_(table_name) {}\n\n";

    code += "    const std::vector<T>& all() const { return cache_; }\n";
    code += "    size_t size() const { return cache_.size(); }\n";
    code += "    bool empty() const { return cache_.empty(); }\n";
    code += "    void clear() { cache_.clear(); }\n\n";

    code += "protected:\n";
    code += "    std::string table_name_;\n";
    code += "    std::vector<T> cache_;\n";
    code += "};\n\n";

    // Generate SqliteDb class
    code += "/// SQLite database accessor for game data.\n";
    code += "class SqliteDb {\n";
    code += "public:\n";

    // Nested table classes with mappers
    for tbl in sqlite_tables {
        let s = tbl.struct_def;
        code += "    class " + tbl.name + "Table : public DbTable<" + tbl.ns_cpp + "::" + tbl.name + "> {\n";
        code += "    public:\n";
        code += "        " + tbl.name + "Table() : DbTable(\"";

        let ns_parts = tbl.ns_name.split(".");
        let table_name = join_with(ns_parts, "_") + "_" + tbl.name;
        code += table_name + "\") {}\n\n";

        code += "        void load(sqlite3* db) {\n";
        code += "            cache_.clear();\n";
        code += "            sqlite3_stmt* stmt;\n";
        code += "            std::string sql = \"SELECT * FROM \" + table_name_;\n";
        code += "            if (sqlite3_prepare_v2(db, sql.c_str(), -1, &stmt, nullptr) != SQLITE_OK) {\n";
        code += "                throw std::runtime_error(\"Failed to prepare statement: \" + std::string(sqlite3_errmsg(db)));\n";
        code += "            }\n";
        code += "            while (sqlite3_step(stmt) == SQLITE_ROW) {\n";
        code += "                cache_.push_back(map_row(stmt));\n";
        code += "            }\n";
        code += "            sqlite3_finalize(stmt);\n";
        code += "        }\n\n";

        // Generate get_by_id method
        let id_field = ();
        let id_type = "int64_t";
        for item in s.items {
            if item.is_field() {
                let f = item.as_field();
                id_field = f.name;
                id_type = cpp_type(f.field_type.type_name);
                break;
            }
        }

        if id_field != () {
            code += "        std::optional<" + tbl.ns_cpp + "::" + tbl.name + "> get_by_id(sqlite3* db, " + id_type + " id) const {\n";
            code += "            sqlite3_stmt* stmt;\n";
            code += "            std::string sql = \"SELECT * FROM \" + table_name_ + \" WHERE " + id_field + " = ?\";\n";
            code += "            if (sqlite3_prepare_v2(db, sql.c_str(), -1, &stmt, nullptr) != SQLITE_OK) {\n";
            code += "                throw std::runtime_error(\"Failed to prepare statement\");\n";
            code += "            }\n";
            code += "            sqlite3_bind_int64(stmt, 1, static_cast<int64_t>(id));\n";
            code += "            std::optional<" + tbl.ns_cpp + "::" + tbl.name + "> result;\n";
            code += "            if (sqlite3_step(stmt) == SQLITE_ROW) {\n";
            code += "                result = map_row(stmt);\n";
            code += "            }\n";
            code += "            sqlite3_finalize(stmt);\n";
            code += "            return result;\n";
            code += "        }\n\n";
        }

        code += "    private:\n";
        code += "        static " + tbl.ns_cpp + "::" + tbl.name + " map_row(sqlite3_stmt* stmt) {\n";
        code += "            " + tbl.ns_cpp + "::" + tbl.name + " obj;\n";

        let field_idx = 0;
        for item in s.items {
            if item.is_field() {
                let f = item.as_field();
                let type_name = f.field_type.type_name;
                let getter = sqlite_getter(type_name, "stmt", field_idx);

                code += "            obj." + f.name + " = " + getter + ";\n";
                field_idx += 1;
            }
        }

        code += "            return obj;\n";
        code += "        }\n";
        code += "    };\n\n";
    }

    // Public members
    for tbl in sqlite_tables {
        let field_name = tbl.name + "s";
        code += "    " + tbl.name + "Table " + field_name + ";\n";
    }
    code += "\n";

    code += "private:\n";
    code += "    sqlite3* db_ = nullptr;\n\n";

    code += "public:\n";
    code += "    SqliteDb() = default;\n";
    code += "    ~SqliteDb() { close(); }\n\n";

    code += "    // Non-copyable\n";
    code += "    SqliteDb(const SqliteDb&) = delete;\n";
    code += "    SqliteDb& operator=(const SqliteDb&) = delete;\n\n";

    code += "    // Movable\n";
    code += "    SqliteDb(SqliteDb&& other) noexcept : db_(other.db_) { other.db_ = nullptr; }\n";
    code += "    SqliteDb& operator=(SqliteDb&& other) noexcept {\n";
    code += "        if (this != &other) { close(); db_ = other.db_; other.db_ = nullptr; }\n";
    code += "        return *this;\n";
    code += "    }\n\n";

    code += "    /// Opens a connection to the SQLite database.\n";
    code += "    bool open(const std::string& path) {\n";
    code += "        close();\n";
    code += "        return sqlite3_open(path.c_str(), &db_) == SQLITE_OK;\n";
    code += "    }\n\n";

    code += "    /// Closes the database connection.\n";
    code += "    void close() {\n";
    code += "        if (db_) {\n";
    code += "            sqlite3_close(db_);\n";
    code += "            db_ = nullptr;\n";
    code += "        }\n";
    code += "    }\n\n";

    code += "    /// Returns true if the database is open.\n";
    code += "    bool is_open() const { return db_ != nullptr; }\n\n";

    code += "    /// Loads all tables into memory.\n";
    code += "    void load_all() {\n";
    code += "        if (!db_) throw std::runtime_error(\"Database not open\");\n";
    for tbl in sqlite_tables {
        let field_name = tbl.name + "s";
        code += "        " + field_name + ".load(db_);\n";
    }
    code += "    }\n";

    code += "};\n\n";

    code += "} // namespace sqlite\n";
    code += "} // namespace polygen\n";

    // Determine output filename
    let out_filename = "schema_sqlite_accessor.hpp";
    for f in schema.files {
        let fp = f.path;
        if fp != () && fp != "" {
            let base_name = fp;
            if fp.contains("/") {
                let parts = fp.split("/");
                base_name = parts[parts.len() - 1];
            }
            let name_without_ext = remove_poly_extension(base_name);
            out_filename = name_without_ext + "_sqlite_accessor.hpp";
            break;
        }
    }

    let out_path = output_dir + "/cpp/" + out_filename;
    print("Generating file: " + out_path);
    write_file(out_path, code);
}
%endlogic
