# C++ Language Configuration for PolyGen
# This file configures the C++ code generation settings.

# File extension for generated C++ header files
extension = ".hpp"

# Static files to copy to the output directory
# Format: "destination/path.ext" = "source/path.ext"
[static_files]
"polygen_support.hpp" = "static/cpp/polygen_support.hpp"

# Type mapping: poly type -> C++ type
[type_map]
u8 = "uint8_t"
i8 = "int8_t"
u16 = "uint16_t"
i16 = "int16_t"
u32 = "uint32_t"
i32 = "int32_t"
u64 = "uint64_t"
i64 = "int64_t"
f32 = "float"
f64 = "double"
bool = "bool"
string = "std::string"
bytes = "std::vector<uint8_t>"
timestamp = "std::chrono::system_clock::time_point"

[type_map.optional]
format = "std::optional<{{type}}>"

[type_map.list]
format = "std::vector<{{type}}>"

[type_map.non_primitive]
format = "::{{type}}"

# Template configuration
[templates]
# Main template for generating C++ headers (Level 1: Basic)
main = "cpp_file.ptpl"

# Extra templates to run after the main template
# Level 2: Data Loaders (Binary serialization)
[[templates.extra]]
template = "cpp_loaders_file.ptpl"
output = "{{stem}}_loaders.hpp"

# Level 3: Container System (indexes, relations)
[[templates.extra]]
template = "cpp_container_file.ptpl"
output = "{{stem}}_container.hpp"

# Level 4: SQLite Accessor (for @datasource("sqlite") tables)
[[templates.extra]]
template = "cpp_sqlite_accessor_file.ptpl"
output = "{{stem}}_sqlite_accessor.hpp"
per_file = false

# Rhai prelude scripts for %logic blocks in ptpl templates
[rhai]
prelude = ["rhai_utils/type_mapping.rhai"]
