%logic
// C++ Loaders File Template for PolyGen
// Generates Binary read/write functions
// Ported from cpp_loaders_file.rhai → converted to 방식 A

import "templates/cpp/rhai_utils/type_mapping" as cpp_types;

// Get the fully qualified C++ type name
fn get_full_cpp_type(namespace_fqn, type_name) {
    if namespace_fqn == "" {
        return type_name;
    }
    let ns_cpp = namespace_fqn + "";
    ns_cpp.replace(".", "::");
    return "::" + ns_cpp + "::" + type_name;
}

// Check if a string starts with uppercase (likely a struct/class name)
fn is_pascal_case(s) {
    if s.len() == 0 { return false; }
    let first = s.sub_string(0, 1);
    return first >= "A" && first <= "Z";
}

// Get namespace FQN, stripping parent struct name if present
fn get_clean_namespace(ns_fqn) {
    if ns_fqn == "" { return ""; }
    let parts = ns_fqn.split(".");
    if parts.len() <= 1 { return ns_fqn; }
    let last = parts[parts.len() - 1];
    if is_pascal_case(last) {
        let clean_ns = "";
        for i in 0..(parts.len() - 1) {
            if i > 0 { clean_ns += "."; }
            clean_ns += parts[i];
        }
        return clean_ns;
    }
    return ns_fqn;
}

// Get fully qualified type for a type_ref
fn get_type_fqn(type_ref) {
    if type_ref.is_primitive || cpp_types::is_primitive_name(type_ref.type_name) {
        return cpp_types::map_primitive_type(type_ref.type_name);
    }
    if type_ref.is_enum {
        return get_full_cpp_type(type_ref.namespace_fqn, type_ref.type_name);
    }
    let clean_ns = get_clean_namespace(type_ref.namespace_fqn);
    return get_full_cpp_type(clean_ns, type_ref.type_name);
}

fn get_primitive_reader(type_name) {
    switch type_name {
        "string" => "read_string",
        "bool" => "read_bool",
        "u8" => "read_u8",
        "u16" => "read_u16",
        "u32" => "read_u32",
        "u64" => "read_u64",
        "i8" => "read_i8",
        "i16" => "read_i16",
        "i32" => "read_i32",
        "i64" => "read_i64",
        "f32" => "read_f32",
        "f64" => "read_f64",
        "bytes" => "read_bytes",
        "timestamp" => "read_timestamp",
        _ => "read_i32"
    }
}

fn get_primitive_writer(type_name) {
    switch type_name {
        "string" => "write_string",
        "bool" => "write_bool",
        "u8" => "write_u8",
        "u16" => "write_u16",
        "u32" => "write_u32",
        "u64" => "write_u64",
        "i8" => "write_i8",
        "i16" => "write_i16",
        "i32" => "write_i32",
        "i64" => "write_i64",
        "f32" => "write_f32",
        "f64" => "write_f64",
        "bytes" => "write_bytes",
        "timestamp" => "write_timestamp",
        _ => "write_i32"
    }
}

// Binary read for a field type
fn bin_read_expr(type_ref) {
    let n = type_ref.type_name;
    if n == "string" { return "reader.read_string()"; }
    if n == "bool" { return "reader.read_bool()"; }
    if n == "u8" { return "reader.read_u8()"; }
    if n == "u16" { return "reader.read_u16()"; }
    if n == "u32" { return "reader.read_u32()"; }
    if n == "u64" { return "reader.read_u64()"; }
    if n == "i8" { return "reader.read_i8()"; }
    if n == "i16" { return "reader.read_i16()"; }
    if n == "i32" { return "reader.read_i32()"; }
    if n == "i64" { return "reader.read_i64()"; }
    if n == "f32" { return "reader.read_f32()"; }
    if n == "f64" { return "reader.read_f64()"; }
    if n == "bytes" { return "reader.read_bytes()"; }
    if n == "timestamp" { return "reader.read_timestamp()"; }
    let full_type = get_type_fqn(type_ref);
    if type_ref.is_enum {
        return "reader.read_enum<" + full_type + ">()";
    }
    return "read_" + n + "(reader)";
}

// Binary write for a field type
fn bin_write_expr(type_ref, value_expr) {
    let n = type_ref.type_name;
    if n == "string" { return "writer.write_string(" + value_expr + ")"; }
    if n == "bool" { return "writer.write_bool(" + value_expr + ")"; }
    if n == "u8" { return "writer.write_u8(" + value_expr + ")"; }
    if n == "u16" { return "writer.write_u16(" + value_expr + ")"; }
    if n == "u32" { return "writer.write_u32(" + value_expr + ")"; }
    if n == "u64" { return "writer.write_u64(" + value_expr + ")"; }
    if n == "i8" { return "writer.write_i8(" + value_expr + ")"; }
    if n == "i16" { return "writer.write_i16(" + value_expr + ")"; }
    if n == "i32" { return "writer.write_i32(" + value_expr + ")"; }
    if n == "i64" { return "writer.write_i64(" + value_expr + ")"; }
    if n == "f32" { return "writer.write_f32(" + value_expr + ")"; }
    if n == "f64" { return "writer.write_f64(" + value_expr + ")"; }
    if n == "bytes" { return "writer.write_bytes(" + value_expr + ")"; }
    if n == "timestamp" { return "writer.write_timestamp(" + value_expr + ")"; }
    if type_ref.is_enum {
        return "writer.write_enum(" + value_expr + ")";
    }
    return "write_" + n + "(writer, " + value_expr + ")";
}

// Generate binary read function body for a struct
fn generate_binary_read(s, namespace_fqn) {
    let result = "";
    let full_type = get_full_cpp_type(namespace_fqn, s.name);

    result += "inline " + full_type + " read_" + s.name + "(polygen::BinaryReader& reader) {\n";
    result += "    " + full_type + " obj;\n";

    for item in s.items {
        if item.is_field() {
            let f = item.as_field();
            let t = f.field_type;
            let n = f.name;
            let elem_type = get_type_fqn(t);

            if t.is_list {
                if t.is_primitive || cpp_types::is_primitive_name(t.type_name) {
                    result += "    obj." + n + " = reader.read_vector<" + elem_type + ">([](polygen::BinaryReader& r) { return r." + get_primitive_reader(t.type_name) + "(); });\n";
                } else {
                    result += "    obj." + n + " = reader.read_vector<" + elem_type + ">([](polygen::BinaryReader& r) { return read_" + t.type_name + "(r); });\n";
                }
            } else if t.is_option {
                if t.type_name == "string" {
                    result += "    obj." + n + " = reader.read_optional_string();\n";
                } else if t.is_primitive || cpp_types::is_primitive_name(t.type_name) {
                    result += "    obj." + n + " = reader.read_optional<" + elem_type + ">([](polygen::BinaryReader& r) { return r." + get_primitive_reader(t.type_name) + "(); });\n";
                } else {
                    result += "    obj." + n + " = reader.read_optional<" + elem_type + ">([](polygen::BinaryReader& r) { return read_" + t.type_name + "(r); });\n";
                }
            } else {
                result += "    obj." + n + " = " + bin_read_expr(t) + ";\n";
            }
        }
    }

    result += "    return obj;\n";
    result += "}";

    return result;
}

// Generate binary write function body for a struct
fn generate_binary_write(s, namespace_fqn) {
    let result = "";
    let full_type = get_full_cpp_type(namespace_fqn, s.name);

    result += "inline void write_" + s.name + "(polygen::BinaryWriter& writer, const " + full_type + "& obj) {\n";

    for item in s.items {
        if item.is_field() {
            let f = item.as_field();
            let t = f.field_type;
            let n = f.name;
            let elem_type = get_type_fqn(t);

            if t.is_list {
                if t.is_primitive || cpp_types::is_primitive_name(t.type_name) {
                    result += "    writer.write_vector(obj." + n + ", [](polygen::BinaryWriter& w, const " + elem_type + "& v) { w." + get_primitive_writer(t.type_name) + "(v); });\n";
                } else {
                    result += "    writer.write_vector(obj." + n + ", [](polygen::BinaryWriter& w, const " + elem_type + "& v) { write_" + t.type_name + "(w, v); });\n";
                }
            } else if t.is_option {
                if t.type_name == "string" {
                    result += "    writer.write_optional_string(obj." + n + ");\n";
                } else if t.is_primitive || cpp_types::is_primitive_name(t.type_name) {
                    result += "    writer.write_optional(obj." + n + ", [](polygen::BinaryWriter& w, const " + elem_type + "& v) { w." + get_primitive_writer(t.type_name) + "(v); });\n";
                } else {
                    result += "    writer.write_optional(obj." + n + ", [](polygen::BinaryWriter& w, const " + elem_type + "& v) { write_" + t.type_name + "(w, v); });\n";
                }
            } else {
                result += "    " + bin_write_expr(t, "obj." + n) + ";\n";
            }
        }
    }

    result += "}";

    return result;
}

// ============================================================
// Data preparation
// ============================================================

// Collect all loader header names for cross-file includes
let all_loader_headers = [];
for f in schema.files {
    if f.path == () || f.path == "" { continue; }
    let parts = f.path.split("/");
    let fname = parts[parts.len - 1];
    let bn = fname + "";
    bn.replace(".poly", "");
    all_loader_headers.push(bn + "_loaders.hpp");
}

// Guard: per_file template needs file.path
let has_file = file.path != () && file.path != "";

// Extract base_name and output_filename
let base_name = "";
let output_filename = "";
if has_file {
    let parts = file.path.split("/");
    let filename = parts[parts.len - 1];
    base_name = filename + "";
    base_name.replace(".poly", "");
    output_filename = base_name + "_loaders.hpp";
}

// Collect other_includes (cross-file headers excluding self)
let other_includes = [];
if has_file {
    for other_header in all_loader_headers {
        if other_header != output_filename {
            other_includes.push(other_header);
        }
    }
}

// Collect all structs from all namespaces in this file
let all_structs = [];
if has_file {
    for ns in file.namespaces {
        for item in ns.items {
            if item.is_struct() {
                let s = item.as_struct();
                all_structs.push(#{ struct_def: s, namespace_name: ns.name });
                for si in s.items {
                    if si.is_embedded_struct() {
                        let es = si.as_embedded_struct();
                        all_structs.push(#{ struct_def: es, namespace_name: ns.name });
                        for esi in es.items {
                            if esi.is_embedded_struct() {
                                let nes = esi.as_embedded_struct();
                                all_structs.push(#{ struct_def: nes, namespace_name: ns.name });
                            }
                        }
                    }
                }
            } else if item.is_namespace() {
                let child_ns = item.as_namespace();
                for child_item in child_ns.items {
                    if child_item.is_struct() {
                        let cs = child_item.as_struct();
                        all_structs.push(#{ struct_def: cs, namespace_name: child_ns.name });
                        for csi in cs.items {
                            if csi.is_embedded_struct() {
                                let ces = csi.as_embedded_struct();
                                all_structs.push(#{ struct_def: ces, namespace_name: child_ns.name });
                            }
                        }
                    }
                }
            }
        }
    }
}

let has_structs = all_structs.len() > 0;

// Pre-compute per-entry: full_type, read_fwd, write_fwd, read_body, write_body
let idx = 0;
for entry in all_structs {
    let s = entry.struct_def;
    let ns = entry.namespace_name;
    let full_type = get_full_cpp_type(ns, s.name);

    all_structs[idx].full_type = full_type;
    all_structs[idx].struct_name = s.name;
    all_structs[idx].read_fwd = "inline " + full_type + " read_" + s.name + "(polygen::BinaryReader& reader);";
    all_structs[idx].write_fwd = "inline void write_" + s.name + "(polygen::BinaryWriter& writer, const " + full_type + "& obj);";
    all_structs[idx].read_body = generate_binary_read(s, ns);
    all_structs[idx].write_body = generate_binary_write(s, ns);

    idx += 1;
}
%endlogic
%if has_file && has_structs
// Auto-generated by PolyGen - DO NOT EDIT
// Loaders for binary serialization
#pragma once
%blank
#include "{{base_name}}.hpp"
#include "polygen_support.hpp"
%for hdr in other_includes
#include "{{hdr}}"
%endfor
%blank
namespace polygen_loaders {
%blank
// ============================================================================
// Binary Readers
// ============================================================================
%blank
%for entry in all_structs
{{entry.read_fwd}}
%endfor
%blank
%for entry in all_structs
{{entry.read_body}}
%blank
%endfor
// ============================================================================
// Binary Writers
// ============================================================================
%blank
%for entry in all_structs
{{entry.write_fwd}}
%endfor
%blank
%for entry in all_structs
{{entry.write_body}}
%blank
%endfor
} // namespace polygen_loaders
%endif
