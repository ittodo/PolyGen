// Go Container file generator
// Generates Container module with DataTables, indexes, and validation

import "templates/go/rhai_utils/type_mapping" as go_types;

for file in schema.files {
    if file.path == () || file.path == "" {
        continue;
    }

    let parts = file.path.split("/");
    let filename = parts[parts.len - 1];
    let output_filename = filename;
    output_filename.replace(".poly", "_container.go");
    let final_path = output_dir + "/go/" + output_filename;

    // Get schema/package name: "game_schema.poly" -> "gameschema"
    let schema_name = filename;
    schema_name.replace(".poly", "");
    let package_name = to_lower(schema_name);

    // Collect all tables inline (Rhai passes arrays by value)
    let all_tables = [];
    for ns in file.namespaces {
        for item in ns.items {
            if item.is_struct() {
                let s = item.as_struct();
                if !s.name.ends_with("__Enum") {
                    all_tables.push(#{
                        name: s.name,
                        table_name: s.name + "Table",
                        field_name: to_pascal_case(s.name) + "s",
                        def: s
                    });
                }
            } else if item.is_namespace() {
                let child = item.as_namespace();
                for child_item in child.items {
                    if child_item.is_struct() {
                        let cs = child_item.as_struct();
                        if !cs.name.ends_with("__Enum") {
                            all_tables.push(#{
                                name: cs.name,
                                table_name: cs.name + "Table",
                                field_name: to_pascal_case(cs.name) + "s",
                                def: cs
                            });
                        }
                    }
                }
            }
        }
    }

    // Get container name
    let container_name = to_pascal_case(schema_name) + "Container";

    let c = "";
    c += "// Code generated by PolyGen. DO NOT EDIT.\n";
    c += "// Source: " + file.path + "\n\n";
    c += "package " + package_name + "\n\n";
    c += "import (\n";
    c += "\t\"fmt\"\n";
    c += "\t. \"polygen\"\n";
    c += ")\n\n";

    // Generate DataTable for each struct
    for table in all_tables {
        let struct_def = table.def;
        let table_type = table.table_name;

        c += "// " + table_type + " is a data table for " + table.name + ".\n";
        c += "type " + table_type + " struct {\n";
        c += "\trows []*" + table.name + "\n";

        // Generate index fields
        for idx in struct_def.indexes {
            let idx_field = "by" + to_pascal_case(idx.field_name);
            let key_type = go_types::map_type(idx.field_type);

            if idx.is_unique {
                c += "\t" + idx_field + " *UniqueIndex[" + key_type + ", *" + table.name + "]\n";
            } else {
                c += "\t" + idx_field + " *GroupIndex[" + key_type + ", *" + table.name + "]\n";
            }
        }

        c += "}\n\n";

        // Constructor
        c += "// New" + table_type + " creates a new " + table_type + ".\n";
        c += "func New" + table_type + "() *" + table_type + " {\n";
        c += "\treturn &" + table_type + "{\n";
        c += "\t\trows: make([]*" + table.name + ", 0),\n";
        for idx in struct_def.indexes {
            let idx_field = "by" + to_pascal_case(idx.field_name);
            let key_type = go_types::map_type(idx.field_type);
            if idx.is_unique {
                c += "\t\t" + idx_field + ": NewUniqueIndex[" + key_type + ", *" + table.name + "](),\n";
            } else {
                c += "\t\t" + idx_field + ": NewGroupIndex[" + key_type + ", *" + table.name + "](),\n";
            }
        }
        c += "\t}\n";
        c += "}\n\n";

        // All method
        c += "// All returns all rows.\n";
        c += "func (t *" + table_type + ") All() []*" + table.name + " { return t.rows }\n\n";

        // Count method
        c += "// Count returns the number of rows.\n";
        c += "func (t *" + table_type + ") Count() int { return len(t.rows) }\n\n";

        // Generate index getter methods
        for idx in struct_def.indexes {
            let method_name = "GetBy" + to_pascal_case(idx.field_name);
            let idx_field = "by" + to_pascal_case(idx.field_name);
            let key_type = go_types::map_type(idx.field_type);

            if idx.is_unique {
                c += "// " + method_name + " gets a row by " + idx.field_name + " (unique).\n";
                c += "func (t *" + table_type + ") " + method_name + "(key " + key_type + ") *" + table.name + " {\n";
                c += "\tval, _ := t." + idx_field + ".Get(key)\n";
                c += "\treturn val\n";
                c += "}\n\n";
            } else {
                c += "// " + method_name + " gets rows by " + idx.field_name + " (group).\n";
                c += "func (t *" + table_type + ") " + method_name + "(key " + key_type + ") []*" + table.name + " {\n";
                c += "\treturn t." + idx_field + ".Get(key)\n";
                c += "}\n\n";
            }
        }

        // AddRow method
        c += "// AddRow adds a row to the table.\n";
        c += "func (t *" + table_type + ") AddRow(row *" + table.name + ") {\n";

        for idx in struct_def.indexes {
            let idx_field = "by" + to_pascal_case(idx.field_name);
            let field_name = to_pascal_case(idx.field_name);

            if idx.is_unique {
                c += "\tt." + idx_field + ".Insert(row." + field_name + ", row)\n";
            } else {
                c += "\tt." + idx_field + ".Add(row." + field_name + ", row)\n";
            }
        }

        c += "\tt.rows = append(t.rows, row)\n";
        c += "}\n\n";

        // LoadAll method
        c += "// LoadAll loads multiple rows into the table.\n";
        c += "func (t *" + table_type + ") LoadAll(rows []*" + table.name + ") {\n";
        c += "\tfor _, row := range rows { t.AddRow(row) }\n";
        c += "}\n\n";

        // Clear method
        c += "// Clear removes all rows from the table.\n";
        c += "func (t *" + table_type + ") Clear() {\n";
        c += "\tt.rows = make([]*" + table.name + ", 0)\n";
        for idx in struct_def.indexes {
            let idx_field = "by" + to_pascal_case(idx.field_name);
            c += "\tt." + idx_field + ".Clear()\n";
        }
        c += "}\n\n";

        // Generate Validate method
        c += "// Validate validates all rows against field constraints.\n";
        c += "func (t *" + table_type + ") Validate() *ValidationResult {\n";
        c += "\tresult := NewValidationResult()\n";

        // Find primary key field for error messages
        let pk_field = "Id";
        for idx in struct_def.indexes {
            if idx.name == "ById" || idx.field_name == "id" {
                pk_field = to_pascal_case(idx.field_name);
                break;
            }
        }

        c += "\tfor _, row := range t.rows {\n";
        c += "\t\trowKey := fmt.Sprintf(\"%v\", row." + pk_field + ")\n";

        // Generate validation for each field
        for item in struct_def.items {
            if item.is_field() {
                let field = item.as_field();
                let field_name = to_pascal_case(field.name);
                let is_option = field.field_type.is_option;
                let type_name = field.field_type.type_name;

                // MaxLength validation
                if field.max_length != () {
                    let max_len = field.max_length;
                    if is_option {
                        c += "\t\tif row." + field_name + " != nil && len(*row." + field_name + ") > " + max_len + " {\n";
                        c += "\t\t\tresult.AddError(MaxLengthError(\"" + table.name + "\", \"" + field_name + "\", rowKey, " + max_len + ", len(*row." + field_name + ")))\n";
                        c += "\t\t}\n";
                    } else if type_name == "string" {
                        c += "\t\tif len(row." + field_name + ") > " + max_len + " {\n";
                        c += "\t\t\tresult.AddError(MaxLengthError(\"" + table.name + "\", \"" + field_name + "\", rowKey, " + max_len + ", len(row." + field_name + ")))\n";
                        c += "\t\t}\n";
                    }
                }

                // Range validation
                if field.range != () {
                    let min_val = field.range.min;
                    let max_val = field.range.max;
                    let go_type = go_types::map_type(field.field_type);

                    // Determine which validation function to use based on type
                    let validate_fn = "ValidateRangeInt";
                    if type_name == "f32" || type_name == "f64" {
                        validate_fn = "ValidateRangeFloat";
                    } else if type_name.starts_with("u") {
                        validate_fn = "ValidateRangeUint";
                    }

                    if is_option {
                        c += "\t\tif row." + field_name + " != nil && !" + validate_fn + "(*row." + field_name + ", " + min_val + ", " + max_val + ") {\n";
                        c += "\t\t\tresult.AddError(RangeError(\"" + table.name + "\", \"" + field_name + "\", rowKey, " + min_val + ", " + max_val + ", *row." + field_name + "))\n";
                        c += "\t\t}\n";
                    } else {
                        c += "\t\tif !" + validate_fn + "(row." + field_name + ", " + min_val + ", " + max_val + ") {\n";
                        c += "\t\t\tresult.AddError(RangeError(\"" + table.name + "\", \"" + field_name + "\", rowKey, " + min_val + ", " + max_val + ", row." + field_name + "))\n";
                        c += "\t\t}\n";
                    }
                }

                // Regex validation
                if field.regex_pattern != () {
                    let pattern = field.regex_pattern;
                    if is_option {
                        c += "\t\tif row." + field_name + " != nil && !ValidateRegex(*row." + field_name + ", `" + pattern + "`) {\n";
                        c += "\t\t\tresult.AddError(RegexError(\"" + table.name + "\", \"" + field_name + "\", rowKey, `" + pattern + "`, *row." + field_name + "))\n";
                        c += "\t\t}\n";
                    } else if type_name == "string" {
                        c += "\t\tif !ValidateRegex(row." + field_name + ", `" + pattern + "`) {\n";
                        c += "\t\t\tresult.AddError(RegexError(\"" + table.name + "\", \"" + field_name + "\", rowKey, `" + pattern + "`, row." + field_name + "))\n";
                        c += "\t\t}\n";
                    }
                }
            }
        }

        c += "\t}\n";
        c += "\treturn result\n";
        c += "}\n\n";
    }

    // Generate root Container struct
    c += "// " + container_name + " is the root container aggregating all data tables.\n";
    c += "type " + container_name + " struct {\n";

    for table in all_tables {
        c += "\t" + table.field_name + " *" + table.table_name + "\n";
    }

    c += "}\n\n";

    // Constructor
    c += "// New" + container_name + " creates a new " + container_name + ".\n";
    c += "func New" + container_name + "() *" + container_name + " {\n";
    c += "\treturn &" + container_name + "{\n";
    for table in all_tables {
        c += "\t\t" + table.field_name + ": New" + table.table_name + "(),\n";
    }
    c += "\t}\n";
    c += "}\n\n";

    // Clear method
    c += "// Clear clears all tables.\n";
    c += "func (c *" + container_name + ") Clear() {\n";
    for table in all_tables {
        c += "\tc." + table.field_name + ".Clear()\n";
    }
    c += "}\n\n";

    // ValidateAll method
    c += "// ValidateAll validates all tables and returns combined results.\n";
    c += "func (c *" + container_name + ") ValidateAll() *ValidationResult {\n";
    c += "\tresult := NewValidationResult()\n";
    for table in all_tables {
        c += "\tresult.Merge(c." + table.field_name + ".Validate())\n";
    }
    c += "\treturn result\n";
    c += "}\n\n";

    // ValidateOrPanic method
    c += "// ValidateOrPanic validates all tables and panics if any validation fails.\n";
    c += "func (c *" + container_name + ") ValidateOrPanic() {\n";
    c += "\tresult := c.ValidateAll()\n";
    c += "\tif !result.IsValid() {\n";
    c += "\t\tpanic(NewValidationException(result))\n";
    c += "\t}\n";
    c += "}\n\n";

    // ValidateOrError method
    c += "// ValidateOrError validates all tables and returns an error if any validation fails.\n";
    c += "func (c *" + container_name + ") ValidateOrError() error {\n";
    c += "\tresult := c.ValidateAll()\n";
    c += "\tif !result.IsValid() {\n";
    c += "\t\treturn NewValidationException(result)\n";
    c += "\t}\n";
    c += "\treturn nil\n";
    c += "}\n";

    print("Generating file: " + final_path);
    write_file(final_path, c);
}

""
