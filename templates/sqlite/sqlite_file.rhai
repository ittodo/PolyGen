// SQLite Generator Entry Point
// Generates a combined schema file at output/sqlite/schema.sql
//
// Datasource filtering:
// - If struct has @datasource("sqlite") or no datasource: include
// - If struct has @datasource("other"): skip
// - Namespace datasource is inherited by structs

import "templates/sqlite/rhai_utils/type_mapping" as types;

// Helper function to join array elements
fn join_with(arr, sep) {
    let result = "";
    let i = 0;
    for item in arr {
        if i > 0 { result += sep; }
        result += item;
        i += 1;
    }
    result
}

// Check if a struct should be included for SQLite generation
// Returns true if datasource is "sqlite" or not specified
fn should_include_for_sqlite(struct_datasource, ns_datasource) {
    // Struct-level datasource takes precedence
    if struct_datasource != () && struct_datasource != "" {
        return struct_datasource == "sqlite";
    }
    // Fall back to namespace datasource
    if ns_datasource != () && ns_datasource != "" {
        return ns_datasource == "sqlite";
    }
    // No datasource specified - include by default
    return true;
}

let final_sql = "-- ============================================\n";
final_sql += "-- Generated by PolyGen (SQLite)\n";
final_sql += "-- ============================================\n\n";
final_sql += "PRAGMA foreign_keys = ON;\n\n";

// Collect all tables and their foreign keys for ordering
let all_tables = [];
let all_indexes = [];

for file in schema.files {
    if file.path == () || file.path == "" { continue; }

    for ns in file.namespaces {
        // Build ns_prefix by splitting on "." and joining with "_"
        let parts = ns.name.split(".");
        let ns_prefix = if ns.name != "" {
            join_with(parts, "_") + "_"
        } else {
            ""
        };

        // Get namespace datasource for inheritance
        let ns_datasource = ns.datasource;

        for item in ns.items {
            if item.is_struct() {
                let s = item.as_struct();

                // Check datasource filter
                if !should_include_for_sqlite(s.datasource, ns_datasource) {
                    continue;
                }
                let table_name = ns_prefix + s.name;

                // Generate CREATE TABLE
                let ddl = "CREATE TABLE IF NOT EXISTS " + table_name + " (\n";
                let columns = [];
                let pk_cols = [];
                let fk_statements = [];
                let unique_cols = [];

                for field_item in s.items {
                    if field_item.is_field() {
                        let f = field_item.as_field();
                        let col_name = f.name;

                        // Skip array types (separate table needed)
                        if types::is_array(f.field_type) {
                            continue;
                        }

                        // Get SQLite type
                        let sql_type = types::base_sqlite_type(f.field_type);
                        let is_null = types::is_nullable(f.field_type);

                        // Check constraints
                        let is_pk = false;
                        let is_unique = false;
                        let default_val = ();
                        let fk_ref = ();

                        for attr in f.attributes {
                            if attr == "Key" || attr == "PrimaryKey" {
                                is_pk = true;
                                pk_cols.push(col_name);
                            }
                            if attr.contains("IsUnique") && attr.contains("true") {
                                is_unique = true;
                                unique_cols.push(col_name);
                            }
                            if attr.starts_with("Default(") && attr.ends_with(")") {
                                let start = "Default(".len();
                                default_val = attr.sub_string(start, attr.len() - start - 1);
                            }
                            if attr.starts_with("ForeignKey(") && attr.ends_with(")") {
                                let start = "ForeignKey(".len();
                                fk_ref = attr.sub_string(start, attr.len() - start - 1);
                            }
                        }

                        // Build column definition
                        let col_def = "    " + col_name + " " + sql_type;

                        // For INTEGER PRIMARY KEY, SQLite auto-increments
                        if is_pk && pk_cols.len() == 1 && sql_type == "INTEGER" {
                            col_def += " PRIMARY KEY";
                        }

                        if !is_null && !is_pk {
                            col_def += " NOT NULL";
                        }

                        if default_val != () {
                            if sql_type == "TEXT" {
                                col_def += " DEFAULT '" + default_val + "'";
                            } else {
                                col_def += " DEFAULT " + default_val;
                            }
                        }

                        columns.push(col_def);

                        // Collect foreign key for later
                        if fk_ref != () {
                            let parts = fk_ref.split(".");
                            if parts.len() >= 2 {
                                let ref_table = parts[0];
                                let ref_col = parts[1];
                                fk_statements.push("    FOREIGN KEY (" + col_name + ") REFERENCES " + ref_table + "(" + ref_col + ")");
                            }
                        }
                    }
                }

                // Join columns
                ddl += join_with(columns, ",\n");

                // Add composite primary key if needed
                if pk_cols.len() > 1 {
                    ddl += ",\n    PRIMARY KEY (" + join_with(pk_cols, ", ") + ")";
                }

                // Add unique constraints
                for u in unique_cols {
                    ddl += ",\n    UNIQUE (" + u + ")";
                }

                // Add foreign keys
                for fk in fk_statements {
                    ddl += ",\n" + fk;
                }

                ddl += "\n);\n";
                all_tables.push(ddl);

                // Generate indexes from @index annotations
                if s.indexes != () {
                    for idx in s.indexes {
                        let idx_name = "idx_" + table_name.to_lower() + "_" + idx.name.to_lower();
                        let unique_kw = if idx.is_unique { "UNIQUE " } else { "" };

                        let field_names = [];
                        for field in idx.fields {
                            field_names.push(field.name);
                        }

                        let idx_sql = "CREATE " + unique_kw + "INDEX IF NOT EXISTS " + idx_name;
                        idx_sql += " ON " + table_name + " (" + join_with(field_names, ", ") + ");\n";
                        all_indexes.push(idx_sql);
                    }
                }
            }

            // Handle enums as lookup tables (optional)
            // Note: Enums don't have individual datasource, use namespace datasource
            if item.is_enum() {
                // Skip if namespace has non-sqlite datasource
                if ns_datasource != () && ns_datasource != "" && ns_datasource != "sqlite" {
                    continue;
                }

                let e = item.as_enum();
                let table_name = ns_prefix + e.name;

                let ddl = "-- Enum: " + e.name + "\n";
                ddl += "CREATE TABLE IF NOT EXISTS " + table_name + " (\n";
                ddl += "    id INTEGER PRIMARY KEY,\n";
                ddl += "    name TEXT NOT NULL UNIQUE\n";
                ddl += ");\n\n";

                // Insert enum values
                let auto_val = 0;
                for enum_item in e.items {
                    if enum_item.is_member() {
                        let m = enum_item.as_member();
                        let val = if m.value != () { m.value } else { auto_val };
                        ddl += "INSERT OR IGNORE INTO " + table_name + " (id, name) VALUES (";
                        ddl += val + ", '" + m.name + "');\n";
                        auto_val += 1;
                    }
                }
                ddl += "\n";
                all_tables.push(ddl);
            }
        }
    }
}

// Output tables
final_sql += "-- ============================================\n";
final_sql += "-- Tables\n";
final_sql += "-- ============================================\n\n";
for tbl in all_tables {
    final_sql += tbl + "\n";
}

// Output indexes
if all_indexes.len() > 0 {
    final_sql += "-- ============================================\n";
    final_sql += "-- Indexes\n";
    final_sql += "-- ============================================\n\n";
    for idx in all_indexes {
        final_sql += idx;
    }
}

let out_path = "output/sqlite/schema.sql";
print("Generating file: " + out_path);
write_file(out_path, final_sql);

""
