%logic
// Rust Container file generator (PolyTemplate)
// Generates Container module with DataTables, indexes, and relations

import "templates/rust/rhai_utils/type_mapping" as rust_types;

fn join_with(arr, sep) {
    let result = "";
    let i = 0;
    for item in arr {
        if i > 0 { result += sep; }
        result += item;
        i += 1;
    }
    result
}

fn find_pk_field(struct_def) {
    // Find primary key field: check is_primary_key first, then fallback to first unique index
    for item in struct_def.items {
        if item.is_field() {
            let f = item.as_field();
            if f.is_primary_key {
                return to_snake_case(f.name);
            }
        }
    }
    for idx in struct_def.indexes {
        if idx.is_unique {
            return to_snake_case(idx.field_name);
        }
    }
    return "";
}

let skip_file = file.path == () || file.path == "";

let schema_mod = "";
let container_name = "";
let all_tables = [];
let structs_with_relations = [];
let has_relations = false;
let relations_body = "";

if !skip_file {
    let parts = file.path.split("/");
    let filename = parts[parts.len - 1];

    schema_mod = filename;
    schema_mod.replace(".poly", "");

    let last_part = filename;
    last_part.replace(".poly", "");
    container_name = to_pascal_case(last_part) + "Container";

    // Collect all tables
    for ns in file.namespaces {
        let ns_mod_path = ns.name;
        ns_mod_path.replace(".", "_");

        for item in ns.items {
            if item.is_struct() {
                let s = item.as_struct();
                if !s.name.ends_with("__Enum") {
                    all_tables.push(#{
                        name: s.name,
                        path: "crate::" + schema_mod + "::" + ns_mod_path + "::" + s.name,
                        table_name: to_snake_case(s.name) + "s",
                        def: s
                    });
                }
            } else if item.is_namespace() {
                let child = item.as_namespace();
                let child_name = child.name;
                child_name.replace(".", "_");
                let child_mod_path = ns_mod_path + "::" + child_name;
                for child_item in child.items {
                    if child_item.is_struct() {
                        let cs = child_item.as_struct();
                        if !cs.name.ends_with("__Enum") {
                            all_tables.push(#{
                                name: cs.name,
                                path: "crate::" + schema_mod + "::" + child_mod_path + "::" + cs.name,
                                table_name: to_snake_case(cs.name) + "s",
                                def: cs
                            });
                        }
                    }
                }
            }
        }
    }

    // Pre-compute per-table bodies (must use index to mutate)
    let tidx = 0;
    for table in all_tables {
        let struct_def = table.def;
        let table_type = table.name + "Table";
        let pk_field = find_pk_field(struct_def);

        // Index struct fields
        let idx_field_lines = [];
        for idx in struct_def.indexes {
            let idx_field = "by_" + to_snake_case(idx.field_name);
            let key_type = rust_types::map_type(idx.field_type);
            if idx.is_unique {
                idx_field_lines.push("        " + idx_field + ": UniqueIndex<" + key_type + ", usize>,");
            } else {
                idx_field_lines.push("        " + idx_field + ": GroupIndex<" + key_type + ">,");
            }
        }
        all_tables[tidx].idx_fields_body = join_with(idx_field_lines, "\n");

        // Getter methods
        let getter_lines = [];
        for idx in struct_def.indexes {
            let method_name = "get_" + to_snake_case(idx.name);
            let idx_field = "by_" + to_snake_case(idx.field_name);
            let key_type = rust_types::map_type(idx.field_type);

            if idx.is_unique {
                getter_lines.push("        /// Get by " + idx.field_name + " (unique)");
                getter_lines.push("        pub fn " + method_name + "(&self, key: " + key_type + ") -> Option<&" + table.path + "> {");
                getter_lines.push("            self." + idx_field + ".get(&key).map(|&idx| &self.rows[idx])");
                getter_lines.push("        }");
                getter_lines.push("");
            } else {
                getter_lines.push("        /// Get by " + idx.field_name + " (group)");
                getter_lines.push("        pub fn " + method_name + "(&self, key: " + key_type + ") -> Vec<&" + table.path + "> {");
                getter_lines.push("            self." + idx_field + ".get(&key).iter().map(|&idx| &self.rows[idx]).collect()");
                getter_lines.push("        }");
                getter_lines.push("");
            }
        }
        all_tables[tidx].getter_body = join_with(getter_lines, "\n");

        // add_row index lines
        let add_row_lines = [];
        for idx in struct_def.indexes {
            let idx_field = "by_" + to_snake_case(idx.field_name);
            let field_name = to_snake_case(idx.field_name);
            let key_expr = "row." + field_name;
            if idx.field_type.type_name == "string" {
                key_expr = "row." + field_name + ".clone()";
            }
            if idx.is_unique {
                add_row_lines.push("            self." + idx_field + ".insert(" + key_expr + ", idx);");
            } else {
                add_row_lines.push("            self." + idx_field + ".add(" + key_expr + ", idx);");
            }
        }
        all_tables[tidx].add_row_body = join_with(add_row_lines, "\n");

        // clear index lines
        let clear_lines = [];
        for idx in struct_def.indexes {
            let idx_field = "by_" + to_snake_case(idx.field_name);
            clear_lines.push("            self." + idx_field + ".clear();");
        }
        all_tables[tidx].clear_body = join_with(clear_lines, "\n");

        // validate body
        let validate_lines = [];
        if pk_field != "" {
            validate_lines.push("            for row in &self.rows {");
            validate_lines.push("                let row_key = row." + pk_field + ".to_string();");
        } else {
            validate_lines.push("            for (row_idx, row) in self.rows.iter().enumerate() {");
            validate_lines.push("                let row_key = row_idx.to_string();");
        }

        for item in struct_def.items {
            if item.is_field() {
                let field = item.as_field();
                let field_name = to_snake_case(field.name);
                let is_option = field.field_type.is_option;
                let type_name = field.field_type.type_name;

                if field.max_length != () {
                    let max_len = field.max_length;
                    if is_option {
                        validate_lines.push("                if let Some(ref v) = row." + field_name + " {");
                        validate_lines.push("                    if v.len() > " + max_len + " {");
                        validate_lines.push("                        result.add_error(validation::max_length_error(");
                        validate_lines.push("                            \"" + table.name + "\", \"" + field_name + "\", &row_key, " + max_len + ", v.len()));");
                        validate_lines.push("                    }");
                        validate_lines.push("                }");
                    } else if type_name == "string" {
                        validate_lines.push("                if row." + field_name + ".len() > " + max_len + " {");
                        validate_lines.push("                    result.add_error(validation::max_length_error(");
                        validate_lines.push("                        \"" + table.name + "\", \"" + field_name + "\", &row_key, " + max_len + ", row." + field_name + ".len()));");
                        validate_lines.push("                }");
                    }
                }

                if field.range != () {
                    let min_val = field.range.min;
                    let max_val = field.range.max;
                    if is_option {
                        validate_lines.push("                if let Some(v) = row." + field_name + " {");
                        validate_lines.push("                    if !validation::validate_range(v, " + min_val + ", " + max_val + ") {");
                        validate_lines.push("                        result.add_error(validation::range_error(");
                        validate_lines.push("                            \"" + table.name + "\", \"" + field_name + "\", &row_key, " + min_val + ", " + max_val + ", v));");
                        validate_lines.push("                    }");
                        validate_lines.push("                }");
                    } else {
                        validate_lines.push("                if !validation::validate_range(row." + field_name + ", " + min_val + ", " + max_val + ") {");
                        validate_lines.push("                    result.add_error(validation::range_error(");
                        validate_lines.push("                        \"" + table.name + "\", \"" + field_name + "\", &row_key, " + min_val + ", " + max_val + ", row." + field_name + "));");
                        validate_lines.push("                }");
                    }
                }

                if field.regex_pattern != () {
                    let pattern = field.regex_pattern;
                    if is_option {
                        validate_lines.push("                if let Some(ref v) = row." + field_name + " {");
                        validate_lines.push("                    if !validation::validate_regex(v, r\"" + pattern + "\") {");
                        validate_lines.push("                        result.add_error(validation::regex_error(");
                        validate_lines.push("                            \"" + table.name + "\", \"" + field_name + "\", &row_key, r\"" + pattern + "\", v));");
                        validate_lines.push("                    }");
                        validate_lines.push("                }");
                    } else if type_name == "string" {
                        validate_lines.push("                if !validation::validate_regex(&row." + field_name + ", r\"" + pattern + "\") {");
                        validate_lines.push("                    result.add_error(validation::regex_error(");
                        validate_lines.push("                        \"" + table.name + "\", \"" + field_name + "\", &row_key, r\"" + pattern + "\", &row." + field_name + "));");
                        validate_lines.push("                }");
                    }
                }
            }
        }

        validate_lines.push("            }");
        validate_lines.push("            result");
        all_tables[tidx].validate_body = join_with(validate_lines, "\n");

        // validate_foreign_keys body
        let fk_lines = [];
        let has_fk = false;
        for item in struct_def.items {
            if item.is_field() {
                let field = item.as_field();
                if field.foreign_key != () {
                    has_fk = true;
                }
            }
        }
        all_tables[tidx].has_fk = has_fk;

        if !has_fk {
            fk_lines.push("            let _ = container; // Suppress unused variable warning");
        } else {
            if pk_field != "" {
                fk_lines.push("            for row in &self.rows {");
                fk_lines.push("                let row_key = row." + pk_field + ".to_string();");
            } else {
                fk_lines.push("            for (row_idx, row) in self.rows.iter().enumerate() {");
                fk_lines.push("                let row_key = row_idx.to_string();");
            }

            for item in struct_def.items {
                if item.is_field() {
                    let field = item.as_field();
                    if field.foreign_key != () {
                        let fk = field.foreign_key;
                        let field_name = to_snake_case(field.name);
                        let target_parts = fk.target_table_fqn.split(".");
                        let target_table = "";
                        for part in target_parts {
                            target_table = part;
                        }
                        let target_member = to_snake_case(target_table) + "s";
                        let target_getter = "get_by_" + to_snake_case(fk.target_field);

                        if field.field_type.is_option {
                            fk_lines.push("                if let Some(fk_value) = row." + field_name + " {");
                            fk_lines.push("                    if container." + target_member + "." + target_getter + "(fk_value).is_none() {");
                            fk_lines.push("                        result.add_error(validation::foreign_key_error(");
                            fk_lines.push("                            \"" + table.name + "\", \"" + field_name + "\", &row_key,");
                            fk_lines.push("                            \"" + target_table + "\", &fk_value.to_string()));");
                            fk_lines.push("                    }");
                            fk_lines.push("                }");
                        } else {
                            fk_lines.push("                if container." + target_member + "." + target_getter + "(row." + field_name + ").is_none() {");
                            fk_lines.push("                    result.add_error(validation::foreign_key_error(");
                            fk_lines.push("                        \"" + table.name + "\", \"" + field_name + "\", &row_key,");
                            fk_lines.push("                        \"" + target_table + "\", &row." + field_name + ".to_string()));");
                            fk_lines.push("                }");
                        }
                    }
                }
            }
            fk_lines.push("            }");
        }
        fk_lines.push("            result");
        all_tables[tidx].fk_body = join_with(fk_lines, "\n");

        all_tables[tidx].table_type = table_type;
        all_tables[tidx].pk_field = pk_field;

        tidx += 1;
    }

    // Collect structs with relations
    for ns in file.namespaces {
        let ns_mod_path2 = ns.name;
        ns_mod_path2.replace(".", "_");

        for item in ns.items {
            if item.is_struct() {
                let s = item.as_struct();
                if s.relations.len() > 0 {
                    structs_with_relations.push(#{
                        name: s.name,
                        path: "crate::" + schema_mod + "::" + ns_mod_path2 + "::" + s.name,
                        def: s
                    });
                }
            } else if item.is_namespace() {
                let child = item.as_namespace();
                let child_name2 = child.name;
                child_name2.replace(".", "_");
                let child_mod_path2 = ns_mod_path2 + "::" + child_name2;
                for child_item in child.items {
                    if child_item.is_struct() {
                        let cs = child_item.as_struct();
                        if cs.relations.len() > 0 {
                            structs_with_relations.push(#{
                                name: cs.name,
                                path: "crate::" + schema_mod + "::" + child_mod_path2 + "::" + cs.name,
                                def: cs
                            });
                        }
                    }
                }
            }
        }
    }
    has_relations = structs_with_relations.len() > 0;

    // Pre-compute relations body
    if has_relations {
        let rel_lines = [];
        rel_lines.push("pub mod relations {");
        rel_lines.push("    //! Relation methods for navigating between tables");
        rel_lines.push("");
        rel_lines.push("    use super::container::" + container_name + ";");
        rel_lines.push("");

        for s in structs_with_relations {
            let struct_def = s.def;
            rel_lines.push("    /// Relation methods for " + s.name);
            rel_lines.push("    impl " + s.path + " {");

            for rel in struct_def.relations {
                let method_name = to_snake_case(rel.name);
                let source_table = to_snake_case(rel.source_table_name) + "s";
                let source_field = to_snake_case(rel.source_field);
                let rel_pk = find_pk_field(struct_def);
                if rel_pk == "" { rel_pk = "id"; }

                let fqn = rel.source_table_fqn;
                let type_suffix = "." + rel.source_table_name;
                let ns_fqn = fqn;
                if fqn.ends_with(type_suffix) {
                    ns_fqn = fqn.sub_string(0, fqn.len() - type_suffix.len());
                }
                let rel_ns_path = ns_fqn;
                rel_ns_path.replace(".", "_");

                rel_lines.push("        /// Get related " + rel.name);
                rel_lines.push("        pub fn " + method_name + "<'a>(&self, container: &'a " + container_name + ") -> Vec<&'a crate::" + schema_mod + "::" + rel_ns_path + "::" + rel.source_table_name + "> {");
                rel_lines.push("            container." + source_table + ".get_by_" + source_field + "(self." + rel_pk + ")");
                rel_lines.push("        }");
                rel_lines.push("");
            }
            rel_lines.push("    }");
            rel_lines.push("");
        }
        rel_lines.push("}");
        relations_body = join_with(rel_lines, "\n");
    }
}
%endlogic
%if !skip_file
//! Generated by PolyGen - Container Module
//! Source: {{file.path}}
%blank
pub mod container {
    //! Data Container with indexes and relations
%blank
    use std::collections::HashMap;
    use crate::polygen_support::{UniqueIndex, GroupIndex, LoadError, LoadResult};
    use crate::polygen_support::{ValidationResult, ValidationException, validation};
%blank
%for table in all_tables
    /// DataTable for {{table.name}}
    #[derive(Debug, Clone, Default)]
    pub struct {{table.table_type}} {
        rows: Vec<{{table.path}}>,
{{table.idx_fields_body}}
    }
%blank
    impl {{table.table_type}} {
        pub fn new() -> Self { Self::default() }
%blank
        pub fn all(&self) -> &[{{table.path}}] { &self.rows }
%blank
        pub fn count(&self) -> usize { self.rows.len() }
%blank
        pub fn iter(&self) -> impl Iterator<Item = &{{table.path}}> { self.rows.iter() }
%blank
{{table.getter_body}}
        pub fn add_row(&mut self, row: {{table.path}}) {
            let idx = self.rows.len();
{{table.add_row_body}}
            self.rows.push(row);
        }
%blank
        pub fn load_all(&mut self, rows: Vec<{{table.path}}>) {
            for row in rows { self.add_row(row); }
        }
%blank
        pub fn clear(&mut self) {
            self.rows.clear();
{{table.clear_body}}
        }
%blank
        /// Validates all rows against field constraints.
        pub fn validate(&self) -> ValidationResult {
            let mut result = ValidationResult::new();
{{table.validate_body}}
        }
%blank
        /// Validates foreign key references exist in related tables.
        pub fn validate_foreign_keys(&self, container: &{{container_name}}) -> ValidationResult {
            let mut result = ValidationResult::new();
{{table.fk_body}}
        }
    }
%blank
%endfor
    /// Root container aggregating all data tables
    #[derive(Debug, Clone, Default)]
    pub struct {{container_name}} {
%for table in all_tables
        pub {{table.table_name}}: {{table.table_type}},
%endfor
    }
%blank
    impl {{container_name}} {
        pub fn new() -> Self { Self::default() }
%blank
        pub fn clear(&mut self) {
%for table in all_tables
            self.{{table.table_name}}.clear();
%endfor
        }
%blank
        /// Validates all tables and returns combined results.
        pub fn validate_all(&self) -> ValidationResult {
            let mut result = ValidationResult::new();
            // Field constraint validation
%for table in all_tables
            result.merge(self.{{table.table_name}}.validate());
%endfor
            // Foreign key validation
%for table in all_tables
            result.merge(self.{{table.table_name}}.validate_foreign_keys(self));
%endfor
            result
        }
%blank
        /// Validates all tables and returns error if any validation fails.
        pub fn validate_or_throw(&self) -> Result<(), ValidationException> {
            let result = self.validate_all();
            if !result.is_valid() {
                return Err(ValidationException::new(result));
            }
            Ok(())
        }
    }
}
%if has_relations
%blank
{{relations_body}}
%endif
%endif
