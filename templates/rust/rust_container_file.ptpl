%logic
// Rust Container file generator (PolyTemplate)
// Generates Container module with DataTables, indexes, and relations

import "templates/rust/rhai_utils/type_mapping" as rust_types;

for file in schema.files {
    if file.path == () || file.path == "" {
        continue;
    }

    let parts = file.path.split("/");
    let filename = parts[parts.len - 1];
    let output_filename = filename;
    output_filename.replace(".poly", "_container.rs");
    let final_path = output_dir + "/rust/" + output_filename;

    let schema_mod = filename;
    schema_mod.replace(".poly", "");

    // Collect all tables inline
    let all_tables = [];
    for ns in file.namespaces {
        let ns_mod_path = ns.name;
        ns_mod_path.replace(".", "_");

        for item in ns.items {
            if item.is_struct() {
                let s = item.as_struct();
                if !s.name.ends_with("__Enum") {
                    all_tables.push(#{
                        name: s.name,
                        path: "crate::" + schema_mod + "::" + ns_mod_path + "::" + s.name,
                        table_name: to_snake_case(s.name) + "s",
                        def: s
                    });
                }
            } else if item.is_namespace() {
                let child = item.as_namespace();
                let child_name = child.name;
                child_name.replace(".", "_");
                let child_mod_path = ns_mod_path + "::" + child_name;
                for child_item in child.items {
                    if child_item.is_struct() {
                        let cs = child_item.as_struct();
                        if !cs.name.ends_with("__Enum") {
                            all_tables.push(#{
                                name: cs.name,
                                path: "crate::" + schema_mod + "::" + child_mod_path + "::" + cs.name,
                                table_name: to_snake_case(cs.name) + "s",
                                def: cs
                            });
                        }
                    }
                }
            }
        }
    }

    // Get container name
    let last_part = filename;
    last_part.replace(".poly", "");
    let container_name = to_pascal_case(last_part) + "Container";

    let c = "";
    c += "//! Generated by PolyGen - Container Module\n";
    c += "//! Source: " + file.path + "\n\n";

    // ===== Container Module =====
    c += "pub mod container {\n";
    c += "    //! Data Container with indexes and relations\n\n";
    c += "    use std::collections::HashMap;\n";
    c += "    use crate::polygen_support::{UniqueIndex, GroupIndex, LoadError, LoadResult};\n";
    c += "    use crate::polygen_support::{ValidationResult, ValidationException, validation};\n\n";

    // Generate DataTable for each struct
    for table in all_tables {
        let struct_def = table.def;
        let table_type = table.name + "Table";

        c += "    /// DataTable for " + table.name + "\n";
        c += "    #[derive(Debug, Clone, Default)]\n";
        c += "    pub struct " + table_type + " {\n";
        c += "        rows: Vec<" + table.path + ">,\n";

        for idx in struct_def.indexes {
            let idx_field = "by_" + to_snake_case(idx.field_name);
            let key_type = rust_types::map_type(idx.field_type);

            if idx.is_unique {
                c += "        " + idx_field + ": UniqueIndex<" + key_type + ", usize>,\n";
            } else {
                c += "        " + idx_field + ": GroupIndex<" + key_type + ">,\n";
            }
        }

        c += "    }\n\n";

        // Implement DataTable
        c += "    impl " + table_type + " {\n";
        c += "        pub fn new() -> Self { Self::default() }\n\n";
        c += "        pub fn all(&self) -> &[" + table.path + "] { &self.rows }\n\n";
        c += "        pub fn count(&self) -> usize { self.rows.len() }\n\n";
        c += "        pub fn iter(&self) -> impl Iterator<Item = &" + table.path + "> { self.rows.iter() }\n\n";

        // Generate index getter methods
        for idx in struct_def.indexes {
            let method_name = "get_" + to_snake_case(idx.name);
            let idx_field = "by_" + to_snake_case(idx.field_name);
            let key_type = rust_types::map_type(idx.field_type);

            if idx.is_unique {
                c += "        /// Get by " + idx.field_name + " (unique)\n";
                c += "        pub fn " + method_name + "(&self, key: " + key_type + ") -> Option<&" + table.path + "> {\n";
                c += "            self." + idx_field + ".get(&key).map(|&idx| &self.rows[idx])\n";
                c += "        }\n\n";
            } else {
                c += "        /// Get by " + idx.field_name + " (group)\n";
                c += "        pub fn " + method_name + "(&self, key: " + key_type + ") -> Vec<&" + table.path + "> {\n";
                c += "            self." + idx_field + ".get(&key).iter().map(|&idx| &self.rows[idx]).collect()\n";
                c += "        }\n\n";
            }
        }

        // add_row method
        c += "        pub fn add_row(&mut self, row: " + table.path + ") {\n";
        c += "            let idx = self.rows.len();\n";

        for idx in struct_def.indexes {
            let idx_field = "by_" + to_snake_case(idx.field_name);
            let field_name = to_snake_case(idx.field_name);
            let key_expr = "row." + field_name;

            if idx.field_type.type_name == "string" {
                key_expr = "row." + field_name + ".clone()";
            }

            if idx.is_unique {
                c += "            self." + idx_field + ".insert(" + key_expr + ", idx);\n";
            } else {
                c += "            self." + idx_field + ".add(" + key_expr + ", idx);\n";
            }
        }

        c += "            self.rows.push(row);\n";
        c += "        }\n\n";

        c += "        pub fn load_all(&mut self, rows: Vec<" + table.path + ">) {\n";
        c += "            for row in rows { self.add_row(row); }\n";
        c += "        }\n\n";

        c += "        pub fn clear(&mut self) {\n";
        c += "            self.rows.clear();\n";
        for idx in struct_def.indexes {
            let idx_field = "by_" + to_snake_case(idx.field_name);
            c += "            self." + idx_field + ".clear();\n";
        }
        c += "        }\n\n";

        // Generate validate method
        c += "        /// Validates all rows against field constraints.\n";
        c += "        pub fn validate(&self) -> ValidationResult {\n";
        c += "            let mut result = ValidationResult::new();\n";

        let pk_field = "id";
        for idx in struct_def.indexes {
            if idx.name == "ById" || idx.field_name == "id" {
                pk_field = to_snake_case(idx.field_name);
                break;
            }
        }

        c += "            for row in &self.rows {\n";
        c += "                let row_key = row." + pk_field + ".to_string();\n";

        for item in struct_def.items {
            if item.is_field() {
                let field = item.as_field();
                let field_name = to_snake_case(field.name);
                let is_option = field.field_type.is_option;
                let type_name = field.field_type.type_name;

                // MaxLength validation
                if field.max_length != () {
                    let max_len = field.max_length;
                    if is_option {
                        c += "                if let Some(ref v) = row." + field_name + " {\n";
                        c += "                    if v.len() > " + max_len + " {\n";
                        c += "                        result.add_error(validation::max_length_error(\n";
                        c += "                            \"" + table.name + "\", \"" + field_name + "\", &row_key, " + max_len + ", v.len()));\n";
                        c += "                    }\n";
                        c += "                }\n";
                    } else if type_name == "string" {
                        c += "                if row." + field_name + ".len() > " + max_len + " {\n";
                        c += "                    result.add_error(validation::max_length_error(\n";
                        c += "                        \"" + table.name + "\", \"" + field_name + "\", &row_key, " + max_len + ", row." + field_name + ".len()));\n";
                        c += "                }\n";
                    }
                }

                // Range validation
                if field.range != () {
                    let min_val = field.range.min;
                    let max_val = field.range.max;
                    if is_option {
                        c += "                if let Some(v) = row." + field_name + " {\n";
                        c += "                    if !validation::validate_range(v, " + min_val + ", " + max_val + ") {\n";
                        c += "                        result.add_error(validation::range_error(\n";
                        c += "                            \"" + table.name + "\", \"" + field_name + "\", &row_key, " + min_val + ", " + max_val + ", v));\n";
                        c += "                    }\n";
                        c += "                }\n";
                    } else {
                        c += "                if !validation::validate_range(row." + field_name + ", " + min_val + ", " + max_val + ") {\n";
                        c += "                    result.add_error(validation::range_error(\n";
                        c += "                        \"" + table.name + "\", \"" + field_name + "\", &row_key, " + min_val + ", " + max_val + ", row." + field_name + "));\n";
                        c += "                }\n";
                    }
                }

                // Regex validation
                if field.regex_pattern != () {
                    let pattern = field.regex_pattern;
                    if is_option {
                        c += "                if let Some(ref v) = row." + field_name + " {\n";
                        c += "                    if !validation::validate_regex(v, r\"" + pattern + "\") {\n";
                        c += "                        result.add_error(validation::regex_error(\n";
                        c += "                            \"" + table.name + "\", \"" + field_name + "\", &row_key, r\"" + pattern + "\", v));\n";
                        c += "                    }\n";
                        c += "                }\n";
                    } else if type_name == "string" {
                        c += "                if !validation::validate_regex(&row." + field_name + ", r\"" + pattern + "\") {\n";
                        c += "                    result.add_error(validation::regex_error(\n";
                        c += "                        \"" + table.name + "\", \"" + field_name + "\", &row_key, r\"" + pattern + "\", &row." + field_name + "));\n";
                        c += "                }\n";
                    }
                }
            }
        }

        c += "            }\n";
        c += "            result\n";
        c += "        }\n\n";

        // Generate validate_foreign_keys method
        c += "        /// Validates foreign key references exist in related tables.\n";
        c += "        pub fn validate_foreign_keys(&self, container: &" + container_name + ") -> ValidationResult {\n";
        c += "            let mut result = ValidationResult::new();\n";

        let has_fk = false;
        for item in struct_def.items {
            if item.is_field() {
                let field = item.as_field();
                if field.foreign_key != () {
                    has_fk = true;
                }
            }
        }

        if !has_fk {
            c += "            let _ = container; // Suppress unused variable warning\n";
        } else {
            c += "            for row in &self.rows {\n";
            c += "                let row_key = row." + pk_field + ".to_string();\n";

            for item in struct_def.items {
                if item.is_field() {
                    let field = item.as_field();
                    if field.foreign_key != () {
                        let fk = field.foreign_key;
                        let field_name = to_snake_case(field.name);
                        let target_parts = fk.target_table_fqn.split(".");
                        let target_table = "";
                        for part in target_parts {
                            target_table = part;
                        }
                        let target_member = to_snake_case(target_table) + "s";
                        let target_getter = "get_by_" + to_snake_case(fk.target_field);

                        if field.field_type.is_option {
                            c += "                if let Some(fk_value) = row." + field_name + " {\n";
                            c += "                    if container." + target_member + "." + target_getter + "(fk_value).is_none() {\n";
                            c += "                        result.add_error(validation::foreign_key_error(\n";
                            c += "                            \"" + table.name + "\", \"" + field_name + "\", &row_key,\n";
                            c += "                            \"" + target_table + "\", &fk_value.to_string()));\n";
                            c += "                    }\n";
                            c += "                }\n";
                        } else {
                            c += "                if container." + target_member + "." + target_getter + "(row." + field_name + ").is_none() {\n";
                            c += "                    result.add_error(validation::foreign_key_error(\n";
                            c += "                        \"" + table.name + "\", \"" + field_name + "\", &row_key,\n";
                            c += "                        \"" + target_table + "\", &row." + field_name + ".to_string()));\n";
                            c += "                }\n";
                        }
                    }
                }
            }

            c += "            }\n";
        }

        c += "            result\n";
        c += "        }\n";
        c += "    }\n\n";
    }

    // Generate root Container struct
    c += "    /// Root container aggregating all data tables\n";
    c += "    #[derive(Debug, Clone, Default)]\n";
    c += "    pub struct " + container_name + " {\n";

    for table in all_tables {
        c += "        pub " + table.table_name + ": " + table.name + "Table,\n";
    }

    c += "    }\n\n";

    c += "    impl " + container_name + " {\n";
    c += "        pub fn new() -> Self { Self::default() }\n\n";

    c += "        pub fn clear(&mut self) {\n";
    for table in all_tables {
        c += "            self." + table.table_name + ".clear();\n";
    }
    c += "        }\n\n";

    c += "        /// Validates all tables and returns combined results.\n";
    c += "        pub fn validate_all(&self) -> ValidationResult {\n";
    c += "            let mut result = ValidationResult::new();\n";
    c += "            // Field constraint validation\n";
    for table in all_tables {
        c += "            result.merge(self." + table.table_name + ".validate());\n";
    }
    c += "            // Foreign key validation\n";
    for table in all_tables {
        c += "            result.merge(self." + table.table_name + ".validate_foreign_keys(self));\n";
    }
    c += "            result\n";
    c += "        }\n\n";

    c += "        /// Validates all tables and returns error if any validation fails.\n";
    c += "        pub fn validate_or_throw(&self) -> Result<(), ValidationException> {\n";
    c += "            let result = self.validate_all();\n";
    c += "            if !result.is_valid() {\n";
    c += "                return Err(ValidationException::new(result));\n";
    c += "            }\n";
    c += "            Ok(())\n";
    c += "        }\n";
    c += "    }\n";
    c += "}\n";

    // ===== Relations Module =====
    let structs_with_relations = [];
    for ns in file.namespaces {
        let ns_mod_path2 = ns.name;
        ns_mod_path2.replace(".", "_");

        for item in ns.items {
            if item.is_struct() {
                let s = item.as_struct();
                if s.relations.len() > 0 {
                    structs_with_relations.push(#{
                        name: s.name,
                        path: "crate::" + schema_mod + "::" + ns_mod_path2 + "::" + s.name,
                        def: s
                    });
                }
            } else if item.is_namespace() {
                let child = item.as_namespace();
                let child_name2 = child.name;
                child_name2.replace(".", "_");
                let child_mod_path2 = ns_mod_path2 + "::" + child_name2;
                for child_item in child.items {
                    if child_item.is_struct() {
                        let cs = child_item.as_struct();
                        if cs.relations.len() > 0 {
                            structs_with_relations.push(#{
                                name: cs.name,
                                path: "crate::" + schema_mod + "::" + child_mod_path2 + "::" + cs.name,
                                def: cs
                            });
                        }
                    }
                }
            }
        }
    }

    if structs_with_relations.len() > 0 {
        c += "\npub mod relations {\n";
        c += "    //! Relation methods for navigating between tables\n\n";
        c += "    use super::container::" + container_name + ";\n\n";

        for s in structs_with_relations {
            let struct_def = s.def;

            c += "    /// Relation methods for " + s.name + "\n";
            c += "    impl " + s.path + " {\n";

            for rel in struct_def.relations {
                let method_name = to_snake_case(rel.name);
                let source_table = to_snake_case(rel.source_table_name) + "s";
                let source_field = to_snake_case(rel.source_field);

                let pk_field = "id";
                for idx in struct_def.indexes {
                    if idx.name == "ById" || idx.field_name == "id" {
                        pk_field = to_snake_case(idx.field_name);
                        break;
                    }
                }

                let fqn = rel.source_table_fqn;
                let type_suffix = "." + rel.source_table_name;
                let ns_fqn = fqn;
                if fqn.ends_with(type_suffix) {
                    ns_fqn = fqn.sub_string(0, fqn.len() - type_suffix.len());
                }
                let rel_ns_path = ns_fqn;
                rel_ns_path.replace(".", "_");

                c += "        /// Get related " + rel.name + "\n";
                c += "        pub fn " + method_name + "<'a>(&self, container: &'a " + container_name + ") -> Vec<&'a crate::";
                c += schema_mod + "::" + rel_ns_path + "::" + rel.source_table_name + "> {\n";
                c += "            container." + source_table + ".get_by_" + source_field + "(self." + pk_field + ")\n";
                c += "        }\n\n";
            }

            c += "    }\n\n";
        }
        c += "}\n";
    }

    print("Generating file: " + final_path);
    write_file(final_path, c);
}
%endlogic
