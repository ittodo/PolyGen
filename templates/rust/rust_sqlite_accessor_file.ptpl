%logic
// Rust SQLite Accessor Generator (PolyTemplate)
// Generates a database accessor for @datasource("sqlite") tables using rusqlite

fn join_with(arr, sep) {
    let result = "";
    let i = 0;
    for item in arr {
        if i > 0 { result += sep; }
        result += item;
        i += 1;
    }
    result
}

fn is_sqlite_table(struct_datasource, ns_datasource) {
    if struct_datasource != () && struct_datasource != "" {
        return struct_datasource == "sqlite";
    }
    if ns_datasource != () && ns_datasource != "" {
        return ns_datasource == "sqlite";
    }
    return false;
}

fn rust_type(type_name) {
    switch type_name {
        "string" => "String",
        "bool" => "bool",
        "bytes" => "Vec<u8>",
        "u8" => "u8",
        "u16" => "u16",
        "u32" => "u32",
        "u64" => "u64",
        "i8" => "i8",
        "i16" => "i16",
        "i32" => "i32",
        "i64" => "i64",
        "f32" => "f32",
        "f64" => "f64",
        _ => type_name
    }
}

fn sqlite_getter(type_name, idx) {
    switch type_name {
        "string" => "row.get(" + idx + ")?",
        "bool" => "row.get(" + idx + ")?",
        "u8" => "row.get::<_, i32>(" + idx + ")? as u8",
        "u16" => "row.get::<_, i32>(" + idx + ")? as u16",
        "u32" => "row.get::<_, i64>(" + idx + ")? as u32",
        "u64" => "row.get::<_, i64>(" + idx + ")? as u64",
        "i8" => "row.get::<_, i32>(" + idx + ")? as i8",
        "i16" => "row.get::<_, i32>(" + idx + ")? as i16",
        "i32" => "row.get(" + idx + ")?",
        "i64" => "row.get(" + idx + ")?",
        "f32" => "row.get::<_, f64>(" + idx + ")? as f32",
        "f64" => "row.get(" + idx + ")?",
        "bytes" => "row.get(" + idx + ")?",
        _ => "row.get(" + idx + ")?"
    }
}

// Collect all SQLite tables
let sqlite_tables = [];

for file in schema.files {
    if file.path == () || file.path == "" { continue; }

    for ns in file.namespaces {
        let ns_datasource = ns.datasource;

        for item in ns.items {
            if item.is_struct() {
                let s = item.as_struct();
                if is_sqlite_table(s.datasource, ns_datasource) {
                    let ns_parts = ns.name.split(".");
                    let mod_path = join_with(ns_parts, "_");
                    let table_name = join_with(ns_parts, "_") + "_" + s.name;
                    let field_name = to_snake_case(s.name) + "s";
                    let full_type = mod_path + "::" + s.name;

                    sqlite_tables.push(#{
                        name: s.name,
                        snake_name: to_snake_case(s.name),
                        fqn: s.fqn,
                        ns_name: ns.name,
                        mod_path: mod_path,
                        table_name: table_name,
                        field_name: field_name,
                        full_type: full_type,
                        struct_def: s
                    });
                }
            }
        }
    }
}

let has_tables = sqlite_tables.len() > 0;

// Pre-compute use lines (unique mod paths)
let use_lines = [];
let imported_mods = #{};
for tbl in sqlite_tables {
    if !(tbl.mod_path in imported_mods) {
        use_lines.push("use crate::schema::" + tbl.mod_path + ";");
        imported_mods[tbl.mod_path] = true;
    }
}

// Pre-compute per-table bodies (must use index)
let tidx = 0;
for tbl in sqlite_tables {
    let s = tbl.struct_def;

    // row mapping body (shared between load and get_by_id)
    let map_lines = [];
    let field_idx = 0;
    for item in s.items {
        if item.is_field() {
            let f = item.as_field();
            let getter = sqlite_getter(f.field_type.type_name, field_idx);
            map_lines.push("                " + f.name + ": " + getter + ",");
            field_idx += 1;
        }
    }
    let all_tables_map_body = join_with(map_lines, "\n");
    sqlite_tables[tidx].map_body = all_tables_map_body;

    // Find first field for get_by_id
    let id_field = ();
    let id_type = "i64";
    for item in s.items {
        if item.is_field() {
            let f = item.as_field();
            id_field = f.name;
            id_type = rust_type(f.field_type.type_name);
            break;
        }
    }
    sqlite_tables[tidx].id_field = id_field;
    sqlite_tables[tidx].id_type = id_type;
    sqlite_tables[tidx].has_id = id_field != ();

    tidx += 1;
}
%endlogic
%if has_tables
//! Generated by PolyGen - SQLite Database Accessor
//! This module provides typed access to SQLite tables.
%blank
use rusqlite::{Connection, Result, params};
use std::path::Path;
%blank
// Import generated types
%for line in use_lines
{{line}}
%endfor
%blank
/// Provides typed access to a SQLite table.
pub struct DbTable<T> {
    table_name: String,
    cache: Vec<T>,
}
%blank
impl<T> DbTable<T> {
    pub fn new(table_name: &str) -> Self {
        Self {
            table_name: table_name.to_string(),
            cache: Vec::new(),
        }
    }
%blank
    /// Returns all loaded records.
    pub fn all(&self) -> &[T] {
        &self.cache
    }
%blank
    /// Returns the number of loaded records.
    pub fn len(&self) -> usize {
        self.cache.len()
    }
%blank
    /// Returns true if no records are loaded.
    pub fn is_empty(&self) -> bool {
        self.cache.is_empty()
    }
}
%blank
/// SQLite database accessor for game data.
pub struct SqliteDb {
    conn: Connection,
%for tbl in sqlite_tables
    pub {{tbl.field_name}}: DbTable<{{tbl.full_type}}>,
%endfor
}
%blank
impl SqliteDb {
    /// Opens a connection to the SQLite database.
    pub fn open<P: AsRef<Path>>(path: P) -> Result<Self> {
        let conn = Connection::open(path)?;
        Ok(Self {
            conn,
%for tbl in sqlite_tables
            {{tbl.field_name}}: DbTable::new("{{tbl.table_name}}"),
%endfor
        })
    }
%blank
    /// Loads all tables into memory.
    pub fn load_all(&mut self) -> Result<()> {
%for tbl in sqlite_tables
        self.load_{{tbl.field_name}}()?;
%endfor
        Ok(())
    }
%blank
%for tbl in sqlite_tables
    /// Loads all records from the {{tbl.name}} table.
    pub fn load_{{tbl.field_name}}(&mut self) -> Result<()> {
        self.{{tbl.field_name}}.cache.clear();
        let mut stmt = self.conn.prepare("SELECT * FROM {{tbl.table_name}}")?;
        let rows = stmt.query_map([], |row| {
            Ok({{tbl.full_type}} {
{{tbl.map_body}}
            })
        })?;
        for row in rows {
            self.{{tbl.field_name}}.cache.push(row?);
        }
        Ok(())
    }
%blank
%endfor
%for tbl in sqlite_tables
%if tbl.has_id
    /// Gets a {{tbl.name}} by its ID.
    pub fn get_{{tbl.snake_name}}_by_id(&self, id: {{tbl.id_type}}) -> Result<Option<{{tbl.full_type}}>> {
        let mut stmt = self.conn.prepare("SELECT * FROM {{tbl.table_name}} WHERE {{tbl.id_field}} = ?1")?;
        let mut rows = stmt.query_map([id as i64], |row| {
            Ok({{tbl.full_type}} {
{{tbl.map_body}}
            })
        })?;
        match rows.next() {
            Some(row) => Ok(Some(row?)),
            None => Ok(None),
        }
    }
%blank
%endif
%endfor
}
%endif
