%logic
// Rust SQLite Accessor Generator (PolyTemplate)
// Generates a database accessor for @datasource("sqlite") tables using rusqlite

// Helper function to join array elements
fn join_with(arr, sep) {
    let result = "";
    let i = 0;
    for item in arr {
        if i > 0 { result += sep; }
        result += item;
        i += 1;
    }
    result
}

// Check if a struct should be included for SQLite
fn is_sqlite_table(struct_datasource, ns_datasource) {
    if struct_datasource != () && struct_datasource != "" {
        return struct_datasource == "sqlite";
    }
    if ns_datasource != () && ns_datasource != "" {
        return ns_datasource == "sqlite";
    }
    return false;
}

// Map poly types to Rust types
fn rust_type(type_name) {
    switch type_name {
        "string" => "String",
        "bool" => "bool",
        "bytes" => "Vec<u8>",
        "u8" => "u8",
        "u16" => "u16",
        "u32" => "u32",
        "u64" => "u64",
        "i8" => "i8",
        "i16" => "i16",
        "i32" => "i32",
        "i64" => "i64",
        "f32" => "f32",
        "f64" => "f64",
        _ => type_name
    }
}

// Map poly types to rusqlite column getter
fn sqlite_getter(type_name, idx) {
    switch type_name {
        "string" => "row.get(" + idx + ")?",
        "bool" => "row.get(" + idx + ")?",
        "u8" => "row.get::<_, i32>(" + idx + ")? as u8",
        "u16" => "row.get::<_, i32>(" + idx + ")? as u16",
        "u32" => "row.get::<_, i64>(" + idx + ")? as u32",
        "u64" => "row.get::<_, i64>(" + idx + ")? as u64",
        "i8" => "row.get::<_, i32>(" + idx + ")? as i8",
        "i16" => "row.get::<_, i32>(" + idx + ")? as i16",
        "i32" => "row.get(" + idx + ")?",
        "i64" => "row.get(" + idx + ")?",
        "f32" => "row.get::<_, f64>(" + idx + ")? as f32",
        "f64" => "row.get(" + idx + ")?",
        "bytes" => "row.get(" + idx + ")?",
        _ => "row.get(" + idx + ")?"
    }
}

// Helper to remove .poly extension
fn remove_poly_extension(filename) {
    let len = filename.len();
    let poly_len = 5;
    if len > poly_len {
        let suffix_start = len - poly_len;
        let suffix = filename.sub_string(suffix_start, poly_len);
        if suffix == ".poly" {
            return filename.sub_string(0, suffix_start);
        }
    }
    filename
}

// Collect all SQLite tables
let sqlite_tables = [];

for file in schema.files {
    if file.path == () || file.path == "" { continue; }

    for ns in file.namespaces {
        let ns_datasource = ns.datasource;

        for item in ns.items {
            if item.is_struct() {
                let s = item.as_struct();
                if is_sqlite_table(s.datasource, ns_datasource) {
                    let ns_parts = ns.name.split(".");
                    let mod_path = join_with(ns_parts, "_");

                    sqlite_tables.push(#{
                        name: s.name,
                        fqn: s.fqn,
                        ns_name: ns.name,
                        mod_path: mod_path,
                        struct_def: s
                    });
                }
            }
        }
    }
}

// Only generate if there are SQLite tables
if sqlite_tables.len() == 0 {
    return;
}

// Generate the accessor code
let code = "//! Generated by PolyGen - SQLite Database Accessor\n";
code += "//! This module provides typed access to SQLite tables.\n\n";

code += "use rusqlite::{Connection, Result, params};\n";
code += "use std::path::Path;\n\n";

// Import the generated types
code += "// Import generated types\n";
let imported_mods = #{};
for tbl in sqlite_tables {
    if !(tbl.mod_path in imported_mods) {
        code += "use crate::schema::" + tbl.mod_path + ";\n";
        imported_mods[tbl.mod_path] = true;
    }
}
code += "\n";

// Generate DbTable struct
code += "/// Provides typed access to a SQLite table.\n";
code += "pub struct DbTable<T> {\n";
code += "    table_name: String,\n";
code += "    cache: Vec<T>,\n";
code += "}\n\n";

code += "impl<T> DbTable<T> {\n";
code += "    pub fn new(table_name: &str) -> Self {\n";
code += "        Self {\n";
code += "            table_name: table_name.to_string(),\n";
code += "            cache: Vec::new(),\n";
code += "        }\n";
code += "    }\n\n";

code += "    /// Returns all loaded records.\n";
code += "    pub fn all(&self) -> &[T] {\n";
code += "        &self.cache\n";
code += "    }\n\n";

code += "    /// Returns the number of loaded records.\n";
code += "    pub fn len(&self) -> usize {\n";
code += "        self.cache.len()\n";
code += "    }\n\n";

code += "    /// Returns true if no records are loaded.\n";
code += "    pub fn is_empty(&self) -> bool {\n";
code += "        self.cache.is_empty()\n";
code += "    }\n";
code += "}\n\n";

// Generate the main SqliteDb struct
code += "/// SQLite database accessor for game data.\n";
code += "pub struct SqliteDb {\n";
code += "    conn: Connection,\n";
for tbl in sqlite_tables {
    let field_name = to_snake_case(tbl.name) + "s";
    code += "    pub " + field_name + ": DbTable<" + tbl.mod_path + "::" + tbl.name + ">,\n";
}
code += "}\n\n";

// Generate impl block
code += "impl SqliteDb {\n";

// Constructor
code += "    /// Opens a connection to the SQLite database.\n";
code += "    pub fn open<P: AsRef<Path>>(path: P) -> Result<Self> {\n";
code += "        let conn = Connection::open(path)?;\n";
code += "        Ok(Self {\n";
code += "            conn,\n";
for tbl in sqlite_tables {
    let field_name = to_snake_case(tbl.name) + "s";
    let ns_parts = tbl.ns_name.split(".");
    let table_name = join_with(ns_parts, "_") + "_" + tbl.name;
    code += "            " + field_name + ": DbTable::new(\"" + table_name + "\"),\n";
}
code += "        })\n";
code += "    }\n\n";

// Load all method
code += "    /// Loads all tables into memory.\n";
code += "    pub fn load_all(&mut self) -> Result<()> {\n";
for tbl in sqlite_tables {
    let field_name = to_snake_case(tbl.name) + "s";
    code += "        self.load_" + field_name + "()?;\n";
}
code += "        Ok(())\n";
code += "    }\n\n";

// Generate load methods for each table
for tbl in sqlite_tables {
    let s = tbl.struct_def;
    let field_name = to_snake_case(tbl.name) + "s";
    let ns_parts = tbl.ns_name.split(".");
    let table_name = join_with(ns_parts, "_") + "_" + tbl.name;
    let full_type = tbl.mod_path + "::" + tbl.name;

    code += "    /// Loads all records from the " + tbl.name + " table.\n";
    code += "    pub fn load_" + field_name + "(&mut self) -> Result<()> {\n";
    code += "        self." + field_name + ".cache.clear();\n";
    code += "        let mut stmt = self.conn.prepare(\"SELECT * FROM " + table_name + "\")?;\n";
    code += "        let rows = stmt.query_map([], |row| {\n";
    code += "            Ok(" + full_type + " {\n";

    let field_idx = 0;
    for item in s.items {
        if item.is_field() {
            let f = item.as_field();
            let type_name = f.field_type.type_name;
            let getter = sqlite_getter(type_name, field_idx);

            code += "                " + f.name + ": " + getter + ",\n";
            field_idx += 1;
        }
    }

    code += "            })\n";
    code += "        })?;\n";
    code += "        for row in rows {\n";
    code += "            self." + field_name + ".cache.push(row?);\n";
    code += "        }\n";
    code += "        Ok(())\n";
    code += "    }\n\n";
}

// Get by ID method for each table
for tbl in sqlite_tables {
    let s = tbl.struct_def;
    let field_name = to_snake_case(tbl.name) + "s";
    let ns_parts = tbl.ns_name.split(".");
    let table_name = join_with(ns_parts, "_") + "_" + tbl.name;
    let full_type = tbl.mod_path + "::" + tbl.name;

    let id_field = ();
    let id_type = "i64";
    for item in s.items {
        if item.is_field() {
            let f = item.as_field();
            id_field = f.name;
            id_type = rust_type(f.field_type.type_name);
            break;
        }
    }

    if id_field != () {
        code += "    /// Gets a " + tbl.name + " by its ID.\n";
        code += "    pub fn get_" + to_snake_case(tbl.name) + "_by_id(&self, id: " + id_type + ") -> Result<Option<" + full_type + ">> {\n";
        code += "        let mut stmt = self.conn.prepare(\"SELECT * FROM " + table_name + " WHERE " + id_field + " = ?1\")?;\n";
        code += "        let mut rows = stmt.query_map([id as i64], |row| {\n";
        code += "            Ok(" + full_type + " {\n";

        let field_idx = 0;
        for item in s.items {
            if item.is_field() {
                let f = item.as_field();
                let type_name = f.field_type.type_name;
                let getter = sqlite_getter(type_name, field_idx);

                code += "                " + f.name + ": " + getter + ",\n";
                field_idx += 1;
            }
        }

        code += "            })\n";
        code += "        })?;\n";
        code += "        match rows.next() {\n";
        code += "            Some(row) => Ok(Some(row?)),\n";
        code += "            None => Ok(None),\n";
        code += "        }\n";
        code += "    }\n\n";
    }
}

code += "}\n";

// Determine output filename
let out_filename = "schema_sqlite_accessor.rs";
for file in schema.files {
    let fp = file.path;
    if fp != () && fp != "" {
        let base_name = fp;
        if fp.contains("/") {
            let parts = fp.split("/");
            base_name = parts[parts.len() - 1];
        }
        let name_without_ext = remove_poly_extension(base_name);
        out_filename = name_without_ext + "_sqlite_accessor.rs";
        break;
    }
}

let out_path = output_dir + "/rust/" + out_filename;
print("Generating file: " + out_path);
write_file(out_path, code);
%endlogic
