%logic
// Rust Loaders file generator (PolyTemplate)
// Generates JSON, CSV, and Binary I/O in a single module file

import "templates/rust/rhai_utils/type_mapping" as rust_types;

// CSV getter helper
fn csv_getter(f) {
    let t = f.field_type;
    let n = f.name;

    if t.is_option {
        if t.type_name == "string" { return "row.get_optional_string(\"" + n + "\")"; }
        if t.is_struct { return "None"; }
        if t.is_enum { return "row.get_i32(\"" + n + "\").map(|v| unsafe { std::mem::transmute(v) }).ok()"; }
        return "row.get(\"" + n + "\").filter(|s| !s.is_empty()).and_then(|s| s.parse().ok())";
    }
    if t.is_list {
        if t.is_struct { return "Default::default()"; }
        return "row.get(\"" + n + "\").map(|s| s.split(',').filter_map(|v| v.trim().parse().ok()).collect()).unwrap_or_default()";
    }
    if t.is_struct { return "Default::default()"; }
    if t.type_name == "string" { return "row.get_string(\"" + n + "\").ok_or_else(|| LoadError::Parse(\"" + n + "\".into()))?"; }
    if t.type_name == "u32" { return "row.get_u32(\"" + n + "\").ok_or_else(|| LoadError::Parse(\"" + n + "\".into()))?"; }
    if t.type_name == "u16" { return "row.get_u16(\"" + n + "\").ok_or_else(|| LoadError::Parse(\"" + n + "\".into()))?"; }
    if t.type_name == "u64" { return "row.get_u64(\"" + n + "\").ok_or_else(|| LoadError::Parse(\"" + n + "\".into()))?"; }
    if t.type_name == "i32" { return "row.get_i32(\"" + n + "\").ok_or_else(|| LoadError::Parse(\"" + n + "\".into()))?"; }
    if t.type_name == "f32" { return "row.get_f32(\"" + n + "\").ok_or_else(|| LoadError::Parse(\"" + n + "\".into()))?"; }
    if t.type_name == "f64" { return "row.get_f64(\"" + n + "\").ok_or_else(|| LoadError::Parse(\"" + n + "\".into()))?"; }
    if t.type_name == "bool" { return "row.get_bool(\"" + n + "\").ok_or_else(|| LoadError::Parse(\"" + n + "\".into()))?"; }
    if t.type_name == "timestamp" { return "row.get_timestamp(\"" + n + "\").ok_or_else(|| LoadError::Parse(\"" + n + "\".into()))?"; }
    if t.is_enum { return "row.get_i32(\"" + n + "\").map(|v| unsafe { std::mem::transmute(v) }).ok_or_else(|| LoadError::Parse(\"" + n + "\".into()))?"; }
    return "Default::default()";
}

// Binary read helper - generates read expression for a type
fn bin_read(t) {
    let n = t.type_name;
    if t.is_option {
        let inner = bin_read_closure(t);
        return "reader.read_optional(|r| " + inner + ")?";
    }
    if t.is_list {
        let inner = bin_read_closure(t);
        return "reader.read_vec(|r| " + inner + ")?";
    }
    return bin_read_direct(t) + "?";
}

fn bin_read_closure(t) {
    let n = t.type_name;
    if n == "string" { return "r.read_string()"; }
    if n == "bool" { return "r.read_bool()"; }
    if n == "u8" { return "r.read_u8()"; }
    if n == "u16" { return "r.read_u16()"; }
    if n == "u32" { return "r.read_u32()"; }
    if n == "u64" { return "r.read_u64()"; }
    if n == "i8" { return "r.read_i8()"; }
    if n == "i16" { return "r.read_i16()"; }
    if n == "i32" { return "r.read_i32()"; }
    if n == "i64" { return "r.read_i64()"; }
    if n == "f32" { return "r.read_f32()"; }
    if n == "f64" { return "r.read_f64()"; }
    if n == "bytes" { return "r.read_bytes()"; }
    if n == "timestamp" { return "r.read_timestamp()"; }
    if t.is_enum { return "r.read_i32().map(|v| unsafe { std::mem::transmute(v) })"; }
    return n + "::read_binary(r)";
}

fn bin_read_direct(t) {
    let n = t.type_name;
    if n == "string" { return "reader.read_string()"; }
    if n == "bool" { return "reader.read_bool()"; }
    if n == "u8" { return "reader.read_u8()"; }
    if n == "u16" { return "reader.read_u16()"; }
    if n == "u32" { return "reader.read_u32()"; }
    if n == "u64" { return "reader.read_u64()"; }
    if n == "i8" { return "reader.read_i8()"; }
    if n == "i16" { return "reader.read_i16()"; }
    if n == "i32" { return "reader.read_i32()"; }
    if n == "i64" { return "reader.read_i64()"; }
    if n == "f32" { return "reader.read_f32()"; }
    if n == "f64" { return "reader.read_f64()"; }
    if n == "bytes" { return "reader.read_bytes()"; }
    if n == "timestamp" { return "reader.read_timestamp()"; }
    if t.is_enum { return "reader.read_i32().map(|v| unsafe { std::mem::transmute(v) })"; }
    return n + "::read_binary(reader)";
}

// Binary write helper
fn bin_write(t, expr) {
    let n = t.type_name;
    if t.is_option {
        let inner = bin_write_inner(t);
        return "writer.write_optional(&" + expr + ", |w, v| " + inner + ")?";
    }
    if t.is_list {
        let inner = bin_write_inner(t);
        return "writer.write_vec(&" + expr + ", |w, v| " + inner + ")?";
    }
    return bin_write_direct(t, expr) + "?";
}

fn bin_write_inner(t) {
    let n = t.type_name;
    if n == "string" { return "w.write_string(v)"; }
    if n == "bool" { return "w.write_bool(*v)"; }
    if n == "u8" { return "w.write_u8(*v)"; }
    if n == "u16" { return "w.write_u16(*v)"; }
    if n == "u32" { return "w.write_u32(*v)"; }
    if n == "u64" { return "w.write_u64(*v)"; }
    if n == "i8" { return "w.write_i8(*v)"; }
    if n == "i16" { return "w.write_i16(*v)"; }
    if n == "i32" { return "w.write_i32(*v)"; }
    if n == "i64" { return "w.write_i64(*v)"; }
    if n == "f32" { return "w.write_f32(*v)"; }
    if n == "f64" { return "w.write_f64(*v)"; }
    if n == "bytes" { return "w.write_bytes(v)"; }
    if n == "timestamp" { return "w.write_timestamp(v)"; }
    if t.is_enum { return "w.write_i32(*v as i32)"; }
    return "v.write_binary(w)";
}

fn bin_write_direct(t, expr) {
    let n = t.type_name;
    if n == "string" { return "writer.write_string(&" + expr + ")"; }
    if n == "bool" { return "writer.write_bool(" + expr + ")"; }
    if n == "u8" { return "writer.write_u8(" + expr + ")"; }
    if n == "u16" { return "writer.write_u16(" + expr + ")"; }
    if n == "u32" { return "writer.write_u32(" + expr + ")"; }
    if n == "u64" { return "writer.write_u64(" + expr + ")"; }
    if n == "i8" { return "writer.write_i8(" + expr + ")"; }
    if n == "i16" { return "writer.write_i16(" + expr + ")"; }
    if n == "i32" { return "writer.write_i32(" + expr + ")"; }
    if n == "i64" { return "writer.write_i64(" + expr + ")"; }
    if n == "f32" { return "writer.write_f32(" + expr + ")"; }
    if n == "f64" { return "writer.write_f64(" + expr + ")"; }
    if n == "bytes" { return "writer.write_bytes(&" + expr + ")"; }
    if n == "timestamp" { return "writer.write_timestamp(&" + expr + ")"; }
    if t.is_enum { return "writer.write_i32(" + expr + " as i32)"; }
    return expr + ".write_binary(writer)";
}

fn join_with(arr, sep) {
    let result = "";
    let i = 0;
    for item in arr {
        if i > 0 { result += sep; }
        result += item;
        i += 1;
    }
    result
}

// First pass: build namespace -> schema_mod mapping for all files
let ns_to_schema = #{};
for f in schema.files {
    if f.path == () || f.path == "" { continue; }
    let parts = f.path.split("/");
    let fname = parts[parts.len - 1];
    let mod_name = fname;
    mod_name.replace(".poly", "");

    for ns in f.namespaces {
        ns_to_schema[ns.name] = mod_name;
        for item in ns.items {
            if item.is_namespace() {
                let child = item.as_namespace();
                ns_to_schema[child.name] = mod_name;
            }
        }
    }
}

let skip_file = file.path == () || file.path == "";

let use_lines = [];
let all_structs = [];

if !skip_file {
    let parts = file.path.split("/");
    let filename = parts[parts.len - 1];
    let schema_mod = filename;
    schema_mod.replace(".poly", "");

    // Collect current file's namespaces
    let current_namespaces = [];
    for ns in file.namespaces {
        current_namespaces.push(ns.name);
        for item in ns.items {
            if item.is_namespace() {
                current_namespaces.push(item.as_namespace().name);
            }
        }
    }

    // Collect all structs (including embedded) recursively
    for ns in file.namespaces {
        let ns_mod_path = ns.name;
        ns_mod_path.replace(".", "_");

        for item in ns.items {
            if item.is_struct() {
                let s = item.as_struct();
                let mp = "crate::" + schema_mod + "::" + ns_mod_path + "::" + s.name;
                all_structs.push(#{ name: s.name, mod_path: mp, def: s });
                for si in s.items {
                    if si.is_embedded_struct() {
                        let es = si.as_embedded_struct();
                        let emp = "crate::" + schema_mod + "::" + ns_mod_path + "::" + es.name;
                        all_structs.push(#{ name: es.name, mod_path: emp, def: es });
                        for esi in es.items {
                            if esi.is_embedded_struct() {
                                let nes = esi.as_embedded_struct();
                                let nmp = "crate::" + schema_mod + "::" + ns_mod_path + "::" + nes.name;
                                all_structs.push(#{ name: nes.name, mod_path: nmp, def: nes });
                            }
                        }
                    }
                }
            } else if item.is_namespace() {
                let child = item.as_namespace();
                let child_name = child.name;
                child_name.replace(".", "_");
                let child_mod_path = ns_mod_path + "::" + child_name;
                for child_item in child.items {
                    if child_item.is_struct() {
                        let cs = child_item.as_struct();
                        let cmp = "crate::" + schema_mod + "::" + child_mod_path + "::" + cs.name;
                        all_structs.push(#{ name: cs.name, mod_path: cmp, def: cs });
                        for csi in cs.items {
                            if csi.is_embedded_struct() {
                                let ces = csi.as_embedded_struct();
                                let cemp = "crate::" + schema_mod + "::" + child_mod_path + "::" + ces.name;
                                all_structs.push(#{ name: ces.name, mod_path: cemp, def: ces });
                            }
                        }
                    }
                }
            }
        }
    }

    // Collect use lines
    for other_file in schema.files {
        if other_file.path == () || other_file.path == "" { continue; }
        let other_parts = other_file.path.split("/");
        let other_fname = other_parts[other_parts.len - 1];
        let other_mod = other_fname;
        other_mod.replace(".poly", "");

        for ns in other_file.namespaces {
            let ns_path = ns.name;
            ns_path.replace(".", "_");
            use_lines.push("use crate::" + other_mod + "::" + ns_path + "::*;");

            for item in ns.items {
                if item.is_namespace() {
                    let child = item.as_namespace();
                    let child_path = child.name;
                    child_path.replace(".", "_");
                    use_lines.push("use crate::" + other_mod + "::" + ns_path + "::" + child_path + "::*;");
                }
            }
        }
    }

    // Pre-compute per-struct bodies (must use index to mutate original array)
    let idx = 0;
    for s in all_structs {
        // CSV body
        let csv_lines = [];
        for item in s.def.items {
            if item.is_field() {
                let f = item.as_field();
                csv_lines.push("            " + to_snake_case(f.name) + ": " + csv_getter(f) + ",");
            }
        }
        all_structs[idx].csv_body = join_with(csv_lines, "\n");

        // Binary read body
        let br_lines = [];
        for item in s.def.items {
            if item.is_field() {
                let f = item.as_field();
                br_lines.push("            " + to_snake_case(f.name) + ": " + bin_read(f.field_type) + ",");
            }
        }
        all_structs[idx].bin_read_body = join_with(br_lines, "\n");

        // Binary write body
        let bw_lines = [];
        for item in s.def.items {
            if item.is_field() {
                let f = item.as_field();
                let fname = to_snake_case(f.name);
                bw_lines.push("        " + bin_write(f.field_type, "self." + fname) + ";");
            }
        }
        all_structs[idx].bin_write_body = join_with(bw_lines, "\n");

        idx += 1;
    }
}
%endlogic
%if !skip_file
//! Generated by PolyGen - Data Loaders
//! Source: {{file.path}}
%blank
use std::fs;
use std::io::{Read, Write, Result as IoResult};
use std::path::Path;
use crate::polygen_support::*;
%for line in use_lines
{{line}}
%endfor
%blank
// ============ JSON Loader ============
%blank
pub trait JsonLoadable: Sized + serde::de::DeserializeOwned {
    fn load_json<P: AsRef<Path>>(path: P) -> Result<Self, Box<dyn std::error::Error>> {
        Ok(serde_json::from_str(&fs::read_to_string(path)?)?)
    }
    fn load_json_vec<P: AsRef<Path>>(path: P) -> Result<Vec<Self>, Box<dyn std::error::Error>> {
        Ok(serde_json::from_str(&fs::read_to_string(path)?)?)
    }
}
%blank
%for s in all_structs
impl JsonLoadable for {{s.mod_path}} {}
%endfor
%blank
// ============ CSV Loader ============
%blank
pub trait CsvLoadable: Sized {
    fn from_csv_row(row: &CsvRow) -> LoadResult<Self>;
    fn load_csv(path: &str) -> LoadResult<Vec<Self>> {
        CsvReader::from_file(path).map_err(LoadError::Csv)?.rows().map(|r| Self::from_csv_row(&r)).collect()
    }
}
%blank
%for s in all_structs
impl CsvLoadable for {{s.mod_path}} {
    fn from_csv_row(row: &CsvRow) -> LoadResult<Self> {
        Ok(Self {
{{s.csv_body}}
        })
    }
}
%blank
%endfor
// ============ Binary I/O ============
%blank
pub use crate::polygen_support::BinaryIO;
%blank
%for s in all_structs
impl BinaryIO for {{s.mod_path}} {
    fn read_binary<R: Read>(reader: &mut R) -> IoResult<Self> {
        Ok(Self {
{{s.bin_read_body}}
        })
    }
    fn write_binary<W: Write>(&self, writer: &mut W) -> IoResult<()> {
{{s.bin_write_body}}
        Ok(())
    }
}
%blank
%endfor
%endif
