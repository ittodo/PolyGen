%let cur_s = struct
%logic
let inline_enums = [];
for it in cur_s.items {
    if it.is_inline_enum() {
        let e = it.as_inline_enum();
        inline_enums.push(e.name);
    }
}
let current_ns_name = namespace.name;
%endlogic
public static void Write{{struct.name}}(this BinaryWriter bw, global::{{struct.fqn}} obj)
{
%for item in struct.items
%if item.is_field
%let field = item.as_field
%logic
let f = field;
let tf = f.field_type;
let base = if tf.is_option { tf.inner } else { tf };
let write_assign = "";

if tf.is_option {
    let inner = base;
    if inner.lang_type == "string" {
        write_assign = "BinaryUtils.WriteOptionRef<string>(bw, obj." + f.name + ", BinaryUtils.WriteUtf8String);";
    } else if inner.is_list {
        let elem = inner.inner;
        if elem.lang_type == "string" {
            write_assign = "BinaryUtils.WriteOptionRef<IList<string>>(bw, obj." + f.name + ", (bw2, list) => BinaryUtils.WriteList<string>(bw2, list, BinaryUtils.WriteUtf8String));";
        } else if elem.is_enum || inline_enums.contains(elem.type_name) {
            let enum_type = if elem.is_enum { cur_s.name + "." + elem.type_name } else { elem.fqn };
            write_assign = "BinaryUtils.WriteOptionRef<IList<" + enum_type + ">>(bw, obj." + f.name + ", (bw2, list) => BinaryUtils.WriteList<" + enum_type + ">(bw2, list, BinaryUtils.WriteEnumInt32<" + enum_type + ">));";
        } else if elem.is_primitive {
            let mapped = cs_type(elem.lang_type);
            write_assign = "BinaryUtils.WriteOptionRef<IList<" + mapped + ">>(bw, obj." + f.name + ", (bw2, list) => BinaryUtils.WriteList<" + mapped + ">(bw2, list, (bw2,v)=>bw2.Write(v)));";
        } else {
            let es_nl = find_embedded_struct(cur_s, elem.type_name);
            let call_ns = if es_nl != () { current_ns_name } else { if elem.namespace_fqn == "" { current_ns_name } else { elem.namespace_fqn } };
            write_assign = "BinaryUtils.WriteOptionRef<IList<global::" + elem.fqn + ">>( bw, obj." + f.name + ", (bw2, list) => BinaryUtils.WriteList<global::" + elem.fqn + ">(bw2, list, " + call_ns + ".BinaryWriters.Write" + elem.type_name + "));";
        }
    } else if inner.is_enum || inline_enums.contains(inner.type_name) {
        let enum_type = inner.fqn;
        write_assign = "BinaryUtils.WriteOptionStruct<" + enum_type + ">(bw, obj." + f.name + ", BinaryUtils.WriteEnumInt32<" + enum_type + ">);";
    } else if inner.lang_type == "timestamp" {
        write_assign = "BinaryUtils.WriteOptionStruct<DateTime>(bw, obj." + f.name + ", (bw2,v)=>bw2.Write(v.Ticks));";
    } else if inner.is_primitive {
        let mapped = cs_type(inner.lang_type);
        write_assign = "BinaryUtils.WriteOptionStruct<" + mapped + ">(bw, obj." + f.name + ", (bw2,v)=>bw2.Write(v));";
    } else {
        let es_nl = find_embedded_struct(cur_s, inner.type_name);
        let call_ns = if es_nl != () { current_ns_name } else { if inner.namespace_fqn == "" { current_ns_name } else { inner.namespace_fqn } };
        write_assign = "BinaryUtils.WriteOptionRef<global::" + inner.fqn + ">(bw, obj." + f.name + ", " + call_ns + ".BinaryWriters.Write" + inner.type_name + ");";
    }
} else if base.is_list {
    let inner = base.inner;
    if inner.lang_type == "string" {
        write_assign = "BinaryUtils.WriteList<string>(bw, obj." + f.name + ", BinaryUtils.WriteUtf8String);";
    } else if inner.is_enum || inline_enums.contains(inner.type_name) {
        let enum_type = inner.fqn;
        write_assign = "BinaryUtils.WriteList<" + enum_type + ">(bw, obj." + f.name + ", BinaryUtils.WriteEnumInt32<" + enum_type + ">);";
    } else if inner.lang_type == "timestamp" {
        write_assign = "BinaryUtils.WriteList<DateTime>(bw, obj." + f.name + ", (bw2,v)=>bw2.Write(v.Ticks));";
    } else if inner.is_primitive {
        let mapped = cs_type(inner.lang_type);
        write_assign = "BinaryUtils.WriteList<" + mapped + ">(bw, obj." + f.name + ", (bw2,v)=>bw2.Write(v));";
    } else {
        let es_nl = find_embedded_struct(cur_s, inner.type_name);
        let call_ns = if es_nl != () { current_ns_name } else { if inner.namespace_fqn == "" { current_ns_name } else { inner.namespace_fqn } };
        write_assign = "BinaryUtils.WriteList<global::" + inner.fqn + ">(bw, obj." + f.name + ", " + call_ns + ".BinaryWriters.Write" + inner.type_name + ");";
    }
} else if base.lang_type == "string" {
    write_assign = "BinaryUtils.WriteUtf8String(bw, obj." + f.name + ");";
} else if base.lang_type == "bytes" {
    write_assign = "BinaryUtils.WriteBytes(bw, obj." + f.name + ");";
} else if base.lang_type == "timestamp" {
    write_assign = "bw.Write(obj." + f.name + ".Ticks);";
} else if base.is_enum || inline_enums.contains(base.type_name) {
    let enum_type = base.fqn;
    write_assign = "BinaryUtils.WriteEnumInt32<" + enum_type + ">(bw, obj." + f.name + ");";
} else if base.is_primitive {
    write_assign = "bw.Write(obj." + f.name + ");";
} else {
    let es_nl = find_embedded_struct(cur_s, base.type_name);
    let call_ns = if es_nl != () { current_ns_name } else { if base.namespace_fqn == "" { current_ns_name } else { base.namespace_fqn } };
    write_assign = call_ns + ".BinaryWriters.Write" + base.type_name + "(bw, obj." + f.name + ");";
}
%endlogic
    {{write_assign}}
%endif
%if item.is_comment
    // {{item.as_comment}}
%endif
%endfor
}
%for item in struct.items
%if item.is_embedded_struct
%blank
%include "binary/writers_struct" with item.as_embedded_struct
%endif
%endfor
