%let cur_s = struct
%logic
let inline_enums = [];
for it in cur_s.items {
    if it.is_inline_enum() {
        let e = it.as_inline_enum();
        inline_enums.push(e.name);
    }
}
let current_ns_name = namespace.name;
%endlogic
public static global::{{struct.fqn}} Read{{struct.name}}(this BinaryReader br)
{
    var obj = new global::{{struct.fqn}}();
%for item in struct.items
%if item.is_field
%let field = item.as_field
%logic
let f = field;
let tf = f.field_type;
let base = if tf.is_option { tf.inner } else { tf };
let read_kind = "direct";
let read_assign = "";

if tf.is_option {
    let inner = base;
    read_kind = "wrapped";
    if inner.lang_type == "string" {
        read_assign = "obj." + f.name + " = BinaryUtils.ReadOption<string>(br, BinaryUtils.ReadUtf8String);";
    } else if inner.is_primitive {
        let k = inner.lang_type;
        let cs = cs_type(k);
        read_assign = "obj." + f.name + " = BinaryUtils.ReadOption<" + cs + ">(br, _ => " + read_expr(k, "br") + ");";
    } else if inner.is_enum || inline_enums.contains(inner.type_name) {
        let enum_type = inner.fqn;
        read_assign = "obj." + f.name + " = BinaryUtils.ReadOption<" + enum_type + ">(br, BinaryUtils.ReadEnumInt32<" + enum_type + ">);";
    } else {
        let es_nl = find_embedded_struct(cur_s, inner.type_name);
        let call_ns = if es_nl != () { current_ns_name } else { if inner.namespace_fqn == "" { current_ns_name } else { inner.namespace_fqn } };
        read_assign = "obj." + f.name + " = BinaryUtils.ReadOption<global::" + inner.fqn + ">(br, " + call_ns + ".BinaryReaders.Read" + inner.type_name + ");";
    }
} else if base.is_list {
    let inner = base.inner;
    read_kind = "wrapped";
    if inner.lang_type == "string" {
        read_assign = "obj." + f.name + " = BinaryUtils.ReadList<string>(br, BinaryUtils.ReadUtf8String);";
    } else if inner.is_primitive {
        let k = inner.lang_type;
        let cs = cs_type(k);
        read_assign = "obj." + f.name + " = BinaryUtils.ReadList<" + cs + ">(br, _ => " + read_expr(k, "br") + ");";
    } else if inner.is_enum || inline_enums.contains(inner.type_name) {
        let enum_type = inner.fqn;
        read_assign = "obj." + f.name + " = BinaryUtils.ReadList<" + enum_type + ">(br, BinaryUtils.ReadEnumInt32<" + enum_type + ">);";
    } else {
        let es_nl = find_embedded_struct(cur_s, inner.type_name);
        let call_ns = if es_nl != () { current_ns_name } else { if inner.namespace_fqn == "" { current_ns_name } else { inner.namespace_fqn } };
        read_assign = "obj." + f.name + " = BinaryUtils.ReadList<global::" + inner.fqn + ">(br, " + call_ns + ".BinaryReaders.Read" + inner.type_name + ");";
    }
} else if base.lang_type == "string" {
    read_assign = "obj." + f.name + " = BinaryUtils.ReadUtf8String(br);";
} else if base.lang_type == "bytes" {
    read_assign = "obj." + f.name + " = BinaryUtils.ReadBytes(br);";
} else if base.lang_type == "timestamp" {
    read_assign = "obj." + f.name + " = new DateTime(br.ReadInt64(), DateTimeKind.Utc);";
} else if base.is_enum || inline_enums.contains(base.type_name) {
    let enum_type = base.fqn;
    read_assign = "obj." + f.name + " = BinaryUtils.ReadEnumInt32<" + enum_type + ">(br);";
} else if base.is_primitive {
    read_assign = "obj." + f.name + " = " + read_expr(base.lang_type, "br") + ";";
} else {
    let es_nl = find_embedded_struct(cur_s, base.type_name);
    let call_ns = if es_nl != () { current_ns_name } else { if base.namespace_fqn == "" { current_ns_name } else { base.namespace_fqn } };
    read_assign = "obj." + f.name + " = " + call_ns + ".BinaryReaders.Read" + base.type_name + "(br);";
}
%endlogic
%if read_kind == "wrapped"
        {
            {{read_assign}}
        }
%else
        {{read_assign}}
%endif
%endif
%if item.is_comment
        // {{item.as_comment}}
%endif
%if item.is_embedded_struct
        // TODO: Embedded struct '{{item.as_embedded_struct.name}}' binary read not implemented
%endif
%if item.is_inline_enum
        // TODO: Inline enum '{{item.as_inline_enum.name}}' binary read not implemented
%endif
%endfor

    return obj;
}
%for item in struct.items
%if item.is_embedded_struct
%blank
%include "binary/readers_struct" with item.as_embedded_struct
%endif
%endfor
