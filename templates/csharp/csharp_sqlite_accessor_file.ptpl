%logic
// Helper function to join array elements
fn join_with(arr, sep) {
    let result = "";
    let i = 0;
    for item in arr {
        if i > 0 { result += sep; }
        result += item;
        i += 1;
    }
    result
}

// Check if a struct should be included for SQLite
fn is_sqlite_table(struct_datasource, ns_datasource) {
    if struct_datasource != () && struct_datasource != "" {
        return struct_datasource == "sqlite";
    }
    if ns_datasource != () && ns_datasource != "" {
        return ns_datasource == "sqlite";
    }
    return false;
}

// Get cache strategy, default to "full_load" if not specified
fn get_cache_strategy(struct_def) {
    let strategy = struct_def.cache_strategy;
    if strategy == () || strategy == "" {
        return "full_load";
    }
    return strategy;
}

// Collect all SQLite tables with their info from ALL schema files
let sqlite_tables = [];
let table_by_name = #{};

for f in schema.files {
    if f.path == () || f.path == "" { continue; }
    for ns in f.namespaces {
        let ns_datasource = ns.datasource;
        for item in ns.items {
            if item.is_struct() {
                let s = item.as_struct();
                if is_sqlite_table(s.datasource, ns_datasource) {
                    let cache_strategy = get_cache_strategy(s);
                    let fk_dependencies = [];
                    for struct_item in s.items {
                        if struct_item.is_field() {
                            let field = struct_item.as_field();
                            if field.has_foreign_key {
                                let fk = field.foreign_key;
                                let target_parts = fk.target_table_fqn.split(".");
                                let target_table = "";
                                for part in target_parts {
                                    target_table = part;
                                }
                                fk_dependencies.push(target_table);
                            }
                        }
                    }
                    let tbl_info = #{
                        name: s.name,
                        fqn: s.fqn,
                        ns_name: ns.name,
                        struct_def: s,
                        cache_strategy: cache_strategy,
                        fk_dependencies: fk_dependencies
                    };
                    sqlite_tables.push(tbl_info);
                    table_by_name[s.name] = tbl_info;
                }
            }
        }
    }
}

let has_sqlite_tables = sqlite_tables.len() > 0;

// Build reverse dependency map
let reverse_deps = #{};
for tbl in sqlite_tables {
    reverse_deps[tbl.name] = [];
}
for tbl in sqlite_tables {
    for dep in tbl.fk_dependencies {
        if reverse_deps[dep] != () {
            reverse_deps[dep].push(tbl.name);
        }
    }
}

// ============================================================
// Generate table properties
// ============================================================
let props_code = "";
for tbl in sqlite_tables {
    let prop_name = tbl.name + "s";
    props_code += "        public DbTable<" + tbl.fqn + "> " + prop_name + " { get; }\n";
}

// ============================================================
// Generate constructor body
// ============================================================
let ctor_body = "";
for tbl in sqlite_tables {
    let prop_name = tbl.name + "s";
    let ns_prefix = if tbl.ns_name != "" {
        let parts = tbl.ns_name.split(".");
        join_with(parts, "_") + "_"
    } else {
        ""
    };
    let table_name = ns_prefix + tbl.name;
    let strategy_enum = if tbl.cache_strategy == "on_demand" {
        "CacheStrategy.OnDemand"
    } else if tbl.cache_strategy == "write_through" {
        "CacheStrategy.WriteThrough"
    } else if tbl.cache_strategy == "write_back" {
        "CacheStrategy.WriteBack"
    } else {
        "CacheStrategy.FullLoad"
    };
    ctor_body += "            " + prop_name + " = new DbTable<" + tbl.fqn + ">(\n";
    ctor_body += "                _connection,\n";
    ctor_body += "                \"" + table_name + "\",\n";
    ctor_body += "                reader => Map" + tbl.name + "(reader),\n";
    ctor_body += "                " + strategy_enum + ");\n\n";
}

// ============================================================
// LoadAll body
// ============================================================
let load_all_body = "";
for tbl in sqlite_tables {
    if tbl.cache_strategy == "full_load" || tbl.cache_strategy == () || tbl.cache_strategy == "" {
        let prop_name = tbl.name + "s";
        load_all_body += "            " + prop_name + ".Load();\n";
    }
}

// ============================================================
// LoadWithDependencies for on_demand tables
// ============================================================
let load_deps_code = "";
for tbl in sqlite_tables {
    if tbl.cache_strategy == "on_demand" {
        let method_name = "Load" + tbl.name + "WithDependencies";
        let all_deps = [];
        for dep in tbl.fk_dependencies {
            if table_by_name[dep] != () {
                all_deps.push(dep);
            }
        }
        load_deps_code += "        /// <summary>\n";
        load_deps_code += "        /// Loads " + tbl.name + " and all FK-related tables, then validates.\n";
        load_deps_code += "        /// Related tables: " + (if all_deps.len() > 0 { join_with(all_deps, ", ") } else { "(none)" }) + "\n";
        load_deps_code += "        /// </summary>\n";
        load_deps_code += "        public ValidationResult " + method_name + "()\n";
        load_deps_code += "        {\n";
        for dep in all_deps {
            load_deps_code += "            " + dep + "s.Load();\n";
        }
        load_deps_code += "            " + tbl.name + "s.Load();\n\n";
        load_deps_code += "            return ValidateLoadedTables();\n";
        load_deps_code += "        }\n\n";
    }
}

// ============================================================
// ValidateFullLoadTables body
// ============================================================
let validate_full_body = "";
for tbl in sqlite_tables {
    if tbl.cache_strategy == "full_load" || tbl.cache_strategy == () || tbl.cache_strategy == "" {
        let s = tbl.struct_def;
        let prop_name = tbl.name + "s";
        let pk_field = "";
        for item in s.items {
            if item.is_field() {
                let field = item.as_field();
                if field.is_primary_key { pk_field = field.name; }
            }
        }
        let has_validations = false;
        for item in s.items {
            if item.is_field() {
                let field = item.as_field();
                if field.has_max_length || field.has_range || field.has_regex_pattern {
                    has_validations = true;
                }
            }
        }
        if has_validations {
            validate_full_body += "\n            // Validate " + tbl.name + " (FullLoad)\n";
            validate_full_body += "            foreach (var row in " + prop_name + ".All)\n";
            validate_full_body += "            {\n";
            let key_expr = if pk_field != "" { "row." + pk_field } else { "null" };
            for item in s.items {
                if item.is_field() {
                    let field = item.as_field();
                    let ft = field.field_type;
                    if field.has_max_length {
                        let max_len = field.max_length;
                        validate_full_body += "                if (row." + field.name + " != null && row." + field.name + ".Length > " + max_len + ")\n";
                        validate_full_body += "                    result.AddError(ValidationHelpers.MaxLengthError(\"" + tbl.name + "\", \"" + field.name + "\", " + key_expr + ", " + max_len + ", row." + field.name + ".Length));\n";
                    }
                    if field.has_range {
                        let range = field.range;
                        if ft.is_option {
                            validate_full_body += "                if (row." + field.name + ".HasValue && !ValidationHelpers.ValidateRange(row." + field.name + ".Value, " + range.min + ", " + range.max + "))\n";
                        } else {
                            validate_full_body += "                if (!ValidationHelpers.ValidateRange(row." + field.name + ", " + range.min + ", " + range.max + "))\n";
                        }
                        validate_full_body += "                    result.AddError(ValidationHelpers.RangeError(\"" + tbl.name + "\", \"" + field.name + "\", " + key_expr + ", " + range.min + ", " + range.max + ", row." + field.name + "));\n";
                    }
                    if field.has_regex_pattern {
                        let pattern = field.regex_pattern;
                        validate_full_body += "                if (!ValidationHelpers.ValidateRegex(row." + field.name + ", @\"" + pattern + "\"))\n";
                        validate_full_body += "                    result.AddError(ValidationHelpers.RegexError(\"" + tbl.name + "\", \"" + field.name + "\", " + key_expr + ", @\"" + pattern + "\", row." + field.name + "));\n";
                    }
                }
            }
            validate_full_body += "            }\n";
        }
    }
}

// ============================================================
// ValidateLoadedTables body
// ============================================================
let validate_loaded_body = "";
for tbl in sqlite_tables {
    if tbl.cache_strategy == "write_through" || tbl.cache_strategy == "write_back" {
        continue;
    }
    let s = tbl.struct_def;
    let prop_name = tbl.name + "s";
    let pk_field = "";
    for item in s.items {
        if item.is_field() {
            let field = item.as_field();
            if field.is_primary_key { pk_field = field.name; }
        }
    }
    let has_validations = false;
    for item in s.items {
        if item.is_field() {
            let field = item.as_field();
            if field.has_max_length || field.has_range || field.has_regex_pattern {
                has_validations = true;
            }
        }
    }
    if has_validations {
        validate_loaded_body += "\n            // Validate " + tbl.name + " (if loaded)\n";
        validate_loaded_body += "            if (" + prop_name + ".IsLoaded)\n";
        validate_loaded_body += "            {\n";
        validate_loaded_body += "                foreach (var row in " + prop_name + ".All)\n";
        validate_loaded_body += "                {\n";
        let key_expr = if pk_field != "" { "row." + pk_field } else { "null" };
        for item in s.items {
            if item.is_field() {
                let field = item.as_field();
                let ft = field.field_type;
                if field.has_max_length {
                    let max_len = field.max_length;
                    validate_loaded_body += "                    if (row." + field.name + " != null && row." + field.name + ".Length > " + max_len + ")\n";
                    validate_loaded_body += "                        result.AddError(ValidationHelpers.MaxLengthError(\"" + tbl.name + "\", \"" + field.name + "\", " + key_expr + ", " + max_len + ", row." + field.name + ".Length));\n";
                }
                if field.has_range {
                    let range = field.range;
                    if ft.is_option {
                        validate_loaded_body += "                    if (row." + field.name + ".HasValue && !ValidationHelpers.ValidateRange(row." + field.name + ".Value, " + range.min + ", " + range.max + "))\n";
                    } else {
                        validate_loaded_body += "                    if (!ValidationHelpers.ValidateRange(row." + field.name + ", " + range.min + ", " + range.max + "))\n";
                    }
                    validate_loaded_body += "                        result.AddError(ValidationHelpers.RangeError(\"" + tbl.name + "\", \"" + field.name + "\", " + key_expr + ", " + range.min + ", " + range.max + ", row." + field.name + "));\n";
                }
                if field.has_regex_pattern {
                    let pattern = field.regex_pattern;
                    validate_loaded_body += "                    if (!ValidationHelpers.ValidateRegex(row." + field.name + ", @\"" + pattern + "\"))\n";
                    validate_loaded_body += "                        result.AddError(ValidationHelpers.RegexError(\"" + tbl.name + "\", \"" + field.name + "\", " + key_expr + ", @\"" + pattern + "\", row." + field.name + "));\n";
                }
            }
        }
        validate_loaded_body += "                }\n";
        validate_loaded_body += "            }\n";
    }
}

// ============================================================
// ValidateFullLoadForeignKeys body
// ============================================================
let validate_fk_full_body = "";
for tbl in sqlite_tables {
    if tbl.cache_strategy != "full_load" && tbl.cache_strategy != () && tbl.cache_strategy != "" {
        continue;
    }
    let s = tbl.struct_def;
    let ns_prefix = if tbl.ns_name != "" {
        let parts = tbl.ns_name.split(".");
        join_with(parts, "_") + "_"
    } else {
        ""
    };
    let source_table_name = ns_prefix + tbl.name;
    let pk_field = "";
    for item in s.items {
        if item.is_field() {
            let field = item.as_field();
            if field.is_primary_key { pk_field = field.name; }
        }
    }
    for item in s.items {
        if item.is_field() {
            let field = item.as_field();
            if field.has_foreign_key {
                let fk = field.foreign_key;
                let target_parts = fk.target_table_fqn.split(".");
                let target_table = "";
                for part in target_parts { target_table = part; }
                let target_ns_parts = [];
                let target_fqn_parts = fk.target_table_fqn.split(".");
                for i in 0..(target_fqn_parts.len() - 1) {
                    target_ns_parts.push(target_fqn_parts[i]);
                }
                let target_ns_prefix = if target_ns_parts.len() > 0 { join_with(target_ns_parts, "_") + "_" } else { "" };
                let target_table_full = target_ns_prefix + target_table;
                validate_fk_full_body += "\n            // FK: " + tbl.name + "." + field.name + " -> " + target_table + "\n";
                validate_fk_full_body += "            using (var cmd = _connection.CreateCommand())\n";
                validate_fk_full_body += "            {\n";
                validate_fk_full_body += "                cmd.CommandText = @\"\n";
                validate_fk_full_body += "                    SELECT s." + field.name;
                if pk_field != "" {
                    validate_fk_full_body += ", s." + pk_field;
                }
                validate_fk_full_body += "\n";
                validate_fk_full_body += "                    FROM " + source_table_name + " s\n";
                validate_fk_full_body += "                    LEFT JOIN " + target_table_full + " t ON s." + field.name + " = t." + fk.target_field + "\n";
                validate_fk_full_body += "                    WHERE t." + fk.target_field + " IS NULL";
                if field.field_type.is_option {
                    validate_fk_full_body += " AND s." + field.name + " IS NOT NULL";
                }
                validate_fk_full_body += "\";\n";
                validate_fk_full_body += "                using var reader = cmd.ExecuteReader();\n";
                validate_fk_full_body += "                while (reader.Read())\n";
                validate_fk_full_body += "                {\n";
                validate_fk_full_body += "                    var fkValue = reader.GetValue(0);\n";
                if pk_field != "" {
                    validate_fk_full_body += "                    var pkValue = reader.GetValue(1);\n";
                    validate_fk_full_body += "                    result.AddError(ValidationHelpers.ForeignKeyError(\"" + tbl.name + "\", \"" + field.name + "\", pkValue, \"" + target_table + "\", fkValue));\n";
                } else {
                    validate_fk_full_body += "                    result.AddError(ValidationHelpers.ForeignKeyError(\"" + tbl.name + "\", \"" + field.name + "\", null, \"" + target_table + "\", fkValue));\n";
                }
                validate_fk_full_body += "                }\n";
                validate_fk_full_body += "            }\n";
            }
        }
    }
}

// ============================================================
// ValidateLoadedForeignKeys body
// ============================================================
let validate_fk_loaded_body = "";
for tbl in sqlite_tables {
    if tbl.cache_strategy == "write_through" || tbl.cache_strategy == "write_back" {
        continue;
    }
    let s = tbl.struct_def;
    let prop_name = tbl.name + "s";
    let pk_field = "";
    for item in s.items {
        if item.is_field() {
            let field = item.as_field();
            if field.is_primary_key { pk_field = field.name; }
        }
    }
    let has_fk = false;
    for item in s.items {
        if item.is_field() {
            let field = item.as_field();
            if field.has_foreign_key { has_fk = true; }
        }
    }
    if has_fk {
        validate_fk_loaded_body += "\n            // FK validation for " + tbl.name + " (if loaded)\n";
        validate_fk_loaded_body += "            if (" + prop_name + ".IsLoaded)\n";
        validate_fk_loaded_body += "            {\n";
        validate_fk_loaded_body += "                foreach (var row in " + prop_name + ".All)\n";
        validate_fk_loaded_body += "                {\n";
        let key_expr = if pk_field != "" { "row." + pk_field } else { "null" };
        for item in s.items {
            if item.is_field() {
                let field = item.as_field();
                if field.has_foreign_key {
                    let fk = field.foreign_key;
                    let target_parts = fk.target_table_fqn.split(".");
                    let target_table = "";
                    for part in target_parts { target_table = part; }
                    validate_fk_loaded_body += "                    // Check FK: " + field.name + " -> " + target_table + "\n";
                    validate_fk_loaded_body += "                    if (" + target_table + "s.IsLoaded)\n";
                    validate_fk_loaded_body += "                    {\n";
                    if field.field_type.is_option {
                        validate_fk_loaded_body += "                        if (row." + field.name + ".HasValue && !" + target_table + "s.All.Any(t => t." + fk.target_field + " == row." + field.name + ".Value))\n";
                    } else {
                        validate_fk_loaded_body += "                        if (!" + target_table + "s.All.Any(t => t." + fk.target_field + " == row." + field.name + "))\n";
                    }
                    validate_fk_loaded_body += "                            result.AddError(ValidationHelpers.ForeignKeyError(\"" + tbl.name + "\", \"" + field.name + "\", " + key_expr + ", \"" + target_table + "\", row." + field.name + "));\n";
                    validate_fk_loaded_body += "                    }\n";
                }
            }
        }
        validate_fk_loaded_body += "                }\n";
        validate_fk_loaded_body += "            }\n";
    }
}

// ============================================================
// Mapper methods
// ============================================================
let mappers_code = "";
for tbl in sqlite_tables {
    let s = tbl.struct_def;
    mappers_code += "        private static " + tbl.fqn + " Map" + tbl.name + "(SqliteDataReader reader)\n";
    mappers_code += "        {\n";
    mappers_code += "            return new " + tbl.fqn + "\n";
    mappers_code += "            {\n";
    let field_idx = 0;
    for item in s.items {
        if item.is_field() {
            let f = item.as_field();
            let ct = cs_type(f.field_type.lang_type);
            let reader_method = "";
            if ct == "string" {
                reader_method = "reader.IsDBNull(" + field_idx + ") ? null : reader.GetString";
            } else if ct == "int" || ct == "Int32" {
                reader_method = "reader.GetInt32";
            } else if ct == "uint" || ct == "UInt32" {
                reader_method = "(uint)reader.GetInt64";
            } else if ct == "long" || ct == "Int64" {
                reader_method = "reader.GetInt64";
            } else if ct == "ulong" || ct == "UInt64" {
                reader_method = "(ulong)reader.GetInt64";
            } else if ct == "short" || ct == "Int16" {
                reader_method = "reader.GetInt16";
            } else if ct == "ushort" || ct == "UInt16" {
                reader_method = "(ushort)reader.GetInt32";
            } else if ct == "byte" {
                reader_method = "reader.GetByte";
            } else if ct == "sbyte" {
                reader_method = "(sbyte)reader.GetInt16";
            } else if ct == "float" || ct == "Single" {
                reader_method = "reader.GetFloat";
            } else if ct == "double" || ct == "Double" {
                reader_method = "reader.GetDouble";
            } else if ct == "bool" || ct == "Boolean" {
                reader_method = "reader.GetBoolean";
            } else {
                reader_method = "reader.IsDBNull(" + field_idx + ") ? null : reader.GetString";
            }
            if field_idx > 0 {
                mappers_code += ",\n";
            }
            mappers_code += "                " + f.name + " = " + reader_method + "(" + field_idx + ")";
            field_idx += 1;
        }
    }
    mappers_code += "\n            };\n";
    mappers_code += "        }\n\n";
}
%endlogic
%if has_sqlite_tables
// Generated by PolyGen - SQLite Database Accessor
// This file provides DbContext-style access to SQLite tables.
// Supports cache strategies: full_load, on_demand, write_through, write_back

using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using Microsoft.Data.Sqlite;
using Polygen.Common;

namespace Polygen.Data
{
    /// <summary>
    /// Cache strategy for database tables.
    /// </summary>
    public enum CacheStrategy
    {
        /// <summary>Load all data at startup.</summary>
        FullLoad,
        /// <summary>Load data on first access, including FK dependencies.</summary>
        OnDemand,
        /// <summary>Write changes immediately to database. No validation.</summary>
        WriteThrough,
        /// <summary>Batch writes for later flush. No validation.</summary>
        WriteBack
    }

    /// <summary>
    /// Provides typed access to a SQLite table with cache strategy support.
    /// </summary>
    public class DbTable<T> where T : class, new()
    {
        private readonly SqliteConnection _connection;
        private readonly string _tableName;
        private readonly Func<SqliteDataReader, T> _mapper;
        private readonly CacheStrategy _cacheStrategy;
        private List<T> _cache = new List<T>();
        private bool _isLoaded = false;

        public DbTable(SqliteConnection connection, string tableName, Func<SqliteDataReader, T> mapper, CacheStrategy cacheStrategy)
        {
            _connection = connection;
            _tableName = tableName;
            _mapper = mapper;
            _cacheStrategy = cacheStrategy;
        }

        public IReadOnlyList<T> All => _cache;
        public bool IsLoaded => _isLoaded;
        public CacheStrategy Strategy => _cacheStrategy;

        /// <summary>
        /// Loads all data from the table into cache.
        /// </summary>
        public void Load()
        {
            if (_isLoaded) return;
            _cache.Clear();
            using var cmd = _connection.CreateCommand();
            cmd.CommandText = $"SELECT * FROM {_tableName}";
            using var reader = cmd.ExecuteReader();
            while (reader.Read())
            {
                _cache.Add(_mapper(reader));
            }
            _isLoaded = true;
        }

        /// <summary>
        /// Clears the cache and resets loaded state.
        /// </summary>
        public void Reset()
        {
            _cache.Clear();
            _isLoaded = false;
        }

        public T GetById<TKey>(TKey id, string idColumn = "id")
        {
            using var cmd = _connection.CreateCommand();
            cmd.CommandText = $"SELECT * FROM {_tableName} WHERE {idColumn} = @id";
            cmd.Parameters.AddWithValue("@id", id);
            using var reader = cmd.ExecuteReader();
            if (reader.Read()) return _mapper(reader);
            return null;
        }
    }

    /// <summary>
    /// SQLite database context with cache strategy support.
    /// </summary>
    public class SqliteDbContext : IDisposable
    {
        private readonly SqliteConnection _connection;
        private bool _disposed = false;

{{props_code}}
        public SqliteDbContext(string connectionString)
        {
            _connection = new SqliteConnection(connectionString);
            _connection.Open();

{{ctor_body}}
        }

        /// <summary>
        /// Loads all tables with FullLoad cache strategy.
        /// </summary>
        public void LoadAll()
        {
{{load_all_body}}
        }

        /// <summary>
        /// Loads all FullLoad tables and validates them.
        /// </summary>
        public ValidationResult LoadAllAndValidate()
        {
            LoadAll();
            return ValidateFullLoadTables();
        }

{{load_deps_code}}
        /// <summary>
        /// Validates all tables with FullLoad cache strategy.
        /// </summary>
        public ValidationResult ValidateFullLoadTables()
        {
            var result = new ValidationResult();
{{validate_full_body}}
            // Validate FK references for FullLoad tables
            result.Merge(ValidateFullLoadForeignKeys());
            return result;
        }

        /// <summary>
        /// Validates all currently loaded tables (for on_demand scenarios).
        /// Skips write_through and write_back tables.
        /// </summary>
        public ValidationResult ValidateLoadedTables()
        {
            var result = new ValidationResult();
{{validate_loaded_body}}
            // Validate FK references for loaded tables
            result.Merge(ValidateLoadedForeignKeys());
            return result;
        }

        /// <summary>
        /// Validates FK references for FullLoad tables using SQL.
        /// </summary>
        public ValidationResult ValidateFullLoadForeignKeys()
        {
            var result = new ValidationResult();
{{validate_fk_full_body}}
            return result;
        }

        /// <summary>
        /// Validates FK references for currently loaded tables (on_demand).
        /// Uses in-memory validation since related tables should also be loaded.
        /// </summary>
        public ValidationResult ValidateLoadedForeignKeys()
        {
            var result = new ValidationResult();
{{validate_fk_loaded_body}}
            return result;
        }

        /// <summary>
        /// Validates all loaded data and throws if errors are found.
        /// </summary>
        public void ValidateOrThrow()
        {
            var result = ValidateLoadedTables();
            if (!result.IsValid)
                throw new ValidationException(result);
        }

{{mappers_code}}
        public void Dispose()
        {
            if (!_disposed)
            {
                _connection?.Dispose();
                _disposed = true;
            }
        }
    }
}
%endif
