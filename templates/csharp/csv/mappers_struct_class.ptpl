%let cur_s = struct
%logic
let full_t = "global::" + cur_s.fqn;
let current_ns_name = namespace.name;

// ============================================================
// HeaderColumnCount helper
// ============================================================
let header_col_count = "    private static int HeaderColumnCount(Polygen.Common.CsvIndexHeader h)\n";
header_col_count += "    {\n";
header_col_count += "        if (h.Index >= 0)\n";
header_col_count += "        {\n";
header_col_count += "            return 1;\n";
header_col_count += "        }\n";
header_col_count += "        int n = 0;\n";
header_col_count += "        if (h.IndexList != null)\n";
header_col_count += "        {\n";
header_col_count += "            for (int i = 0; i < h.IndexList.Count; i++)\n";
header_col_count += "            {\n";
header_col_count += "                n += HeaderColumnCount(h.IndexList[i]);\n";
header_col_count += "            }\n";
header_col_count += "        }\n";
header_col_count += "        return n;\n";
header_col_count += "    }\n";

// ============================================================
// Writer: AppendRowWithHeader
// ============================================================
let writer_code = "";
writer_code += "    public static void AppendRowWithHeader(Polygen.Common.CsvIndexHeader h, in " + full_t + " obj, List<string> cols, Polygen.Common.CsvUtils.GapMode gap = Polygen.Common.CsvUtils.GapMode.Break)\n";
writer_code += "    {\n";
writer_code += "        int __idx = 0;\n";

// 1) Non-list fields
for it in cur_s.items {
    if it.is_field() {
        let f = it.as_field();
        let tf = f.field_type;
        let base = if tf.is_option { tf.inner } else { tf };
        if !base.is_list {
            let field_name = f.name;
            writer_code += "        {\n";
            writer_code += "            var __h = (h != null && h.IndexList != null && __idx < h.IndexList.Count) ? h.IndexList[__idx++] : null;\n";
            if base.is_enum {
                writer_code += "          if (__h != null && __h.Index >= 0)\n";
                writer_code += "          {\n";
                writer_code += "              cols.Add(obj." + field_name + ".ToString());\n";
                writer_code += "          }\n";
                writer_code += "          else if (__h != null && __h.IndexList != null)\n";
                writer_code += "          {\n";
                writer_code += "              int pad = HeaderColumnCount(__h);\n";
                writer_code += "              for (int k = 0; k < pad; k++)\n";
                writer_code += "              {\n";
                writer_code += "                  cols.Add(string.Empty);\n";
                writer_code += "              }\n";
                writer_code += "          }\n";
                writer_code += "          else\n";
                writer_code += "          {\n";
                writer_code += "              cols.Add(string.Empty);\n";
                writer_code += "          }\n";
            } else if base.is_primitive || base.lang_type == "string" {
                writer_code += "          if (__h != null && __h.Index >= 0)\n";
                writer_code += "          {\n";
                writer_code += "              cols.Add(Polygen.Common.CsvUtils.ToStringInvariant(obj." + field_name + "));\n";
                writer_code += "          }\n";
                writer_code += "          else\n";
                writer_code += "          {\n";
                writer_code += "              cols.Add(string.Empty);\n";
                writer_code += "          }\n";
            } else {
                let fqn = base.fqn;
                let parts = fqn.split(".");
                let call_ns = "";
                let child_name = "";
                let i = 0;
                for seg in parts {
                    if i < parts.len - 1 {
                        if call_ns != "" { call_ns += "."; }
                        call_ns += seg;
                    } else { child_name = seg; }
                    i += 1;
                }
                let call_prefix = if call_ns == "" { "global::Csv." } else { "global::Csv." + call_ns + "." };
                let es_nl = find_embedded_struct(cur_s, base.type_name);
                writer_code += "          if (__h != null && __h.IndexList != null)\n";
                writer_code += "          {\n";
                writer_code += "              if (obj." + field_name + " != null)\n";
                writer_code += "              {\n";
                if es_nl != () {
                    let owner_fqn = cur_s.fqn;
                    writer_code += "                  global::Csv." + owner_fqn + "." + es_nl.name + ".AppendRowWithHeader(__h, obj." + field_name + ", cols, gap);\n";
                } else {
                    writer_code += "                  " + call_prefix + child_name + ".AppendRowWithHeader(__h, obj." + field_name + ", cols, gap);\n";
                }
                writer_code += "              }\n";
                writer_code += "              else\n";
                writer_code += "              {\n";
                writer_code += "                  int pad = HeaderColumnCount(__h); for (int k=0;k<pad;k++) cols.Add(string.Empty);\n";
                writer_code += "              }\n";
                writer_code += "          }\n";
                writer_code += "          else\n";
                writer_code += "          {\n";
                writer_code += "              cols.Add(string.Empty);\n";
                writer_code += "          }\n";
            }
            writer_code += "        }\n";
        }
    }
}

// 2) List fields
for it in cur_s.items {
    if it.is_field() {
        let f = it.as_field();
        let tf = f.field_type;
        let base = if tf.is_option { tf.inner } else { tf };
        if base.is_list {
            let inner = base.inner;
            writer_code += "        {\n";
            writer_code += "            var __h = (h != null && h.IndexList != null && __idx < h.IndexList.Count) ? h.IndexList[__idx++] : null;\n";
            if inner.is_enum {
                writer_code += "          int count = (__h != null && __h.IndexList != null) ? __h.IndexList.Count : 0; \n";
                writer_code += "          for (int j=0;j<count;j++)\n";
                writer_code += "          {\n";
                writer_code += "            if (obj." + f.name + " != null && j < obj." + f.name + ".Count)\n";
                writer_code += "            {\n";
                writer_code += "                var v = obj." + f.name + "[j];\n";
                writer_code += "                cols.Add(v.ToString());\n";
                writer_code += "            }\n";
                writer_code += "            else\n";
                writer_code += "            {\n";
                writer_code += "                cols.Add(string.Empty);\n";
                writer_code += "            }\n";
                writer_code += "          }\n";
            } else if inner.is_primitive || inner.lang_type == "string" {
                writer_code += "          int count = (__h != null && __h.IndexList != null) ? __h.IndexList.Count : 0; \n";
                writer_code += "          for (int j=0;j<count;j++)\n";
                writer_code += "          {\n";
                writer_code += "            if (obj." + f.name + " != null && j < obj." + f.name + ".Count)\n";
                writer_code += "            {\n";
                writer_code += "                var v = obj." + f.name + "[j];\n";
                writer_code += "                cols.Add(Polygen.Common.CsvUtils.ToStringInvariant(v));\n";
                writer_code += "            }\n";
                writer_code += "            else\n";
                writer_code += "            {\n";
                writer_code += "                cols.Add(string.Empty);\n";
                writer_code += "            }\n";
                writer_code += "          }\n";
            } else {
                let es = find_embedded_struct(cur_s, inner.type_name);
                if es != () {
                    writer_code += "          int count = (__h != null && __h.IndexList != null) ? __h.IndexList.Count : 0; \n";
                    writer_code += "          for (int j=0;j<count;j++)\n";
                    writer_code += "          {\n";
                    writer_code += "              var subH = __h.IndexList[j]; \n";
                    writer_code += "              if (obj." + f.name + " != null && j < obj." + f.name + ".Count && obj." + f.name + "[j] != null)\n";
                    writer_code += "              {\n";
                    writer_code += "                  var sub = obj." + f.name + "[j];\n";
                    let owner_fqn = cur_s.fqn;
                    writer_code += "                  global::Csv." + owner_fqn + "." + es.name + ".AppendRowWithHeader(subH, sub, cols, gap);\n";
                    writer_code += "              }\n";
                    writer_code += "              else\n";
                    writer_code += "              {\n";
                    writer_code += "                  int pad = HeaderColumnCount(subH); for (int k=0;k<pad;k++) cols.Add(string.Empty);\n";
                    writer_code += "              }\n";
                    writer_code += "          }\n";
                } else {
                    let fqn = inner.fqn;
                    let call_ns = "";
                    let child_name = "";
                    let parts = fqn.split(".");
                    let i = 0;
                    for seg in parts {
                        if i < parts.len - 1 { if call_ns != "" { call_ns += "."; } call_ns += seg; } else { child_name = seg; }
                        i += 1;
                    }
                    let call_prefix = if call_ns == "" { "global::Csv." } else { "global::Csv." + call_ns + "." };
                    writer_code += "          int count = (__h != null && __h.IndexList != null) ? __h.IndexList.Count : 0; \n";
                    writer_code += "          for (int j=0;j<count;j++)\n";
                    writer_code += "          {\n";
                    writer_code += "              var subH = __h.IndexList[j]; \n";
                    writer_code += "              if (obj." + f.name + " != null && j < obj." + f.name + ".Count && obj." + f.name + "[j] != null)\n";
                    writer_code += "              {\n";
                    writer_code += "                  var sub = obj." + f.name + "[j];\n";
                    writer_code += "                  " + call_prefix + child_name + ".AppendRowWithHeader(subH, sub, cols, gap);\n";
                    writer_code += "              }\n";
                    writer_code += "              else\n";
                    writer_code += "              {\n";
                    writer_code += "                  int pad = HeaderColumnCount(subH); for (int k=0;k<pad;k++) cols.Add(string.Empty);\n";
                    writer_code += "              }\n";
                    writer_code += "          }\n";
                }
            }
            writer_code += "        }\n";
        }
    }
}
writer_code += "    }\n";

writer_code += "    public static string[] ToRowWithHeader(Polygen.Common.CsvIndexHeader h, in " + full_t + " obj, Polygen.Common.CsvUtils.GapMode gap = Polygen.Common.CsvUtils.GapMode.Break) { var list = new List<string>(); AppendRowWithHeader(h, obj, list, gap); return list.ToArray(); }\n";

// ============================================================
// Writer: BuildWriteHeaderFromItems
// ============================================================
let build_write_header = "";
build_write_header += "    public static Polygen.Common.CsvIndexHeader BuildWriteHeaderFromItems(System.Collections.Generic.IEnumerable<" + full_t + "> items)\n";
build_write_header += "    {\n";
build_write_header += "        var root = new Polygen.Common.CsvIndexHeader { Index = -1, IndexList = new System.Collections.Generic.List<Polygen.Common.CsvIndexHeader>() };\n";
build_write_header += "        var __nonList = new System.Collections.Generic.List<Polygen.Common.CsvIndexHeader>();\n";

let has_list_items = false;
for it in cur_s.items { if it.is_field() {
    let f = it.as_field();
    let tf = f.field_type; let base = if tf.is_option { tf.inner } else { tf };
    if base.is_list { has_list_items = true; }
} }

if has_list_items {
    build_write_header += "        var __lists = new System.Collections.Generic.List<Polygen.Common.CsvIndexHeader>();\n";
}

for it in cur_s.items { if it.is_field() {
    let f = it.as_field();
    let tf = f.field_type;
    let base = if tf.is_option { tf.inner } else { tf };
    if base.is_list {
        let inner = base.inner;
        build_write_header += "        {\n";
        build_write_header += "            var ch = new Polygen.Common.CsvIndexHeader { Index = -1, IndexList = new System.Collections.Generic.List<Polygen.Common.CsvIndexHeader>() };\n";
        build_write_header += "          int __max = 0; \n";
        build_write_header += "          foreach (var __it in items)\n";
        build_write_header += "          {\n";
        build_write_header += "              var __lst = __it." + f.name + ";\n";
        build_write_header += "              if (__lst != null && __lst.Count > __max)\n";
        build_write_header += "              {\n";
        build_write_header += "                  __max = __lst.Count;\n";
        build_write_header += "              }\n";
        build_write_header += "          }\n";
        if inner.is_primitive || inner.lang_type == "string" || inner.is_enum {
            build_write_header += "          for (int i=0;i<__max;i++)\n";
            build_write_header += "          {\n";
            build_write_header += "              ch.IndexList.Add(new Polygen.Common.CsvIndexHeader { Index = 0 });\n";
            build_write_header += "          }\n";
        } else {
            let call_ns = inner.namespace_fqn;
            let child_name = inner.type_name;
            let type_fqn = if call_ns == "" { child_name } else { call_ns + "." + child_name };
            let es = find_embedded_struct(cur_s, inner.type_name);
            build_write_header += "          for (int i=0;i<__max;i++)\n";
            build_write_header += "          {\n";
            build_write_header += "            var coll = new System.Collections.Generic.List<global::" + type_fqn + ">(); \n";
            build_write_header += "            foreach (var __it in items)\n";
            build_write_header += "            {\n";
            build_write_header += "                var __lst = __it." + f.name + ";\n";
            build_write_header += "                if (__lst != null && __lst.Count > i)\n";
            build_write_header += "                {\n";
            build_write_header += "                    var cand = __lst[i];\n";
            build_write_header += "                    if (cand != null)\n";
            build_write_header += "                    {\n";
            build_write_header += "                        coll.Add(cand);\n";
            build_write_header += "                    }\n";
            build_write_header += "                }\n";
            build_write_header += "            } \n";
            if es != () {
                let owner_fqn = cur_s.fqn;
                build_write_header += "            ch.IndexList.Add(coll.Count > 0 ? global::Csv." + owner_fqn + "." + es.name + ".BuildWriteHeaderFromItems(coll) : new Polygen.Common.CsvIndexHeader());\n";
            } else {
                let call_prefix = if call_ns == "" { "global::Csv." } else { "global::Csv." + call_ns + "." };
                build_write_header += "            ch.IndexList.Add(coll.Count > 0 ? " + call_prefix + child_name + ".BuildWriteHeaderFromItems(coll) : new Polygen.Common.CsvIndexHeader());\n";
            }
            build_write_header += "          }\n";
        }
        build_write_header += "          __lists.Add(ch);\n";
        build_write_header += "        }\n";
    } else {
        if base.is_primitive || base.lang_type == "string" || base.is_enum {
            build_write_header += "        __nonList.Add(new Polygen.Common.CsvIndexHeader { Index = 0 });\n";
        } else {
            let call_ns = base.namespace_fqn;
            let child_name = base.type_name;
            let type_fqn = if call_ns == "" { child_name } else { call_ns + "." + child_name };
            let es_nl = find_embedded_struct(cur_s, base.type_name);
            build_write_header += "        {\n";
            build_write_header += "          Polygen.Common.CsvIndexHeader best = null;\n";
            build_write_header += "          int bestCols = -1;\n";
            build_write_header += "          foreach (var __it in items)\n";
            build_write_header += "          {\n";
            build_write_header += "              if (__it." + f.name + " != null)\n";
            build_write_header += "              {\n";
            if es_nl != () {
                let owner_fqn = cur_s.fqn;
                build_write_header += "                  var _single = new System.Collections.Generic.List<global::" + owner_fqn + "." + es_nl.name + ">();\n";
            } else {
                build_write_header += "                  var _single = new System.Collections.Generic.List<global::" + type_fqn + ">();\n";
            }
            build_write_header += "                  _single.Add(__it." + f.name + ");\n";
            if es_nl != () {
                let owner_fqn = cur_s.fqn;
                build_write_header += "                  var cand = global::Csv." + owner_fqn + "." + es_nl.name + ".BuildWriteHeaderFromItems(_single);\n";
            } else {
                let call_prefix = if call_ns == "" { "global::Csv." } else { "global::Csv." + call_ns + "." };
                build_write_header += "                  var cand = " + call_prefix + child_name + ".BuildWriteHeaderFromItems(_single);\n";
            }
            build_write_header += "                  int cols = HeaderColumnCount(cand);\n";
            build_write_header += "                  if (cols > bestCols)\n";
            build_write_header += "                  {\n";
            build_write_header += "                      bestCols = cols;\n";
            build_write_header += "                      best = cand;\n";
            build_write_header += "                  }\n";
            build_write_header += "              }\n";
            build_write_header += "          }\n";
            build_write_header += "          var sub = (bestCols >= 0) ? best : new Polygen.Common.CsvIndexHeader();\n";
            build_write_header += "          __nonList.Add(sub);\n";
            build_write_header += "        }\n";
        }
    }
} }
build_write_header += "        foreach (var n in __nonList)\n";
build_write_header += "        {\n";
build_write_header += "            root.IndexList.Add(n);\n";
build_write_header += "        }\n";
if has_list_items {
    build_write_header += "        foreach (var l in __lists)\n";
    build_write_header += "        {\n";
    build_write_header += "            root.IndexList.Add(l);\n";
    build_write_header += "        }\n";
}
build_write_header += "        return root;\n";
build_write_header += "    }\n";

// ============================================================
// Writer: CollectWriteHeaderNames
// ============================================================
let collect_names = "";
collect_names += "    public static void CollectWriteHeaderNames(Polygen.Common.CsvIndexHeader h, string prefix, System.Collections.Generic.List<string> names)\n";
collect_names += "    {\n";
collect_names += "        int __idx = 0;\n";

// Non-list first
for it in cur_s.items {
    if it.is_field() {
        let f = it.as_field();
        let tf = f.field_type;
        let base = if tf.is_option { tf.inner } else { tf };
        if !base.is_list {
            collect_names += "        {\n";
            collect_names += "            var __h = (h != null && h.IndexList != null && __idx < h.IndexList.Count) ? h.IndexList[__idx++] : null;\n";
            if base.is_primitive || base.lang_type == "string" || base.is_enum {
                let field_name = f.name;
                collect_names += "          names.Add((prefix==string.Empty? \"" + field_name + "\" : prefix + \"" + field_name + "\"));\n";
            } else {
                let call_ns = base.namespace_fqn;
                let child_name = base.type_name;
                let field_name = f.name;
                let es_nl = find_embedded_struct(cur_s, base.type_name);
                collect_names += "          if (__h != null)\n";
                collect_names += "          {\n";
                if es_nl != () {
                    let owner_fqn = cur_s.fqn;
                    collect_names += "              global::Csv." + owner_fqn + "." + es_nl.name + ".CollectWriteHeaderNames(__h, \n";
                } else {
                    let call_prefix = if call_ns == "" { "global::Csv." } else { "global::Csv." + call_ns + "." };
                    collect_names += "              " + call_prefix + child_name + ".CollectWriteHeaderNames(__h, \n";
                }
                collect_names += "              (prefix==string.Empty? \"" + field_name + ".\" : prefix + \"" + field_name + ".\"), names);\n";
                collect_names += "          }\n";
            }
            collect_names += "        }\n";
        }
    }
}

// Lists next
for it in cur_s.items {
    if it.is_field() {
        let f = it.as_field();
        let tf = f.field_type;
        let base = if tf.is_option { tf.inner } else { tf };
        if base.is_list {
            let inner = base.inner;
            collect_names += "        {\n";
            collect_names += "            var __h = (h != null && h.IndexList != null && __idx < h.IndexList.Count) ? h.IndexList[__idx++] : null;\n";
            if inner.is_primitive || inner.lang_type == "string" || inner.is_enum {
                let field_name = f.name;
                collect_names += "          int count = (__h != null && __h.IndexList != null) ? __h.IndexList.Count : 0; \n";
                collect_names += "          for (int j=0;j<count;j++)\n";
                collect_names += "          {\n";
                collect_names += "              names.Add((prefix==string.Empty? \"" + field_name + "[\" + j + \"]\" : prefix + \"" + field_name + "[\" + j + \"]\"));\n";
                collect_names += "          }\n";
            } else {
                let call_ns = inner.namespace_fqn;
                let child_name = inner.type_name;
                let call_prefix = if call_ns == "" { "global::Csv." } else { "global::Csv." + call_ns + "." };
                collect_names += "          int count = (__h != null && __h.IndexList != null) ? __h.IndexList.Count : 0; \n";
                collect_names += "          for (int j=0;j<count;j++)\n";
                collect_names += "          {\n";
                collect_names += "              var subH = __h.IndexList[j]; \n";
                collect_names += "              " + call_prefix + child_name + ".CollectWriteHeaderNames(subH, \n";
                collect_names += "              (prefix==string.Empty? \"" + f.name + "[\" + j + \"].\" : prefix + \"" + f.name + "[\" + j + \"].\"), names);\n";
                collect_names += "          }\n";
            }
            collect_names += "        }\n";
        }
    }
}
collect_names += "    }\n";

// ============================================================
// Writer: WriteCsv / WriteCsvWithHeader
// ============================================================
let write_csv = "";
write_csv += "    public static void WriteCsv(System.Collections.Generic.IEnumerable<" + full_t + "> items, string path, char sep = ',', Polygen.Common.CsvUtils.GapMode gap = Polygen.Common.CsvUtils.GapMode.Break)\n";
write_csv += "    {\n";
write_csv += "        var list = new System.Collections.Generic.List<" + full_t + ">(); foreach (var it in items) list.Add(it);\n";
write_csv += "        var h = BuildWriteHeaderFromItems(list);\n";
write_csv += "        var names = new System.Collections.Generic.List<string>(); CollectWriteHeaderNames(h, string.Empty, names);\n";
write_csv += "        using var sw = new StreamWriter(path, false, new UTF8Encoding(false));\n";
write_csv += "        sw.WriteLine(Polygen.Common.CsvUtils.Join(names, sep));\n";
write_csv += "        foreach (var it in list)\n";
write_csv += "        {\n";
write_csv += "            var row = ToRowWithHeader(h, it, gap);\n";
write_csv += "            sw.WriteLine(Polygen.Common.CsvUtils.Join(row, sep));\n";
write_csv += "        }\n";
write_csv += "    }\n";

write_csv += "    public static void WriteCsvWithHeader(IEnumerable<" + full_t + "> items, string path, string[] header, char sep = ',', Polygen.Common.CsvUtils.GapMode gap = Polygen.Common.CsvUtils.GapMode.Break)\n";
write_csv += "    {\n";
write_csv += "        var h = BuildHeader(header, string.Empty);\n";
write_csv += "        using var sw = new StreamWriter(path, false, new UTF8Encoding(false));\n";
write_csv += "        sw.WriteLine(Polygen.Common.CsvUtils.Join(header, sep));\n";
write_csv += "        foreach (var it in items)\n";
write_csv += "        {\n";
write_csv += "            var row = ToRowWithHeader(h, it, gap);\n";
write_csv += "            sw.WriteLine(Polygen.Common.CsvUtils.Join(row, sep));\n";
write_csv += "        }\n";
write_csv += "    }\n";

// ============================================================
// Reader: FromRowWithHeader
// ============================================================
let reader_code = "";
reader_code += "    public static " + full_t + " FromRowWithHeader(Polygen.Common.CsvIndexHeader h, string[] row, Polygen.Common.CsvUtils.GapMode gap)\n";
reader_code += "    {\n";
reader_code += "        var obj = new " + full_t + "();\n";
reader_code += "        int __i = 0;\n";

for it in cur_s.items { if it.is_field() {
    let f = it.as_field();
    let tf = f.field_type; let base = if tf.is_option { tf.inner } else { tf };
    reader_code += "        {\n";
    reader_code += "            var __h = (h != null && h.IndexList != null && __i < h.IndexList.Count) ? h.IndexList[__i++] : null;\n";
    if base.is_list {
        let inner = base.inner;
        if inner.is_primitive || inner.lang_type == "string" || inner.is_enum {
            let cs_inner = cs_type(inner.lang_type);
            let generic_t = if inner.is_enum { "global::" + inner.fqn } else { cs_inner };
            reader_code += "            {\n";
            reader_code += "                var list = new System.Collections.Generic.List<" + cs_inner + ">();\n";
            reader_code += "                if (__h != null && __h.IndexList != null)\n";
            reader_code += "                {\n";
            reader_code += "                    for (int i = 0; i < __h.IndexList.Count; i++)\n";
            reader_code += "                    {\n";
            reader_code += "                        var subH = __h.IndexList[i];\n";
            reader_code += "                        if (!Polygen.Common.CsvUtils.HeaderHasValues(subH, row))\n";
            reader_code += "                        {\n";
            reader_code += "                            if (i == 0 || gap == Polygen.Common.CsvUtils.GapMode.Break)\n";
            reader_code += "                            {\n";
            reader_code += "                                break;\n";
            reader_code += "                            }\n";
            reader_code += "                            else\n";
            reader_code += "                            {\n";
            reader_code += "                                continue;\n";
            reader_code += "                            }\n";
            reader_code += "                        }\n";
            reader_code += "                        var v = DataSourceFactory.ConvertValue<" + generic_t + ">(row[subH.Index]);\n";
            reader_code += "                        list.Add(v);\n";
            reader_code += "                    }\n";
            reader_code += "                }\n";
            reader_code += "                obj." + f.name + " = list;\n";
            reader_code += "            }\n";
        } else {
            let call_ns = inner.namespace_fqn;
            let child_name = inner.type_name;
            let es = find_embedded_struct(cur_s, inner.type_name);
            reader_code += "            {\n";
            reader_code += "                var list = new System.Collections.Generic.List<global::" + inner.fqn + ">();\n";
            reader_code += "                if (__h != null && __h.IndexList != null)\n";
            reader_code += "                {\n";
            reader_code += "                    for (int i = 0; i < __h.IndexList.Count; i++)\n";
            reader_code += "                    {\n";
            reader_code += "                        var subH = __h.IndexList[i];\n";
            reader_code += "                        if (!Polygen.Common.CsvUtils.HeaderHasValues(subH, row))\n";
            reader_code += "                        {\n";
            reader_code += "                            if (i == 0 || gap == Polygen.Common.CsvUtils.GapMode.Break)\n";
            reader_code += "                            {\n";
            reader_code += "                                break;\n";
            reader_code += "                            }\n";
            reader_code += "                            else\n";
            reader_code += "                            {\n";
            reader_code += "                                continue;\n";
            reader_code += "                            }\n";
            reader_code += "                        }\n";
            if es != () {
                let owner_fqn = cur_s.fqn;
                reader_code += "                        var sub = global::Csv." + owner_fqn + "." + es.name + ".FromRowWithHeader(subH, row, gap);\n";
            } else {
                let call_prefix = if call_ns == "" { "global::Csv." } else { "global::Csv." + call_ns + "." };
                reader_code += "                        var sub = " + call_prefix + child_name + ".FromRowWithHeader(subH, row, gap);\n";
            }
            reader_code += "                        list.Add(sub);\n";
            reader_code += "                    }\n";
            reader_code += "                }\n";
            reader_code += "                obj." + f.name + " = list;\n";
            reader_code += "            }\n";
        }
    } else {
        let es = find_embedded_struct(cur_s, base.type_name);
        if es != () {
            reader_code += "        if (!Polygen.Common.CsvUtils.HeaderHasValues(__h, row))\n";
            reader_code += "        {\n";
            reader_code += "            obj." + f.name + " = null;\n";
            reader_code += "        }\n";
            reader_code += "        else\n";
            reader_code += "        {\n";
            let owner_fqn = cur_s.fqn;
            reader_code += "            obj." + f.name + " = global::Csv." + owner_fqn + "." + es.name + ".FromRowWithHeader(__h, row, gap);\n";
            reader_code += "        }\n";
        } else if base.is_primitive || base.lang_type == "string" || base.is_enum {
            let cs_t = cs_type(base.lang_type);
            let generic_t = if base.is_enum { "global::" + base.fqn } else { cs_t };
            reader_code += "        if (__h != null && __h.Index >= 0 && __h.Index < row.Length)\n";
            reader_code += "        {\n";
            reader_code += "            var __cell = row[__h.Index];\n";
            reader_code += "            obj." + f.name + " = DataSourceFactory.ConvertValue<" + generic_t + ">(__cell);\n";
            reader_code += "        }\n";
        } else {
            let call_ns = base.namespace_fqn;
            let child_name = base.type_name;
            let call_prefix = if call_ns == "" { "global::Csv." } else { "global::Csv." + call_ns + "." };
            reader_code += "        if (!Polygen.Common.CsvUtils.HeaderHasValues(__h, row))\n";
            reader_code += "        {\n";
            reader_code += "            obj." + f.name + " = null;\n";
            reader_code += "        }\n";
            reader_code += "        else\n";
            reader_code += "        {\n";
            reader_code += "            obj." + f.name + " = " + call_prefix + child_name + ".FromRowWithHeader(__h, row, gap);\n";
            reader_code += "        }\n";
        }
    }
    reader_code += "        }\n";
} }
reader_code += "        return obj;\n";
reader_code += "    }\n";

// ReadRowsWithHeader
reader_code += "    public static System.Collections.Generic.IEnumerable<" + full_t + "> ReadRowsWithHeader(string path, char sep = ',', Polygen.Common.CsvUtils.GapMode gap = Polygen.Common.CsvUtils.GapMode.Break)\n";
reader_code += "    {\n";
reader_code += "        var lines = File.ReadAllLines(path);\n";
reader_code += "        if (lines.Length == 0)\n";
reader_code += "        {\n";
reader_code += "            yield break;\n";
reader_code += "        }\n";
reader_code += "        var header = lines[0].Split(sep);\n";
reader_code += "        var h = BuildHeader(header, string.Empty);\n";
reader_code += "        for (int i = 1; i < lines.Length; i++)\n";
reader_code += "        {\n";
reader_code += "            var row = lines[i].Split(sep);\n";
reader_code += "            if (!Polygen.Common.CsvUtils.HeaderHasValues(h, row))\n";
reader_code += "            {\n";
reader_code += "                if (gap == Polygen.Common.CsvUtils.GapMode.Break)\n";
reader_code += "                {\n";
reader_code += "                    break;\n";
reader_code += "                }\n";
reader_code += "                else\n";
reader_code += "                {\n";
reader_code += "                    continue;\n";
reader_code += "                }\n";
reader_code += "            }\n";
reader_code += "            yield return FromRowWithHeader(h, row, gap);\n";
reader_code += "        }\n";
reader_code += "    }\n";

// ReadCsvFast alias
reader_code += "    public static System.Collections.Generic.IEnumerable<" + full_t + "> ReadCsvFast(string path, char sep = ',', Polygen.Common.CsvUtils.GapMode gap = Polygen.Common.CsvUtils.GapMode.Break)\n";
reader_code += "        => ReadRowsWithHeader(path, sep, gap);\n";

// ============================================================
// BuildHeader
// ============================================================
let build_header = "";
build_header += "    public static Polygen.Common.CsvIndexHeader BuildHeader(string[] header, string prefix)\n";
build_header += "    {\n";
build_header += "        var map = Polygen.Common.CsvUtils.CsvIndexHeader(header);\n";
build_header += "        var root = new Polygen.Common.CsvIndexHeader();\n";
build_header += "        root.IndexList = new System.Collections.Generic.List<Polygen.Common.CsvIndexHeader>();\n";

for it in cur_s.items { if it.is_field() {
    let f = it.as_field();
    let tf = f.field_type;
    let base = if tf.is_option { tf.inner } else { tf };
    if base.is_list {
        let inner = base.inner;
        build_header += "        {\n";
        build_header += "            var ch = new Polygen.Common.CsvIndexHeader();\n";
        build_header += "            ch.Index = -1;\n";
        build_header += "            ch.IndexList = new System.Collections.Generic.List<Polygen.Common.CsvIndexHeader>();\n";
        if inner.is_primitive || inner.lang_type == "string" || inner.is_enum {
            build_header += "            for (int i=0;;i++)\n";
            build_header += "            {\n";
            build_header += "                int __ix;\n";
            build_header += "                if (!map.TryGetValue(prefix + \"" + f.name + "[\" + i + \"]\", out __ix))\n";
            build_header += "                {\n";
            build_header += "                    break;\n";
            build_header += "                }\n";
            build_header += "                var leaf = new Polygen.Common.CsvIndexHeader();\n";
            build_header += "                leaf.Index = __ix;\n";
            build_header += "                ch.IndexList.Add(leaf);\n";
            build_header += "            }\n";
        } else {
            let es = find_embedded_struct(cur_s, inner.type_name);
            if es != () {
                build_header += "            for (int i=0;;i++)\n";
                build_header += "            {\n";
                let owner_fqn = cur_s.fqn;
                build_header += "                var sub = global::Csv." + owner_fqn + "." + es.name + ".BuildHeader(header, prefix + \"" + f.name + "[\"+i+\"].\");\n";
                build_header += "                if (!sub.HasAny()) break;\n";
                build_header += "                ch.IndexList.Add(sub);\n";
                build_header += "            }\n";
            } else {
                let call_ns = if inner.namespace_fqn == "" { current_ns_name } else { inner.namespace_fqn };
                build_header += "            for (int i=0;;i++)\n";
                build_header += "            {\n";
                build_header += "                var sub = global::Csv." + call_ns + "." + inner.type_name + ".BuildHeader(header, prefix + \"" + f.name + "[\"+i+\"].\");\n";
                build_header += "                if (!sub.HasAny()) break;\n";
                build_header += "                ch.IndexList.Add(sub);\n";
                build_header += "            }\n";
            }
        }
        build_header += "            root.IndexList.Add(ch);\n";
        build_header += "        }\n";
    } else {
        let es = find_embedded_struct(cur_s, base.type_name);
        if es != () {
            let owner_fqn = cur_s.fqn;
            build_header += "        {\n";
            build_header += "            var sub = global::Csv." + owner_fqn + "." + es.name + ".BuildHeader(header, prefix + \"" + f.name + ".\");\n";
            build_header += "            if (sub.HasAny()) root.IndexList.Add(sub);\n";
            build_header += "        }\n";
        } else if base.is_primitive || base.lang_type == "string" || base.is_enum {
            build_header += "        {\n";
            build_header += "            int __ix;\n";
            build_header += "            if (map.TryGetValue(prefix + \"" + f.name + "\", out __ix))\n";
            build_header += "            {\n";
            build_header += "                var leaf = new Polygen.Common.CsvIndexHeader();\n";
            build_header += "                leaf.Index = __ix;\n";
            build_header += "                root.IndexList.Add(leaf);\n";
            build_header += "            }\n";
            build_header += "        }\n";
        } else {
            let call_ns = if base.namespace_fqn == "" { current_ns_name } else { base.namespace_fqn };
            build_header += "        {\n";
            build_header += "            var sub = global::Csv." + call_ns + "." + base.type_name + ".BuildHeader(header, prefix + \"" + f.name + ".\");\n";
            build_header += "            if (sub.HasAny()) root.IndexList.Add(sub);\n";
            build_header += "        }\n";
        }
    }
} }
build_header += "        return root;\n";
build_header += "    }\n";
%endlogic
public static class {{struct.name}}
{
{{header_col_count}}
{{writer_code}}
{{build_write_header}}
{{collect_names}}
{{write_csv}}
{{reader_code}}
{{build_header}}
%for item in struct.items
%if item.is_embedded_struct
%include "csv/mappers_struct_class" with item.as_embedded_struct
%endif
%endfor
}
