// C# SQLite Accessor Generator
// Generates a DbContext-style accessor for @datasource("sqlite") tables
//
// Only runs if schema has @datasource("sqlite") annotations

// Note: cs_map_type is a global Rhai function registered in Rust

// Helper function to join array elements
fn join_with(arr, sep) {
    let result = "";
    let i = 0;
    for item in arr {
        if i > 0 { result += sep; }
        result += item;
        i += 1;
    }
    result
}

// Check if a struct should be included for SQLite
fn is_sqlite_table(struct_datasource, ns_datasource) {
    if struct_datasource != () && struct_datasource != "" {
        return struct_datasource == "sqlite";
    }
    if ns_datasource != () && ns_datasource != "" {
        return ns_datasource == "sqlite";
    }
    return false;  // Only include explicitly marked tables
}

// Collect all SQLite tables
let sqlite_tables = [];

for file in schema.files {
    if file.path == () || file.path == "" { continue; }

    for ns in file.namespaces {
        let ns_datasource = ns.datasource;

        for item in ns.items {
            if item.is_struct() {
                let s = item.as_struct();
                if is_sqlite_table(s.datasource, ns_datasource) {
                    sqlite_tables.push(#{
                        name: s.name,
                        fqn: s.fqn,
                        ns_name: ns.name,
                        struct_def: s
                    });
                }
            }
        }
    }
}

// Only generate if there are SQLite tables
if sqlite_tables.len() == 0 {
    return "";
}

// Generate the accessor code
let code = "// Generated by PolyGen - SQLite Database Accessor\n";
code += "// This file provides DbContext-style access to SQLite tables.\n\n";

code += "using System;\n";
code += "using System.Collections.Generic;\n";
code += "using System.Data;\n";
code += "using Microsoft.Data.Sqlite;\n\n";

code += "namespace Polygen.Data\n{\n";

// Generate DbTable<T> generic class
code += "    /// <summary>\n";
code += "    /// Provides typed access to a SQLite table.\n";
code += "    /// </summary>\n";
code += "    public class DbTable<T> where T : class, new()\n";
code += "    {\n";
code += "        private readonly SqliteConnection _connection;\n";
code += "        private readonly string _tableName;\n";
code += "        private readonly Func<SqliteDataReader, T> _mapper;\n";
code += "        private List<T> _cache = new List<T>();\n\n";

code += "        public DbTable(SqliteConnection connection, string tableName, Func<SqliteDataReader, T> mapper)\n";
code += "        {\n";
code += "            _connection = connection;\n";
code += "            _tableName = tableName;\n";
code += "            _mapper = mapper;\n";
code += "        }\n\n";

code += "        public IReadOnlyList<T> All => _cache;\n\n";

code += "        public void Load()\n";
code += "        {\n";
code += "            _cache.Clear();\n";
code += "            using var cmd = _connection.CreateCommand();\n";
code += "            cmd.CommandText = $\"SELECT * FROM {_tableName}\";\n";
code += "            using var reader = cmd.ExecuteReader();\n";
code += "            while (reader.Read())\n";
code += "            {\n";
code += "                _cache.Add(_mapper(reader));\n";
code += "            }\n";
code += "        }\n\n";

code += "        public T GetById<TKey>(TKey id, string idColumn = \"id\")\n";
code += "        {\n";
code += "            using var cmd = _connection.CreateCommand();\n";
code += "            cmd.CommandText = $\"SELECT * FROM {_tableName} WHERE {idColumn} = @id\";\n";
code += "            cmd.Parameters.AddWithValue(\"@id\", id);\n";
code += "            using var reader = cmd.ExecuteReader();\n";
code += "            if (reader.Read()) return _mapper(reader);\n";
code += "            return null;\n";
code += "        }\n";
code += "    }\n\n";

// Generate the main DbContext class
code += "    /// <summary>\n";
code += "    /// SQLite database context for accessing game data.\n";
code += "    /// </summary>\n";
code += "    public class SqliteDbContext : IDisposable\n";
code += "    {\n";
code += "        private readonly SqliteConnection _connection;\n";
code += "        private bool _disposed = false;\n\n";

// Generate properties for each table
for tbl in sqlite_tables {
    let prop_name = tbl.name + "s";  // Pluralize
    code += "        public DbTable<" + tbl.fqn + "> " + prop_name + " { get; }\n";
}
code += "\n";

// Constructor
code += "        public SqliteDbContext(string connectionString)\n";
code += "        {\n";
code += "            _connection = new SqliteConnection(connectionString);\n";
code += "            _connection.Open();\n\n";

// Initialize each DbTable
for tbl in sqlite_tables {
    let prop_name = tbl.name + "s";
    let ns_prefix = if tbl.ns_name != "" {
        let parts = tbl.ns_name.split(".");
        join_with(parts, "_") + "_"
    } else {
        ""
    };
    let table_name = ns_prefix + tbl.name;

    code += "            " + prop_name + " = new DbTable<" + tbl.fqn + ">(\n";
    code += "                _connection,\n";
    code += "                \"" + table_name + "\",\n";
    code += "                reader => Map" + tbl.name + "(reader));\n\n";
}

code += "        }\n\n";

// LoadAll method
code += "        /// <summary>\n";
code += "        /// Loads all tables into memory.\n";
code += "        /// </summary>\n";
code += "        public void LoadAll()\n";
code += "        {\n";
for tbl in sqlite_tables {
    let prop_name = tbl.name + "s";
    code += "            " + prop_name + ".Load();\n";
}
code += "        }\n\n";

// Generate mapper methods for each table
for tbl in sqlite_tables {
    let s = tbl.struct_def;
    code += "        private static " + tbl.fqn + " Map" + tbl.name + "(SqliteDataReader reader)\n";
    code += "        {\n";
    code += "            return new " + tbl.fqn + "\n";
    code += "            {\n";

    let field_idx = 0;
    for item in s.items {
        if item.is_field() {
            let f = item.as_field();
            let cs_type = cs_map_type(f.field_type);

            // Determine the appropriate reader method
            let reader_method = "";
            if cs_type == "string" {
                reader_method = "reader.GetString";
            } else if cs_type == "int" || cs_type == "Int32" {
                reader_method = "reader.GetInt32";
            } else if cs_type == "uint" || cs_type == "UInt32" {
                reader_method = "(uint)reader.GetInt64";
            } else if cs_type == "long" || cs_type == "Int64" {
                reader_method = "reader.GetInt64";
            } else if cs_type == "ulong" || cs_type == "UInt64" {
                reader_method = "(ulong)reader.GetInt64";
            } else if cs_type == "short" || cs_type == "Int16" {
                reader_method = "reader.GetInt16";
            } else if cs_type == "ushort" || cs_type == "UInt16" {
                reader_method = "(ushort)reader.GetInt32";
            } else if cs_type == "byte" {
                reader_method = "reader.GetByte";
            } else if cs_type == "sbyte" {
                reader_method = "(sbyte)reader.GetInt16";
            } else if cs_type == "float" || cs_type == "Single" {
                reader_method = "reader.GetFloat";
            } else if cs_type == "double" || cs_type == "Double" {
                reader_method = "reader.GetDouble";
            } else if cs_type == "bool" || cs_type == "Boolean" {
                reader_method = "reader.GetBoolean";
            } else {
                reader_method = "reader.GetString";  // fallback
            }

            if field_idx > 0 {
                code += ",\n";
            }
            code += "                " + f.name + " = " + reader_method + "(" + field_idx + ")";
            field_idx += 1;
        }
    }

    code += "\n            };\n";
    code += "        }\n\n";
}

// Dispose
code += "        public void Dispose()\n";
code += "        {\n";
code += "            if (!_disposed)\n";
code += "            {\n";
code += "                _connection?.Dispose();\n";
code += "                _disposed = true;\n";
code += "            }\n";
code += "        }\n";
code += "    }\n";
code += "}\n";

// Helper to remove .poly extension (Rhai replace treats "." as regex)
fn remove_poly_extension(filename) {
    let len = filename.len();
    let poly_len = 5;  // ".poly".len()
    if len > poly_len {
        let suffix_start = len - poly_len;
        let suffix = filename.sub_string(suffix_start, poly_len);
        if suffix == ".poly" {
            return filename.sub_string(0, suffix_start);
        }
    }
    filename
}

// Determine output filename from first file with valid path
let out_filename = "schema.SqliteAccessor.cs";  // default fallback
for file in schema.files {
    let fp = file.path;
    if fp != () && fp != "" {
        // Extract just the filename without directory
        let base_name = fp;
        if fp.contains("/") {
            let parts = fp.split("/");
            base_name = parts[parts.len() - 1];
        }
        // Remove .poly extension and add new extension
        let name_without_ext = remove_poly_extension(base_name);
        out_filename = name_without_ext + ".SqliteAccessor.cs";
        break;
    }
}

let out_path = "output/csharp/" + out_filename;
print("Generating file: " + out_path);
write_file(out_path, code);

""
