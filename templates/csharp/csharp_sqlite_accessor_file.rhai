// C# SQLite Accessor Generator
// Generates a DbContext-style accessor for @datasource("sqlite") tables
// Supports cache strategies: full_load, on_demand, write_through, write_back
//
// Validation behavior:
// - full_load: Validate after LoadAll()
// - on_demand: Validate after loading table and all FK-related tables
// - write_through / write_back: No validation

// Note: cs_map_type is a global Rhai function registered in Rust

// Helper function to join array elements
fn join_with(arr, sep) {
    let result = "";
    let i = 0;
    for item in arr {
        if i > 0 { result += sep; }
        result += item;
        i += 1;
    }
    result
}

// Check if a struct should be included for SQLite
fn is_sqlite_table(struct_datasource, ns_datasource) {
    if struct_datasource != () && struct_datasource != "" {
        return struct_datasource == "sqlite";
    }
    if ns_datasource != () && ns_datasource != "" {
        return ns_datasource == "sqlite";
    }
    return false;
}

// Get cache strategy, default to "full_load" if not specified
fn get_cache_strategy(struct_def) {
    let strategy = struct_def.cache_strategy;
    if strategy == () || strategy == "" {
        return "full_load";
    }
    return strategy;
}

// Collect all SQLite tables with their info
let sqlite_tables = [];
let table_by_name = #{};  // Map: table name -> table info

for file in schema.files {
    if file.path == () || file.path == "" { continue; }

    for ns in file.namespaces {
        let ns_datasource = ns.datasource;

        for item in ns.items {
            if item.is_struct() {
                let s = item.as_struct();
                if is_sqlite_table(s.datasource, ns_datasource) {
                    let cache_strategy = get_cache_strategy(s);

                    // Collect FK dependencies
                    let fk_dependencies = [];
                    for struct_item in s.items {
                        if struct_item.is_field() {
                            let field = struct_item.as_field();
                            if field.has_foreign_key {
                                let fk = field.foreign_key;
                                // Extract target table name from FQN
                                let target_parts = fk.target_table_fqn.split(".");
                                let target_table = "";
                                for part in target_parts {
                                    target_table = part;
                                }
                                fk_dependencies.push(target_table);
                            }
                        }
                    }

                    let tbl_info = #{
                        name: s.name,
                        fqn: s.fqn,
                        ns_name: ns.name,
                        struct_def: s,
                        cache_strategy: cache_strategy,
                        fk_dependencies: fk_dependencies
                    };

                    sqlite_tables.push(tbl_info);
                    table_by_name[s.name] = tbl_info;
                }
            }
        }
    }
}

// Only generate if there are SQLite tables
if sqlite_tables.len() == 0 {
    return "";
}

// Build reverse dependency map (who references me)
let reverse_deps = #{};
for tbl in sqlite_tables {
    reverse_deps[tbl.name] = [];
}
for tbl in sqlite_tables {
    for dep in tbl.fk_dependencies {
        if reverse_deps[dep] != () {
            reverse_deps[dep].push(tbl.name);
        }
    }
}

// Generate the accessor code
let code = "// Generated by PolyGen - SQLite Database Accessor\n";
code += "// This file provides DbContext-style access to SQLite tables.\n";
code += "// Supports cache strategies: full_load, on_demand, write_through, write_back\n\n";

code += "using System;\n";
code += "using System.Collections.Generic;\n";
code += "using System.Data;\n";
code += "using System.Linq;\n";
code += "using Microsoft.Data.Sqlite;\n";
code += "using Polygen.Common;\n\n";

code += "namespace Polygen.Data\n{\n";

// Generate CacheStrategy enum
code += "    /// <summary>\n";
code += "    /// Cache strategy for database tables.\n";
code += "    /// </summary>\n";
code += "    public enum CacheStrategy\n";
code += "    {\n";
code += "        /// <summary>Load all data at startup.</summary>\n";
code += "        FullLoad,\n";
code += "        /// <summary>Load data on first access, including FK dependencies.</summary>\n";
code += "        OnDemand,\n";
code += "        /// <summary>Write changes immediately to database. No validation.</summary>\n";
code += "        WriteThrough,\n";
code += "        /// <summary>Batch writes for later flush. No validation.</summary>\n";
code += "        WriteBack\n";
code += "    }\n\n";

// Generate DbTable<T> generic class with cache strategy support
code += "    /// <summary>\n";
code += "    /// Provides typed access to a SQLite table with cache strategy support.\n";
code += "    /// </summary>\n";
code += "    public class DbTable<T> where T : class, new()\n";
code += "    {\n";
code += "        private readonly SqliteConnection _connection;\n";
code += "        private readonly string _tableName;\n";
code += "        private readonly Func<SqliteDataReader, T> _mapper;\n";
code += "        private readonly CacheStrategy _cacheStrategy;\n";
code += "        private List<T> _cache = new List<T>();\n";
code += "        private bool _isLoaded = false;\n\n";

code += "        public DbTable(SqliteConnection connection, string tableName, Func<SqliteDataReader, T> mapper, CacheStrategy cacheStrategy)\n";
code += "        {\n";
code += "            _connection = connection;\n";
code += "            _tableName = tableName;\n";
code += "            _mapper = mapper;\n";
code += "            _cacheStrategy = cacheStrategy;\n";
code += "        }\n\n";

code += "        public IReadOnlyList<T> All => _cache;\n";
code += "        public bool IsLoaded => _isLoaded;\n";
code += "        public CacheStrategy Strategy => _cacheStrategy;\n\n";

code += "        /// <summary>\n";
code += "        /// Loads all data from the table into cache.\n";
code += "        /// </summary>\n";
code += "        public void Load()\n";
code += "        {\n";
code += "            if (_isLoaded) return;\n";
code += "            _cache.Clear();\n";
code += "            using var cmd = _connection.CreateCommand();\n";
code += "            cmd.CommandText = $\"SELECT * FROM {_tableName}\";\n";
code += "            using var reader = cmd.ExecuteReader();\n";
code += "            while (reader.Read())\n";
code += "            {\n";
code += "                _cache.Add(_mapper(reader));\n";
code += "            }\n";
code += "            _isLoaded = true;\n";
code += "        }\n\n";

code += "        /// <summary>\n";
code += "        /// Clears the cache and resets loaded state.\n";
code += "        /// </summary>\n";
code += "        public void Reset()\n";
code += "        {\n";
code += "            _cache.Clear();\n";
code += "            _isLoaded = false;\n";
code += "        }\n\n";

code += "        public T GetById<TKey>(TKey id, string idColumn = \"id\")\n";
code += "        {\n";
code += "            using var cmd = _connection.CreateCommand();\n";
code += "            cmd.CommandText = $\"SELECT * FROM {_tableName} WHERE {idColumn} = @id\";\n";
code += "            cmd.Parameters.AddWithValue(\"@id\", id);\n";
code += "            using var reader = cmd.ExecuteReader();\n";
code += "            if (reader.Read()) return _mapper(reader);\n";
code += "            return null;\n";
code += "        }\n";
code += "    }\n\n";

// Generate the main DbContext class
code += "    /// <summary>\n";
code += "    /// SQLite database context with cache strategy support.\n";
code += "    /// </summary>\n";
code += "    public class SqliteDbContext : IDisposable\n";
code += "    {\n";
code += "        private readonly SqliteConnection _connection;\n";
code += "        private bool _disposed = false;\n\n";

// Generate properties for each table
for tbl in sqlite_tables {
    let prop_name = tbl.name + "s";
    code += "        public DbTable<" + tbl.fqn + "> " + prop_name + " { get; }\n";
}
code += "\n";

// Constructor
code += "        public SqliteDbContext(string connectionString)\n";
code += "        {\n";
code += "            _connection = new SqliteConnection(connectionString);\n";
code += "            _connection.Open();\n\n";

// Initialize each DbTable with cache strategy
for tbl in sqlite_tables {
    let prop_name = tbl.name + "s";
    let ns_prefix = if tbl.ns_name != "" {
        let parts = tbl.ns_name.split(".");
        join_with(parts, "_") + "_"
    } else {
        ""
    };
    let table_name = ns_prefix + tbl.name;

    let strategy_enum = switch tbl.cache_strategy {
        "full_load" => "CacheStrategy.FullLoad",
        "on_demand" => "CacheStrategy.OnDemand",
        "write_through" => "CacheStrategy.WriteThrough",
        "write_back" => "CacheStrategy.WriteBack",
        _ => "CacheStrategy.FullLoad"
    };

    code += "            " + prop_name + " = new DbTable<" + tbl.fqn + ">(\n";
    code += "                _connection,\n";
    code += "                \"" + table_name + "\",\n";
    code += "                reader => Map" + tbl.name + "(reader),\n";
    code += "                " + strategy_enum + ");\n\n";
}

code += "        }\n\n";

// LoadAll method - only loads full_load tables
code += "        /// <summary>\n";
code += "        /// Loads all tables with FullLoad cache strategy.\n";
code += "        /// </summary>\n";
code += "        public void LoadAll()\n";
code += "        {\n";
for tbl in sqlite_tables {
    if tbl.cache_strategy == "full_load" || tbl.cache_strategy == () || tbl.cache_strategy == "" {
        let prop_name = tbl.name + "s";
        code += "            " + prop_name + ".Load();\n";
    }
}
code += "        }\n\n";

// LoadAllAndValidate - loads full_load tables and validates
code += "        /// <summary>\n";
code += "        /// Loads all FullLoad tables and validates them.\n";
code += "        /// </summary>\n";
code += "        public ValidationResult LoadAllAndValidate()\n";
code += "        {\n";
code += "            LoadAll();\n";
code += "            return ValidateFullLoadTables();\n";
code += "        }\n\n";

// Generate LoadWithDependencies for each on_demand table
for tbl in sqlite_tables {
    if tbl.cache_strategy == "on_demand" {
        let method_name = "Load" + tbl.name + "WithDependencies";

        // Collect all dependencies recursively (simplified: direct deps only for now)
        let all_deps = [];
        for dep in tbl.fk_dependencies {
            if table_by_name[dep] != () {
                all_deps.push(dep);
            }
        }

        code += "        /// <summary>\n";
        code += "        /// Loads " + tbl.name + " and all FK-related tables, then validates.\n";
        code += "        /// Related tables: " + (if all_deps.len() > 0 { join_with(all_deps, ", ") } else { "(none)" }) + "\n";
        code += "        /// </summary>\n";
        code += "        public ValidationResult " + method_name + "()\n";
        code += "        {\n";

        // Load dependencies first
        for dep in all_deps {
            code += "            " + dep + "s.Load();\n";
        }

        // Load the main table
        code += "            " + tbl.name + "s.Load();\n\n";

        // Validate
        code += "            return ValidateLoadedTables();\n";
        code += "        }\n\n";
    }
}

// ValidateFullLoadTables - validates only full_load tables
code += "        /// <summary>\n";
code += "        /// Validates all tables with FullLoad cache strategy.\n";
code += "        /// </summary>\n";
code += "        public ValidationResult ValidateFullLoadTables()\n";
code += "        {\n";
code += "            var result = new ValidationResult();\n";

for tbl in sqlite_tables {
    if tbl.cache_strategy == "full_load" || tbl.cache_strategy == () || tbl.cache_strategy == "" {
        let s = tbl.struct_def;
        let prop_name = tbl.name + "s";

        // Find primary key field
        let pk_field = "";
        for item in s.items {
            if item.is_field() {
                let field = item.as_field();
                if field.is_primary_key {
                    pk_field = field.name;
                }
            }
        }

        let has_validations = false;
        for item in s.items {
            if item.is_field() {
                let field = item.as_field();
                if field.has_max_length || field.has_range || field.has_regex_pattern {
                    has_validations = true;
                }
            }
        }

        if has_validations {
            code += "\n            // Validate " + tbl.name + " (FullLoad)\n";
            code += "            foreach (var row in " + prop_name + ".All)\n";
            code += "            {\n";

            let key_expr = if pk_field != "" { "row." + pk_field } else { "null" };

            for item in s.items {
                if item.is_field() {
                    let field = item.as_field();
                    let ft = field.field_type;

                    if field.has_max_length {
                        let max_len = field.max_length;
                        code += "                if (row." + field.name + " != null && row." + field.name + ".Length > " + max_len + ")\n";
                        code += "                    result.AddError(ValidationHelpers.MaxLengthError(\"" + tbl.name + "\", \"" + field.name + "\", " + key_expr + ", " + max_len + ", row." + field.name + ".Length));\n";
                    }

                    if field.has_range {
                        let range = field.range;
                        if ft.is_option {
                            code += "                if (row." + field.name + ".HasValue && !ValidationHelpers.ValidateRange(row." + field.name + ".Value, " + range.min + ", " + range.max + "))\n";
                        } else {
                            code += "                if (!ValidationHelpers.ValidateRange(row." + field.name + ", " + range.min + ", " + range.max + "))\n";
                        }
                        code += "                    result.AddError(ValidationHelpers.RangeError(\"" + tbl.name + "\", \"" + field.name + "\", " + key_expr + ", " + range.min + ", " + range.max + ", row." + field.name + "));\n";
                    }

                    if field.has_regex_pattern {
                        let pattern = field.regex_pattern;
                        code += "                if (!ValidationHelpers.ValidateRegex(row." + field.name + ", @\"" + pattern + "\"))\n";
                        code += "                    result.AddError(ValidationHelpers.RegexError(\"" + tbl.name + "\", \"" + field.name + "\", " + key_expr + ", @\"" + pattern + "\", row." + field.name + "));\n";
                    }
                }
            }
            code += "            }\n";
        }
    }
}

code += "\n            // Validate FK references for FullLoad tables\n";
code += "            result.Merge(ValidateFullLoadForeignKeys());\n";
code += "            return result;\n";
code += "        }\n\n";

// ValidateLoadedTables - validates all currently loaded tables
code += "        /// <summary>\n";
code += "        /// Validates all currently loaded tables (for on_demand scenarios).\n";
code += "        /// Skips write_through and write_back tables.\n";
code += "        /// </summary>\n";
code += "        public ValidationResult ValidateLoadedTables()\n";
code += "        {\n";
code += "            var result = new ValidationResult();\n";

for tbl in sqlite_tables {
    // Skip write_through and write_back
    if tbl.cache_strategy == "write_through" || tbl.cache_strategy == "write_back" {
        continue;
    }

    let s = tbl.struct_def;
    let prop_name = tbl.name + "s";

    let pk_field = "";
    for item in s.items {
        if item.is_field() {
            let field = item.as_field();
            if field.is_primary_key {
                pk_field = field.name;
            }
        }
    }

    let has_validations = false;
    for item in s.items {
        if item.is_field() {
            let field = item.as_field();
            if field.has_max_length || field.has_range || field.has_regex_pattern {
                has_validations = true;
            }
        }
    }

    if has_validations {
        code += "\n            // Validate " + tbl.name + " (if loaded)\n";
        code += "            if (" + prop_name + ".IsLoaded)\n";
        code += "            {\n";
        code += "                foreach (var row in " + prop_name + ".All)\n";
        code += "                {\n";

        let key_expr = if pk_field != "" { "row." + pk_field } else { "null" };

        for item in s.items {
            if item.is_field() {
                let field = item.as_field();
                let ft = field.field_type;

                if field.has_max_length {
                    let max_len = field.max_length;
                    code += "                    if (row." + field.name + " != null && row." + field.name + ".Length > " + max_len + ")\n";
                    code += "                        result.AddError(ValidationHelpers.MaxLengthError(\"" + tbl.name + "\", \"" + field.name + "\", " + key_expr + ", " + max_len + ", row." + field.name + ".Length));\n";
                }

                if field.has_range {
                    let range = field.range;
                    if ft.is_option {
                        code += "                    if (row." + field.name + ".HasValue && !ValidationHelpers.ValidateRange(row." + field.name + ".Value, " + range.min + ", " + range.max + "))\n";
                    } else {
                        code += "                    if (!ValidationHelpers.ValidateRange(row." + field.name + ", " + range.min + ", " + range.max + "))\n";
                    }
                    code += "                        result.AddError(ValidationHelpers.RangeError(\"" + tbl.name + "\", \"" + field.name + "\", " + key_expr + ", " + range.min + ", " + range.max + ", row." + field.name + "));\n";
                }

                if field.has_regex_pattern {
                    let pattern = field.regex_pattern;
                    code += "                    if (!ValidationHelpers.ValidateRegex(row." + field.name + ", @\"" + pattern + "\"))\n";
                    code += "                        result.AddError(ValidationHelpers.RegexError(\"" + tbl.name + "\", \"" + field.name + "\", " + key_expr + ", @\"" + pattern + "\", row." + field.name + "));\n";
                }
            }
        }
        code += "                }\n";
        code += "            }\n";
    }
}

code += "\n            // Validate FK references for loaded tables\n";
code += "            result.Merge(ValidateLoadedForeignKeys());\n";
code += "            return result;\n";
code += "        }\n\n";

// ValidateFullLoadForeignKeys - FK validation for full_load tables
code += "        /// <summary>\n";
code += "        /// Validates FK references for FullLoad tables using SQL.\n";
code += "        /// </summary>\n";
code += "        public ValidationResult ValidateFullLoadForeignKeys()\n";
code += "        {\n";
code += "            var result = new ValidationResult();\n";

for tbl in sqlite_tables {
    if tbl.cache_strategy != "full_load" && tbl.cache_strategy != () && tbl.cache_strategy != "" {
        continue;
    }

    let s = tbl.struct_def;
    let ns_prefix = if tbl.ns_name != "" {
        let parts = tbl.ns_name.split(".");
        join_with(parts, "_") + "_"
    } else {
        ""
    };
    let source_table_name = ns_prefix + tbl.name;

    let pk_field = "";
    for item in s.items {
        if item.is_field() {
            let field = item.as_field();
            if field.is_primary_key {
                pk_field = field.name;
            }
        }
    }

    for item in s.items {
        if item.is_field() {
            let field = item.as_field();
            if field.has_foreign_key {
                let fk = field.foreign_key;

                let target_parts = fk.target_table_fqn.split(".");
                let target_table = "";
                for part in target_parts {
                    target_table = part;
                }

                let target_ns_parts = [];
                let target_fqn_parts = fk.target_table_fqn.split(".");
                for i in 0..(target_fqn_parts.len() - 1) {
                    target_ns_parts.push(target_fqn_parts[i]);
                }
                let target_ns_prefix = if target_ns_parts.len() > 0 { join_with(target_ns_parts, "_") + "_" } else { "" };
                let target_table_full = target_ns_prefix + target_table;

                code += "\n            // FK: " + tbl.name + "." + field.name + " -> " + target_table + "\n";
                code += "            using (var cmd = _connection.CreateCommand())\n";
                code += "            {\n";
                code += "                cmd.CommandText = @\"\n";
                code += "                    SELECT s." + field.name;
                if pk_field != "" {
                    code += ", s." + pk_field;
                }
                code += "\n";
                code += "                    FROM " + source_table_name + " s\n";
                code += "                    LEFT JOIN " + target_table_full + " t ON s." + field.name + " = t." + fk.target_field + "\n";
                code += "                    WHERE t." + fk.target_field + " IS NULL";
                if field.field_type.is_option {
                    code += " AND s." + field.name + " IS NOT NULL";
                }
                code += "\";\n";
                code += "                using var reader = cmd.ExecuteReader();\n";
                code += "                while (reader.Read())\n";
                code += "                {\n";
                code += "                    var fkValue = reader.GetValue(0);\n";
                if pk_field != "" {
                    code += "                    var pkValue = reader.GetValue(1);\n";
                    code += "                    result.AddError(ValidationHelpers.ForeignKeyError(\"" + tbl.name + "\", \"" + field.name + "\", pkValue, \"" + target_table + "\", fkValue));\n";
                } else {
                    code += "                    result.AddError(ValidationHelpers.ForeignKeyError(\"" + tbl.name + "\", \"" + field.name + "\", null, \"" + target_table + "\", fkValue));\n";
                }
                code += "                }\n";
                code += "            }\n";
            }
        }
    }
}

code += "\n            return result;\n";
code += "        }\n\n";

// ValidateLoadedForeignKeys - FK validation for loaded on_demand tables
code += "        /// <summary>\n";
code += "        /// Validates FK references for currently loaded tables (on_demand).\n";
code += "        /// Uses in-memory validation since related tables should also be loaded.\n";
code += "        /// </summary>\n";
code += "        public ValidationResult ValidateLoadedForeignKeys()\n";
code += "        {\n";
code += "            var result = new ValidationResult();\n";

for tbl in sqlite_tables {
    // Skip write_through and write_back
    if tbl.cache_strategy == "write_through" || tbl.cache_strategy == "write_back" {
        continue;
    }

    let s = tbl.struct_def;
    let prop_name = tbl.name + "s";

    let pk_field = "";
    for item in s.items {
        if item.is_field() {
            let field = item.as_field();
            if field.is_primary_key {
                pk_field = field.name;
            }
        }
    }

    // Check for FK fields
    let has_fk = false;
    for item in s.items {
        if item.is_field() {
            let field = item.as_field();
            if field.has_foreign_key {
                has_fk = true;
            }
        }
    }

    if has_fk {
        code += "\n            // FK validation for " + tbl.name + " (if loaded)\n";
        code += "            if (" + prop_name + ".IsLoaded)\n";
        code += "            {\n";
        code += "                foreach (var row in " + prop_name + ".All)\n";
        code += "                {\n";

        let key_expr = if pk_field != "" { "row." + pk_field } else { "null" };

        for item in s.items {
            if item.is_field() {
                let field = item.as_field();
                if field.has_foreign_key {
                    let fk = field.foreign_key;
                    let target_parts = fk.target_table_fqn.split(".");
                    let target_table = "";
                    for part in target_parts {
                        target_table = part;
                    }

                    code += "                    // Check FK: " + field.name + " -> " + target_table + "\n";
                    code += "                    if (" + target_table + "s.IsLoaded)\n";
                    code += "                    {\n";
                    if field.field_type.is_option {
                        code += "                        if (row." + field.name + ".HasValue && !" + target_table + "s.All.Any(t => t." + fk.target_field + " == row." + field.name + ".Value))\n";
                    } else {
                        code += "                        if (!" + target_table + "s.All.Any(t => t." + fk.target_field + " == row." + field.name + "))\n";
                    }
                    code += "                            result.AddError(ValidationHelpers.ForeignKeyError(\"" + tbl.name + "\", \"" + field.name + "\", " + key_expr + ", \"" + target_table + "\", row." + field.name + "));\n";
                    code += "                    }\n";
                }
            }
        }

        code += "                }\n";
        code += "            }\n";
    }
}

code += "\n            return result;\n";
code += "        }\n\n";

// ValidateOrThrow
code += "        /// <summary>\n";
code += "        /// Validates all loaded data and throws if errors are found.\n";
code += "        /// </summary>\n";
code += "        public void ValidateOrThrow()\n";
code += "        {\n";
code += "            var result = ValidateLoadedTables();\n";
code += "            if (!result.IsValid)\n";
code += "                throw new ValidationException(result);\n";
code += "        }\n\n";

// Generate mapper methods for each table
for tbl in sqlite_tables {
    let s = tbl.struct_def;
    code += "        private static " + tbl.fqn + " Map" + tbl.name + "(SqliteDataReader reader)\n";
    code += "        {\n";
    code += "            return new " + tbl.fqn + "\n";
    code += "            {\n";

    let field_idx = 0;
    for item in s.items {
        if item.is_field() {
            let f = item.as_field();
            let cs_type = cs_map_type(f.field_type);

            let reader_method = "";
            if cs_type == "string" {
                reader_method = "reader.IsDBNull(" + field_idx + ") ? null : reader.GetString";
            } else if cs_type == "int" || cs_type == "Int32" {
                reader_method = "reader.GetInt32";
            } else if cs_type == "uint" || cs_type == "UInt32" {
                reader_method = "(uint)reader.GetInt64";
            } else if cs_type == "long" || cs_type == "Int64" {
                reader_method = "reader.GetInt64";
            } else if cs_type == "ulong" || cs_type == "UInt64" {
                reader_method = "(ulong)reader.GetInt64";
            } else if cs_type == "short" || cs_type == "Int16" {
                reader_method = "reader.GetInt16";
            } else if cs_type == "ushort" || cs_type == "UInt16" {
                reader_method = "(ushort)reader.GetInt32";
            } else if cs_type == "byte" {
                reader_method = "reader.GetByte";
            } else if cs_type == "sbyte" {
                reader_method = "(sbyte)reader.GetInt16";
            } else if cs_type == "float" || cs_type == "Single" {
                reader_method = "reader.GetFloat";
            } else if cs_type == "double" || cs_type == "Double" {
                reader_method = "reader.GetDouble";
            } else if cs_type == "bool" || cs_type == "Boolean" {
                reader_method = "reader.GetBoolean";
            } else {
                reader_method = "reader.IsDBNull(" + field_idx + ") ? null : reader.GetString";
            }

            if field_idx > 0 {
                code += ",\n";
            }

            if reader_method.contains("IsDBNull") {
                code += "                " + f.name + " = " + reader_method + "(" + field_idx + ")";
            } else {
                code += "                " + f.name + " = " + reader_method + "(" + field_idx + ")";
            }
            field_idx += 1;
        }
    }

    code += "\n            };\n";
    code += "        }\n\n";
}

// Dispose
code += "        public void Dispose()\n";
code += "        {\n";
code += "            if (!_disposed)\n";
code += "            {\n";
code += "                _connection?.Dispose();\n";
code += "                _disposed = true;\n";
code += "            }\n";
code += "        }\n";
code += "    }\n";
code += "}\n";

// Helper to remove .poly extension
fn remove_poly_extension(filename) {
    let len = filename.len();
    let poly_len = 5;
    if len > poly_len {
        let suffix_start = len - poly_len;
        let suffix = filename.sub_string(suffix_start, poly_len);
        if suffix == ".poly" {
            return filename.sub_string(0, suffix_start);
        }
    }
    filename
}

// Determine output filename
let out_filename = "schema.SqliteAccessor.cs";
for file in schema.files {
    let fp = file.path;
    if fp != () && fp != "" {
        let base_name = fp;
        if fp.contains("/") {
            let parts = fp.split("/");
            base_name = parts[parts.len() - 1];
        }
        let name_without_ext = remove_poly_extension(base_name);
        out_filename = name_without_ext + ".SqliteAccessor.cs";
        break;
    }
}

let out_path = output_dir + "/csharp/" + out_filename;
print("Generating file: " + out_path);
write_file(out_path, code);

""
