---
source: tests/snapshot_tests.rs
expression: content
---
"using System;\nusing System.Collections.Generic;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\nusing System.Globalization;\nusing System.IO;\nusing System.Text;\nusing Polygen.Common;\nnamespace Csv.test.csv\n{\n\tpublic static class Point\n\t{\n\t        private static int HeaderColumnCount(Polygen.Common.CsvIndexHeader h)\n\t        {\n\t            if (h.Index >= 0)\n\t            {\n\t                return 1;\n\t            }\n\t            int n = 0;\n\t            if (h.IndexList != null)\n\t            {\n\t                for (int i = 0; i < h.IndexList.Count; i++)\n\t                {\n\t                    n += HeaderColumnCount(h.IndexList[i]);\n\t                }\n\t            }\n\t            return n;\n\t        }\n\t        public static void AppendRowWithHeader(Polygen.Common.CsvIndexHeader h, in global::test.csv.Point obj, List<string> cols, Polygen.Common.CsvUtils.GapMode gap = Polygen.Common.CsvUtils.GapMode.Break)\n\t        {\n\t            int __idx = 0;\n\t            {\n\t                var __h = (h != null && h.IndexList != null && __idx < h.IndexList.Count) ? h.IndexList[__idx++] : null;\n\t              if (__h != null && __h.Index >= 0)\n\t              {\n\t                  cols.Add(Polygen.Common.CsvUtils.ToStringInvariant(obj.x));\n\t              }\n\t              else\n\t              {\n\t                  cols.Add(string.Empty);\n\t              }\n\t            }\n\t            {\n\t                var __h = (h != null && h.IndexList != null && __idx < h.IndexList.Count) ? h.IndexList[__idx++] : null;\n\t              if (__h != null && __h.Index >= 0)\n\t              {\n\t                  cols.Add(Polygen.Common.CsvUtils.ToStringInvariant(obj.y));\n\t              }\n\t              else\n\t              {\n\t                  cols.Add(string.Empty);\n\t              }\n\t            }\n\t        }\n\t        public static string[] ToRowWithHeader(Polygen.Common.CsvIndexHeader h, in global::test.csv.Point obj, Polygen.Common.CsvUtils.GapMode gap = Polygen.Common.CsvUtils.GapMode.Break) { var list = new List<string>(); AppendRowWithHeader(h, obj, list, gap); return list.ToArray(); }\n\t        public static Polygen.Common.CsvIndexHeader BuildWriteHeaderFromItems(System.Collections.Generic.IEnumerable<global::test.csv.Point> items)\n\t        {\n\t            var root = new Polygen.Common.CsvIndexHeader { Index = -1, IndexList = new System.Collections.Generic.List<Polygen.Common.CsvIndexHeader>() };\n\t            var __nonList = new System.Collections.Generic.List<Polygen.Common.CsvIndexHeader>();\n\t            __nonList.Add(new Polygen.Common.CsvIndexHeader { Index = 0 });\n\t            __nonList.Add(new Polygen.Common.CsvIndexHeader { Index = 0 });\n\t            foreach (var n in __nonList)\n\t            {\n\t                root.IndexList.Add(n);\n\t            }\n\t            return root;\n\t        }\n\t        public static void CollectWriteHeaderNames(Polygen.Common.CsvIndexHeader h, string prefix, System.Collections.Generic.List<string> names)\n\t        {\n\t            int __idx = 0;\n\t            {\n\t                var __h = (h != null && h.IndexList != null && __idx < h.IndexList.Count) ? h.IndexList[__idx++] : null;\n\t              names.Add((prefix==string.Empty? \"x\" : prefix + \"x\"));\n\t            }\n\t            {\n\t                var __h = (h != null && h.IndexList != null && __idx < h.IndexList.Count) ? h.IndexList[__idx++] : null;\n\t              names.Add((prefix==string.Empty? \"y\" : prefix + \"y\"));\n\t            }\n\t        }\n\t        public static void WriteCsv(System.Collections.Generic.IEnumerable<global::test.csv.Point> items, string path, char sep = ',', Polygen.Common.CsvUtils.GapMode gap = Polygen.Common.CsvUtils.GapMode.Break)\n\t        {\n\t            var list = new System.Collections.Generic.List<global::test.csv.Point>(); foreach (var it in items) list.Add(it);\n\t            var h = BuildWriteHeaderFromItems(list);\n\t            var names = new System.Collections.Generic.List<string>(); CollectWriteHeaderNames(h, string.Empty, names);\n\t            using var sw = new StreamWriter(path, false, new UTF8Encoding(false));\n\t            sw.WriteLine(Polygen.Common.CsvUtils.Join(names, sep));\n\t            foreach (var it in list)\n\t            {\n\t                var row = ToRowWithHeader(h, it, gap);\n\t                sw.WriteLine(Polygen.Common.CsvUtils.Join(row, sep));\n\t            }\n\t        }\n\t        public static void WriteCsvWithHeader(IEnumerable<global::test.csv.Point> items, string path, string[] header, char sep = ',', Polygen.Common.CsvUtils.GapMode gap = Polygen.Common.CsvUtils.GapMode.Break)\n\t        {\n\t            var h = BuildHeader(header, string.Empty);\n\t            using var sw = new StreamWriter(path, false, new UTF8Encoding(false));\n\t            sw.WriteLine(Polygen.Common.CsvUtils.Join(header, sep));\n\t            foreach (var it in items)\n\t            {\n\t                var row = ToRowWithHeader(h, it, gap);\n\t                sw.WriteLine(Polygen.Common.CsvUtils.Join(row, sep));\n\t            }\n\t        }\n\t        public static Polygen.Common.CsvIndexHeader BuildHeader(string[] header, string prefix)\n\t        {\n\t            var map = Polygen.Common.CsvUtils.CsvIndexHeader(header);\n\t            var root = new Polygen.Common.CsvIndexHeader();\n\t            root.IndexList = new System.Collections.Generic.List<Polygen.Common.CsvIndexHeader>();\n\t            {\n\t                int __ix;\n\t                if (map.TryGetValue(prefix + \"x\", out __ix))\n\t                {\n\t                    var leaf = new Polygen.Common.CsvIndexHeader();\n\t                    leaf.Index = __ix;\n\t                    root.IndexList.Add(leaf);\n\t                }\n\t            }\n\t            {\n\t                int __ix;\n\t                if (map.TryGetValue(prefix + \"y\", out __ix))\n\t                {\n\t                    var leaf = new Polygen.Common.CsvIndexHeader();\n\t                    leaf.Index = __ix;\n\t                    root.IndexList.Add(leaf);\n\t                }\n\t            }\n\t            return root;\n\t        }\n\n\t        public static global::test.csv.Point FromRowWithHeader(Polygen.Common.CsvIndexHeader h, string[] row, Polygen.Common.CsvUtils.GapMode gap)\n\t        {\n\t            var obj = new global::test.csv.Point();\n\t            int __i = 0;\n\t            {\n\t                var __h = (h != null && h.IndexList != null && __i < h.IndexList.Count) ? h.IndexList[__i++] : null;\n\t            if (__h != null && __h.Index >= 0 && __h.Index < row.Length)\n\t            {\n\t                var __cell = row[__h.Index];\n\t                obj.x = DataSourceFactory.ConvertValue<int>(__cell);\n\t            }\n\t            }\n\t            {\n\t                var __h = (h != null && h.IndexList != null && __i < h.IndexList.Count) ? h.IndexList[__i++] : null;\n\t            if (__h != null && __h.Index >= 0 && __h.Index < row.Length)\n\t            {\n\t                var __cell = row[__h.Index];\n\t                obj.y = DataSourceFactory.ConvertValue<int>(__cell);\n\t            }\n\t            }\n\t            return obj;\n\t        }\n\t        public static System.Collections.Generic.IEnumerable<global::test.csv.Point> ReadRowsWithHeader(string path, char sep = ',', Polygen.Common.CsvUtils.GapMode gap = Polygen.Common.CsvUtils.GapMode.Break)\n\t        {\n\t            var lines = File.ReadAllLines(path);\n\t            if (lines.Length == 0)\n\t            {\n\t                yield break;\n\t            }\n\t            var header = lines[0].Split(sep);\n\t            var h = BuildHeader(header, string.Empty);\n\t            for (int i = 1; i < lines.Length; i++)\n\t            {\n\t                var row = lines[i].Split(sep);\n\t                if (!Polygen.Common.CsvUtils.HeaderHasValues(h, row))\n\t                {\n\t                    if (gap == Polygen.Common.CsvUtils.GapMode.Break)\n\t                    {\n\t                        break;\n\t                    }\n\t                    else\n\t                    {\n\t                        continue;\n\t                    }\n\t                }\n\t                yield return FromRowWithHeader(h, row, gap);\n\t            }\n\t        }\n\t        public static System.Collections.Generic.IEnumerable<global::test.csv.Point> ReadCsvFast(string path, char sep = ',', Polygen.Common.CsvUtils.GapMode gap = Polygen.Common.CsvUtils.GapMode.Break)\n\t            => ReadRowsWithHeader(path, sep, gap);\n\n\t}\n\n\n\tpublic static class TestObject\n\t{\n\t        private static int HeaderColumnCount(Polygen.Common.CsvIndexHeader h)\n\t        {\n\t            if (h.Index >= 0)\n\t            {\n\t                return 1;\n\t            }\n\t            int n = 0;\n\t            if (h.IndexList != null)\n\t            {\n\t                for (int i = 0; i < h.IndexList.Count; i++)\n\t                {\n\t                    n += HeaderColumnCount(h.IndexList[i]);\n\t                }\n\t            }\n\t            return n;\n\t        }\n\t        public static void AppendRowWithHeader(Polygen.Common.CsvIndexHeader h, in global::test.csv.TestObject obj, List<string> cols, Polygen.Common.CsvUtils.GapMode gap = Polygen.Common.CsvUtils.GapMode.Break)\n\t        {\n\t            int __idx = 0;\n\t            {\n\t                var __h = (h != null && h.IndexList != null && __idx < h.IndexList.Count) ? h.IndexList[__idx++] : null;\n\t              if (__h != null && __h.Index >= 0)\n\t              {\n\t                  cols.Add(Polygen.Common.CsvUtils.ToStringInvariant(obj.id));\n\t              }\n\t              else\n\t              {\n\t                  cols.Add(string.Empty);\n\t              }\n\t            }\n\t            {\n\t                var __h = (h != null && h.IndexList != null && __idx < h.IndexList.Count) ? h.IndexList[__idx++] : null;\n\t              if (__h != null && __h.Index >= 0)\n\t              {\n\t                  cols.Add(Polygen.Common.CsvUtils.ToStringInvariant(obj.name));\n\t              }\n\t              else\n\t              {\n\t                  cols.Add(string.Empty);\n\t              }\n\t            }\n\t            {\n\t                var __h = (h != null && h.IndexList != null && __idx < h.IndexList.Count) ? h.IndexList[__idx++] : null;\n\t              if (__h != null && __h.Index >= 0)\n\t              {\n\t                  cols.Add(Polygen.Common.CsvUtils.ToStringInvariant(obj.active));\n\t              }\n\t              else\n\t              {\n\t                  cols.Add(string.Empty);\n\t              }\n\t            }\n\t            {\n\t                var __h = (h != null && h.IndexList != null && __idx < h.IndexList.Count) ? h.IndexList[__idx++] : null;\n\t              if (__h != null && __h.Index >= 0)\n\t              {\n\t                  cols.Add(Polygen.Common.CsvUtils.ToStringInvariant(obj.score));\n\t              }\n\t              else\n\t              {\n\t                  cols.Add(string.Empty);\n\t              }\n\t            }\n\t            {\n\t                var __h = (h != null && h.IndexList != null && __idx < h.IndexList.Count) ? h.IndexList[__idx++] : null;\n\t              if (__h != null && __h.Index >= 0)\n\t              {\n\t                  cols.Add(obj.color.ToString());\n\t              }\n\t              else if (__h != null && __h.IndexList != null)\n\t              {\n\t                  int pad = HeaderColumnCount(__h);\n\t                  for (int k = 0; k < pad; k++)\n\t                  {\n\t                      cols.Add(string.Empty);\n\t                  }\n\t              }\n\t              else\n\t              {\n\t                  cols.Add(string.Empty);\n\t              }\n\t            }\n\t            {\n\t                var __h = (h != null && h.IndexList != null && __idx < h.IndexList.Count) ? h.IndexList[__idx++] : null;\n\t              if (__h != null && __h.IndexList != null)\n\t              {\n\t                  if (obj.location != null)\n\t                  {\n\t                      global::Csv.test.csv.Point.AppendRowWithHeader(__h, obj.location, cols, gap);\n\t                  }\n\t                  else\n\t                  {\n\t                      int pad = HeaderColumnCount(__h); for (int k=0;k<pad;k++) cols.Add(string.Empty);\n\t                  }\n\t              }\n\t              else\n\t              {\n\t                  cols.Add(string.Empty);\n\t              }\n\t            }\n\t            {\n\t                var __h = (h != null && h.IndexList != null && __idx < h.IndexList.Count) ? h.IndexList[__idx++] : null;\n\t              int count = (__h != null && __h.IndexList != null) ? __h.IndexList.Count : 0; \n\t              for (int j=0;j<count;j++)\n\t              {\n\t                if (obj.tags != null && j < obj.tags.Count)\n\t                {\n\t                    var v = obj.tags[j];\n\t                    cols.Add(Polygen.Common.CsvUtils.ToStringInvariant(v));\n\t                }\n\t                else\n\t                {\n\t                    cols.Add(string.Empty);\n\t                }\n\t              }\n\t            }\n\t            {\n\t                var __h = (h != null && h.IndexList != null && __idx < h.IndexList.Count) ? h.IndexList[__idx++] : null;\n\t              int count = (__h != null && __h.IndexList != null) ? __h.IndexList.Count : 0; \n\t              for (int j=0;j<count;j++)\n\t              {\n\t                  var subH = __h.IndexList[j]; \n\t                  if (obj.history != null && j < obj.history.Count && obj.history[j] != null)\n\t                  {\n\t                      var sub = obj.history[j];\n\t                      global::Csv.test.csv.Point.AppendRowWithHeader(subH, sub, cols, gap);\n\t                  }\n\t                  else\n\t                  {\n\t                      int pad = HeaderColumnCount(subH); for (int k=0;k<pad;k++) cols.Add(string.Empty);\n\t                  }\n\t              }\n\t            }\n\t        }\n\t        public static string[] ToRowWithHeader(Polygen.Common.CsvIndexHeader h, in global::test.csv.TestObject obj, Polygen.Common.CsvUtils.GapMode gap = Polygen.Common.CsvUtils.GapMode.Break) { var list = new List<string>(); AppendRowWithHeader(h, obj, list, gap); return list.ToArray(); }\n\t        public static Polygen.Common.CsvIndexHeader BuildWriteHeaderFromItems(System.Collections.Generic.IEnumerable<global::test.csv.TestObject> items)\n\t        {\n\t            var root = new Polygen.Common.CsvIndexHeader { Index = -1, IndexList = new System.Collections.Generic.List<Polygen.Common.CsvIndexHeader>() };\n\t            var __nonList = new System.Collections.Generic.List<Polygen.Common.CsvIndexHeader>();\n\t            var __lists = new System.Collections.Generic.List<Polygen.Common.CsvIndexHeader>();\n\t            __nonList.Add(new Polygen.Common.CsvIndexHeader { Index = 0 });\n\t            __nonList.Add(new Polygen.Common.CsvIndexHeader { Index = 0 });\n\t            __nonList.Add(new Polygen.Common.CsvIndexHeader { Index = 0 });\n\t            __nonList.Add(new Polygen.Common.CsvIndexHeader { Index = 0 });\n\t            {\n\t                var ch = new Polygen.Common.CsvIndexHeader { Index = -1, IndexList = new System.Collections.Generic.List<Polygen.Common.CsvIndexHeader>() };\n\t              int __max = 0; \n\t              foreach (var __it in items)\n\t              {\n\t                  var __lst = __it.tags;\n\t                  if (__lst != null && __lst.Count > __max)\n\t                  {\n\t                      __max = __lst.Count;\n\t                  }\n\t              }\n\t              for (int i=0;i<__max;i++)\n\t              {\n\t                  ch.IndexList.Add(new Polygen.Common.CsvIndexHeader { Index = 0 });\n\t              }\n\t              __lists.Add(ch);\n\t            }\n\t            __nonList.Add(new Polygen.Common.CsvIndexHeader { Index = 0 });\n\t            {\n\t              Polygen.Common.CsvIndexHeader best = null;\n\t              int bestCols = -1;\n\t              foreach (var __it in items)\n\t              {\n\t                  if (__it.location != null)\n\t                  {\n\t                      var _single = new System.Collections.Generic.List<global::test.csv.Point>();\n\t                      _single.Add(__it.location);\n\t                      var cand = global::Csv.test.csv.Point.BuildWriteHeaderFromItems(_single);\n\t                      int cols = HeaderColumnCount(cand);\n\t                      if (cols > bestCols)\n\t                      {\n\t                          bestCols = cols;\n\t                          best = cand;\n\t                      }\n\t                  }\n\t              }\n\t              var sub = (bestCols >= 0) ? best : new Polygen.Common.CsvIndexHeader();\n\t              __nonList.Add(sub);\n\t            }\n\t            {\n\t                var ch = new Polygen.Common.CsvIndexHeader { Index = -1, IndexList = new System.Collections.Generic.List<Polygen.Common.CsvIndexHeader>() };\n\t              int __max = 0; \n\t              foreach (var __it in items)\n\t              {\n\t                  var __lst = __it.history;\n\t                  if (__lst != null && __lst.Count > __max)\n\t                  {\n\t                      __max = __lst.Count;\n\t                  }\n\t              }\n\t              for (int i=0;i<__max;i++)\n\t              {\n\t                var coll = new System.Collections.Generic.List<global::test.csv.Point>(); \n\t                foreach (var __it in items)\n\t                {\n\t                    var __lst = __it.history;\n\t                    if (__lst != null && __lst.Count > i)\n\t                    {\n\t                        var cand = __lst[i];\n\t                        if (cand != null)\n\t                        {\n\t                            coll.Add(cand);\n\t                        }\n\t                    }\n\t                } \n\t                ch.IndexList.Add(coll.Count > 0 ? global::Csv.test.csv.Point.BuildWriteHeaderFromItems(coll) : new Polygen.Common.CsvIndexHeader());\n\t              }\n\t              __lists.Add(ch);\n\t            }\n\t            foreach (var n in __nonList)\n\t            {\n\t                root.IndexList.Add(n);\n\t            }\n\t            foreach (var l in __lists)\n\t            {\n\t                root.IndexList.Add(l);\n\t            }\n\t            return root;\n\t        }\n\t        public static void CollectWriteHeaderNames(Polygen.Common.CsvIndexHeader h, string prefix, System.Collections.Generic.List<string> names)\n\t        {\n\t            int __idx = 0;\n\t            {\n\t                var __h = (h != null && h.IndexList != null && __idx < h.IndexList.Count) ? h.IndexList[__idx++] : null;\n\t              names.Add((prefix==string.Empty? \"id\" : prefix + \"id\"));\n\t            }\n\t            {\n\t                var __h = (h != null && h.IndexList != null && __idx < h.IndexList.Count) ? h.IndexList[__idx++] : null;\n\t              names.Add((prefix==string.Empty? \"name\" : prefix + \"name\"));\n\t            }\n\t            {\n\t                var __h = (h != null && h.IndexList != null && __idx < h.IndexList.Count) ? h.IndexList[__idx++] : null;\n\t              names.Add((prefix==string.Empty? \"active\" : prefix + \"active\"));\n\t            }\n\t            {\n\t                var __h = (h != null && h.IndexList != null && __idx < h.IndexList.Count) ? h.IndexList[__idx++] : null;\n\t              names.Add((prefix==string.Empty? \"score\" : prefix + \"score\"));\n\t            }\n\t            {\n\t                var __h = (h != null && h.IndexList != null && __idx < h.IndexList.Count) ? h.IndexList[__idx++] : null;\n\t              names.Add((prefix==string.Empty? \"color\" : prefix + \"color\"));\n\t            }\n\t            {\n\t                var __h = (h != null && h.IndexList != null && __idx < h.IndexList.Count) ? h.IndexList[__idx++] : null;\n\t              if (__h != null)\n\t              {\n\t                  global::Csv.test.csv.Point.CollectWriteHeaderNames(__h, \n\t                  (prefix==string.Empty? \"location.\" : prefix + \"location.\"), names);\n\t              }\n\t            }\n\t            {\n\t                var __h = (h != null && h.IndexList != null && __idx < h.IndexList.Count) ? h.IndexList[__idx++] : null;\n\t              int count = (__h != null && __h.IndexList != null) ? __h.IndexList.Count : 0; \n\t              for (int j=0;j<count;j++)\n\t              {\n\t                  names.Add((prefix==string.Empty? \"tags[\" + j + \"]\" : prefix + \"tags[\" + j + \"]\"));\n\t              }\n\t            }\n\t            {\n\t                var __h = (h != null && h.IndexList != null && __idx < h.IndexList.Count) ? h.IndexList[__idx++] : null;\n\t              int count = (__h != null && __h.IndexList != null) ? __h.IndexList.Count : 0; \n\t              for (int j=0;j<count;j++)\n\t              {\n\t                  var subH = __h.IndexList[j]; \n\t                  global::Csv.test.csv.Point.CollectWriteHeaderNames(subH, \n\t                  (prefix==string.Empty? \"history[\" + j + \"].\" : prefix + \"history[\" + j + \"].\"), names);\n\t              }\n\t            }\n\t        }\n\t        public static void WriteCsv(System.Collections.Generic.IEnumerable<global::test.csv.TestObject> items, string path, char sep = ',', Polygen.Common.CsvUtils.GapMode gap = Polygen.Common.CsvUtils.GapMode.Break)\n\t        {\n\t            var list = new System.Collections.Generic.List<global::test.csv.TestObject>(); foreach (var it in items) list.Add(it);\n\t            var h = BuildWriteHeaderFromItems(list);\n\t            var names = new System.Collections.Generic.List<string>(); CollectWriteHeaderNames(h, string.Empty, names);\n\t            using var sw = new StreamWriter(path, false, new UTF8Encoding(false));\n\t            sw.WriteLine(Polygen.Common.CsvUtils.Join(names, sep));\n\t            foreach (var it in list)\n\t            {\n\t                var row = ToRowWithHeader(h, it, gap);\n\t                sw.WriteLine(Polygen.Common.CsvUtils.Join(row, sep));\n\t            }\n\t        }\n\t        public static void WriteCsvWithHeader(IEnumerable<global::test.csv.TestObject> items, string path, string[] header, char sep = ',', Polygen.Common.CsvUtils.GapMode gap = Polygen.Common.CsvUtils.GapMode.Break)\n\t        {\n\t            var h = BuildHeader(header, string.Empty);\n\t            using var sw = new StreamWriter(path, false, new UTF8Encoding(false));\n\t            sw.WriteLine(Polygen.Common.CsvUtils.Join(header, sep));\n\t            foreach (var it in items)\n\t            {\n\t                var row = ToRowWithHeader(h, it, gap);\n\t                sw.WriteLine(Polygen.Common.CsvUtils.Join(row, sep));\n\t            }\n\t        }\n\t        public static Polygen.Common.CsvIndexHeader BuildHeader(string[] header, string prefix)\n\t        {\n\t            var map = Polygen.Common.CsvUtils.CsvIndexHeader(header);\n\t            var root = new Polygen.Common.CsvIndexHeader();\n\t            root.IndexList = new System.Collections.Generic.List<Polygen.Common.CsvIndexHeader>();\n\t            {\n\t                int __ix;\n\t                if (map.TryGetValue(prefix + \"id\", out __ix))\n\t                {\n\t                    var leaf = new Polygen.Common.CsvIndexHeader();\n\t                    leaf.Index = __ix;\n\t                    root.IndexList.Add(leaf);\n\t                }\n\t            }\n\t            {\n\t                int __ix;\n\t                if (map.TryGetValue(prefix + \"name\", out __ix))\n\t                {\n\t                    var leaf = new Polygen.Common.CsvIndexHeader();\n\t                    leaf.Index = __ix;\n\t                    root.IndexList.Add(leaf);\n\t                }\n\t            }\n\t            {\n\t                int __ix;\n\t                if (map.TryGetValue(prefix + \"active\", out __ix))\n\t                {\n\t                    var leaf = new Polygen.Common.CsvIndexHeader();\n\t                    leaf.Index = __ix;\n\t                    root.IndexList.Add(leaf);\n\t                }\n\t            }\n\t            {\n\t                int __ix;\n\t                if (map.TryGetValue(prefix + \"score\", out __ix))\n\t                {\n\t                    var leaf = new Polygen.Common.CsvIndexHeader();\n\t                    leaf.Index = __ix;\n\t                    root.IndexList.Add(leaf);\n\t                }\n\t            }\n\t            {\n\t                var ch = new Polygen.Common.CsvIndexHeader();\n\t                ch.Index = -1;\n\t                ch.IndexList = new System.Collections.Generic.List<Polygen.Common.CsvIndexHeader>();\n\t                for (int i=0;;i++)\n\t                {\n\t                    int __ix;\n\t                    if (!map.TryGetValue(prefix + \"tags[\" + i + \"]\", out __ix))\n\t                    {\n\t                        break;\n\t                    }\n\t                    var leaf = new Polygen.Common.CsvIndexHeader();\n\t                    leaf.Index = __ix;\n\t                    ch.IndexList.Add(leaf);\n\t                }\n\t                root.IndexList.Add(ch);\n\t            }\n\t            {\n\t                int __ix;\n\t                if (map.TryGetValue(prefix + \"color\", out __ix))\n\t                {\n\t                    var leaf = new Polygen.Common.CsvIndexHeader();\n\t                    leaf.Index = __ix;\n\t                    root.IndexList.Add(leaf);\n\t                }\n\t            }\n\t            {\n\t                var sub = global::Csv.test.csv.Point.BuildHeader(header, prefix + \"location.\");\n\t                if (sub.HasAny()) root.IndexList.Add(sub);\n\t            }\n\t            {\n\t                var ch = new Polygen.Common.CsvIndexHeader();\n\t                ch.Index = -1;\n\t                ch.IndexList = new System.Collections.Generic.List<Polygen.Common.CsvIndexHeader>();\n\t                for (int i=0;;i++)\n\t                {\n\t                    var sub = global::Csv.test.csv.Point.BuildHeader(header, prefix + \"history[\"+i+\"].\");\n\t                    if (!sub.HasAny()) break;\n\t                    ch.IndexList.Add(sub);\n\t                }\n\t                root.IndexList.Add(ch);\n\t            }\n\t            return root;\n\t        }\n\n\t        public static global::test.csv.TestObject FromRowWithHeader(Polygen.Common.CsvIndexHeader h, string[] row, Polygen.Common.CsvUtils.GapMode gap)\n\t        {\n\t            var obj = new global::test.csv.TestObject();\n\t            int __i = 0;\n\t            {\n\t                var __h = (h != null && h.IndexList != null && __i < h.IndexList.Count) ? h.IndexList[__i++] : null;\n\t            if (__h != null && __h.Index >= 0 && __h.Index < row.Length)\n\t            {\n\t                var __cell = row[__h.Index];\n\t                obj.id = DataSourceFactory.ConvertValue<uint>(__cell);\n\t            }\n\t            }\n\t            {\n\t                var __h = (h != null && h.IndexList != null && __i < h.IndexList.Count) ? h.IndexList[__i++] : null;\n\t            if (__h != null && __h.Index >= 0 && __h.Index < row.Length)\n\t            {\n\t                var __cell = row[__h.Index];\n\t                obj.name = DataSourceFactory.ConvertValue<string>(__cell);\n\t            }\n\t            }\n\t            {\n\t                var __h = (h != null && h.IndexList != null && __i < h.IndexList.Count) ? h.IndexList[__i++] : null;\n\t            if (__h != null && __h.Index >= 0 && __h.Index < row.Length)\n\t            {\n\t                var __cell = row[__h.Index];\n\t                obj.active = DataSourceFactory.ConvertValue<bool>(__cell);\n\t            }\n\t            }\n\t            {\n\t                var __h = (h != null && h.IndexList != null && __i < h.IndexList.Count) ? h.IndexList[__i++] : null;\n\t            if (__h != null && __h.Index >= 0 && __h.Index < row.Length)\n\t            {\n\t                var __cell = row[__h.Index];\n\t                obj.score = DataSourceFactory.ConvertValue<float>(__cell);\n\t            }\n\t            }\n\t            {\n\t                var __h = (h != null && h.IndexList != null && __i < h.IndexList.Count) ? h.IndexList[__i++] : null;\n\t                {\n\t                    var list = new System.Collections.Generic.List<string>();\n\t                    if (__h != null && __h.IndexList != null)\n\t                    {\n\t                        for (int i = 0; i < __h.IndexList.Count; i++)\n\t                        {\n\t                            var subH = __h.IndexList[i];\n\t                            if (!Polygen.Common.CsvUtils.HeaderHasValues(subH, row))\n\t                            {\n\t                                if (i == 0 || gap == Polygen.Common.CsvUtils.GapMode.Break)\n\t                                {\n\t                                    break;\n\t                                }\n\t                                else\n\t                                {\n\t                                    continue;\n\t                                }\n\t                            }\n\t                            var v = DataSourceFactory.ConvertValue<string>(row[subH.Index]);\n\t                            list.Add(v);\n\t                        }\n\t                    }\n\t                    obj.tags = list;\n\t                }\n\t            }\n\t            {\n\t                var __h = (h != null && h.IndexList != null && __i < h.IndexList.Count) ? h.IndexList[__i++] : null;\n\t            if (__h != null && __h.Index >= 0 && __h.Index < row.Length)\n\t            {\n\t                var __cell = row[__h.Index];\n\t                obj.color = DataSourceFactory.ConvertValue<global::test.csv.Color>(__cell);\n\t            }\n\t            }\n\t            {\n\t                var __h = (h != null && h.IndexList != null && __i < h.IndexList.Count) ? h.IndexList[__i++] : null;\n\t            if (!Polygen.Common.CsvUtils.HeaderHasValues(__h, row))\n\t            {\n\t                obj.location = null;\n\t            }\n\t            else\n\t            {\n\t                obj.location = global::Csv.test.csv.Point.FromRowWithHeader(__h, row, gap);\n\t            }\n\t            }\n\t            {\n\t                var __h = (h != null && h.IndexList != null && __i < h.IndexList.Count) ? h.IndexList[__i++] : null;\n\t                {\n\t                    var list = new System.Collections.Generic.List<global::test.csv.Point>();\n\t                    if (__h != null && __h.IndexList != null)\n\t                    {\n\t                        for (int i = 0; i < __h.IndexList.Count; i++)\n\t                        {\n\t                            var subH = __h.IndexList[i];\n\t                            if (!Polygen.Common.CsvUtils.HeaderHasValues(subH, row))\n\t                            {\n\t                                if (i == 0 || gap == Polygen.Common.CsvUtils.GapMode.Break)\n\t                                {\n\t                                    break;\n\t                                }\n\t                                else\n\t                                {\n\t                                    continue;\n\t                                }\n\t                            }\n\t                            var sub = global::Csv.test.csv.Point.FromRowWithHeader(subH, row, gap);\n\t                            list.Add(sub);\n\t                        }\n\t                    }\n\t                    obj.history = list;\n\t                }\n\t            }\n\t            return obj;\n\t        }\n\t        public static System.Collections.Generic.IEnumerable<global::test.csv.TestObject> ReadRowsWithHeader(string path, char sep = ',', Polygen.Common.CsvUtils.GapMode gap = Polygen.Common.CsvUtils.GapMode.Break)\n\t        {\n\t            var lines = File.ReadAllLines(path);\n\t            if (lines.Length == 0)\n\t            {\n\t                yield break;\n\t            }\n\t            var header = lines[0].Split(sep);\n\t            var h = BuildHeader(header, string.Empty);\n\t            for (int i = 1; i < lines.Length; i++)\n\t            {\n\t                var row = lines[i].Split(sep);\n\t                if (!Polygen.Common.CsvUtils.HeaderHasValues(h, row))\n\t                {\n\t                    if (gap == Polygen.Common.CsvUtils.GapMode.Break)\n\t                    {\n\t                        break;\n\t                    }\n\t                    else\n\t                    {\n\t                        continue;\n\t                    }\n\t                }\n\t                yield return FromRowWithHeader(h, row, gap);\n\t            }\n\t        }\n\t        public static System.Collections.Generic.IEnumerable<global::test.csv.TestObject> ReadCsvFast(string path, char sep = ',', Polygen.Common.CsvUtils.GapMode gap = Polygen.Common.CsvUtils.GapMode.Break)\n\t            => ReadRowsWithHeader(path, sep, gap);\n\n\t}\n\n\n\n}\n\n\n\n\n"
