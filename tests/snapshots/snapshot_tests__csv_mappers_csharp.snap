---
source: tests/snapshot_tests.rs
expression: content
---
"using System;\nusing System.Collections.Generic;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\nusing System.Globalization;\nusing System.IO;\nusing System.Text;\nusing Polygen.Common;\nnamespace Csv.test.csv\n{\n    public static class Point\n    {\n        private static int HeaderColumnCount(Polygen.Common.CsvIndexHeader h)\n        {\n            if (h.Index >= 0)\n            {\n                return 1;\n            }\n            int n = 0;\n            if (h.IndexList != null)\n            {\n                for (int i = 0; i < h.IndexList.Count; i++)\n                {\n                    n += HeaderColumnCount(h.IndexList[i]);\n                }\n            }\n            return n;\n        }\n\n        public static void AppendRowWithHeader(Polygen.Common.CsvIndexHeader h, in global::test.csv.Point obj, List<string> cols, Polygen.Common.CsvUtils.GapMode gap = Polygen.Common.CsvUtils.GapMode.Break)\n        {\n            int __idx = 0;\n            {\n                var __h = (h != null && h.IndexList != null && __idx < h.IndexList.Count) ? h.IndexList[__idx++] : null;\n              if (__h != null && __h.Index >= 0)\n              {\n                  cols.Add(Polygen.Common.CsvUtils.ToStringInvariant(obj.x));\n              }\n              else\n              {\n                  cols.Add(string.Empty);\n              }\n            }\n            {\n                var __h = (h != null && h.IndexList != null && __idx < h.IndexList.Count) ? h.IndexList[__idx++] : null;\n              if (__h != null && __h.Index >= 0)\n              {\n                  cols.Add(Polygen.Common.CsvUtils.ToStringInvariant(obj.y));\n              }\n              else\n              {\n                  cols.Add(string.Empty);\n              }\n            }\n        }\n        public static string[] ToRowWithHeader(Polygen.Common.CsvIndexHeader h, in global::test.csv.Point obj, Polygen.Common.CsvUtils.GapMode gap = Polygen.Common.CsvUtils.GapMode.Break) { var list = new List<string>(); AppendRowWithHeader(h, obj, list, gap); return list.ToArray(); }\n\n        public static Polygen.Common.CsvIndexHeader BuildWriteHeaderFromItems(System.Collections.Generic.IEnumerable<global::test.csv.Point> items)\n        {\n            var root = new Polygen.Common.CsvIndexHeader { Index = -1, IndexList = new System.Collections.Generic.List<Polygen.Common.CsvIndexHeader>() };\n            var __nonList = new System.Collections.Generic.List<Polygen.Common.CsvIndexHeader>();\n            __nonList.Add(new Polygen.Common.CsvIndexHeader { Index = 0 });\n            __nonList.Add(new Polygen.Common.CsvIndexHeader { Index = 0 });\n            foreach (var n in __nonList)\n            {\n                root.IndexList.Add(n);\n            }\n            return root;\n        }\n\n        public static void CollectWriteHeaderNames(Polygen.Common.CsvIndexHeader h, string prefix, System.Collections.Generic.List<string> names)\n        {\n            int __idx = 0;\n            {\n                var __h = (h != null && h.IndexList != null && __idx < h.IndexList.Count) ? h.IndexList[__idx++] : null;\n              names.Add((prefix==string.Empty? \"x\" : prefix + \"x\"));\n            }\n            {\n                var __h = (h != null && h.IndexList != null && __idx < h.IndexList.Count) ? h.IndexList[__idx++] : null;\n              names.Add((prefix==string.Empty? \"y\" : prefix + \"y\"));\n            }\n        }\n\n        public static void WriteCsv(System.Collections.Generic.IEnumerable<global::test.csv.Point> items, string path, char sep = ',', Polygen.Common.CsvUtils.GapMode gap = Polygen.Common.CsvUtils.GapMode.Break)\n        {\n            var list = new System.Collections.Generic.List<global::test.csv.Point>(); foreach (var it in items) list.Add(it);\n            var h = BuildWriteHeaderFromItems(list);\n            var names = new System.Collections.Generic.List<string>(); CollectWriteHeaderNames(h, string.Empty, names);\n            using var sw = new StreamWriter(path, false, new UTF8Encoding(false));\n            sw.WriteLine(Polygen.Common.CsvUtils.Join(names, sep));\n            foreach (var it in list)\n            {\n                var row = ToRowWithHeader(h, it, gap);\n                sw.WriteLine(Polygen.Common.CsvUtils.Join(row, sep));\n            }\n        }\n        public static void WriteCsvWithHeader(IEnumerable<global::test.csv.Point> items, string path, string[] header, char sep = ',', Polygen.Common.CsvUtils.GapMode gap = Polygen.Common.CsvUtils.GapMode.Break)\n        {\n            var h = BuildHeader(header, string.Empty);\n            using var sw = new StreamWriter(path, false, new UTF8Encoding(false));\n            sw.WriteLine(Polygen.Common.CsvUtils.Join(header, sep));\n            foreach (var it in items)\n            {\n                var row = ToRowWithHeader(h, it, gap);\n                sw.WriteLine(Polygen.Common.CsvUtils.Join(row, sep));\n            }\n        }\n\n        public static global::test.csv.Point FromRowWithHeader(Polygen.Common.CsvIndexHeader h, string[] row, Polygen.Common.CsvUtils.GapMode gap)\n        {\n            var obj = new global::test.csv.Point();\n            int __i = 0;\n            {\n                var __h = (h != null && h.IndexList != null && __i < h.IndexList.Count) ? h.IndexList[__i++] : null;\n            if (__h != null && __h.Index >= 0 && __h.Index < row.Length)\n            {\n                var __cell = row[__h.Index];\n                obj.x = DataSourceFactory.ConvertValue<int>(__cell);\n            }\n            }\n            {\n                var __h = (h != null && h.IndexList != null && __i < h.IndexList.Count) ? h.IndexList[__i++] : null;\n            if (__h != null && __h.Index >= 0 && __h.Index < row.Length)\n            {\n                var __cell = row[__h.Index];\n                obj.y = DataSourceFactory.ConvertValue<int>(__cell);\n            }\n            }\n            return obj;\n        }\n        public static System.Collections.Generic.IEnumerable<global::test.csv.Point> ReadRowsWithHeader(string path, char sep = ',', Polygen.Common.CsvUtils.GapMode gap = Polygen.Common.CsvUtils.GapMode.Break)\n        {\n            var lines = File.ReadAllLines(path);\n            if (lines.Length == 0)\n            {\n                yield break;\n            }\n            var header = lines[0].Split(sep);\n            var h = BuildHeader(header, string.Empty);\n            for (int i = 1; i < lines.Length; i++)\n            {\n                var row = lines[i].Split(sep);\n                if (!Polygen.Common.CsvUtils.HeaderHasValues(h, row))\n                {\n                    if (gap == Polygen.Common.CsvUtils.GapMode.Break)\n                    {\n                        break;\n                    }\n                    else\n                    {\n                        continue;\n                    }\n                }\n                yield return FromRowWithHeader(h, row, gap);\n            }\n        }\n        public static System.Collections.Generic.IEnumerable<global::test.csv.Point> ReadCsvFast(string path, char sep = ',', Polygen.Common.CsvUtils.GapMode gap = Polygen.Common.CsvUtils.GapMode.Break)\n            => ReadRowsWithHeader(path, sep, gap);\n\n        public static Polygen.Common.CsvIndexHeader BuildHeader(string[] header, string prefix)\n        {\n            var map = Polygen.Common.CsvUtils.CsvIndexHeader(header);\n            var root = new Polygen.Common.CsvIndexHeader();\n            root.IndexList = new System.Collections.Generic.List<Polygen.Common.CsvIndexHeader>();\n            {\n                int __ix;\n                if (map.TryGetValue(prefix + \"x\", out __ix))\n                {\n                    var leaf = new Polygen.Common.CsvIndexHeader();\n                    leaf.Index = __ix;\n                    root.IndexList.Add(leaf);\n                }\n            }\n            {\n                int __ix;\n                if (map.TryGetValue(prefix + \"y\", out __ix))\n                {\n                    var leaf = new Polygen.Common.CsvIndexHeader();\n                    leaf.Index = __ix;\n                    root.IndexList.Add(leaf);\n                }\n            }\n            return root;\n        }\n\n    }\n    public static class TestObject\n    {\n        private static int HeaderColumnCount(Polygen.Common.CsvIndexHeader h)\n        {\n            if (h.Index >= 0)\n            {\n                return 1;\n            }\n            int n = 0;\n            if (h.IndexList != null)\n            {\n                for (int i = 0; i < h.IndexList.Count; i++)\n                {\n                    n += HeaderColumnCount(h.IndexList[i]);\n                }\n            }\n            return n;\n        }\n\n        public static void AppendRowWithHeader(Polygen.Common.CsvIndexHeader h, in global::test.csv.TestObject obj, List<string> cols, Polygen.Common.CsvUtils.GapMode gap = Polygen.Common.CsvUtils.GapMode.Break)\n        {\n            int __idx = 0;\n            {\n                var __h = (h != null && h.IndexList != null && __idx < h.IndexList.Count) ? h.IndexList[__idx++] : null;\n              if (__h != null && __h.Index >= 0)\n              {\n                  cols.Add(Polygen.Common.CsvUtils.ToStringInvariant(obj.id));\n              }\n              else\n              {\n                  cols.Add(string.Empty);\n              }\n            }\n            {\n                var __h = (h != null && h.IndexList != null && __idx < h.IndexList.Count) ? h.IndexList[__idx++] : null;\n              if (__h != null && __h.Index >= 0)\n              {\n                  cols.Add(Polygen.Common.CsvUtils.ToStringInvariant(obj.name));\n              }\n              else\n              {\n                  cols.Add(string.Empty);\n              }\n            }\n            {\n                var __h = (h != null && h.IndexList != null && __idx < h.IndexList.Count) ? h.IndexList[__idx++] : null;\n              if (__h != null && __h.Index >= 0)\n              {\n                  cols.Add(Polygen.Common.CsvUtils.ToStringInvariant(obj.active));\n              }\n              else\n              {\n                  cols.Add(string.Empty);\n              }\n            }\n            {\n                var __h = (h != null && h.IndexList != null && __idx < h.IndexList.Count) ? h.IndexList[__idx++] : null;\n              if (__h != null && __h.Index >= 0)\n              {\n                  cols.Add(Polygen.Common.CsvUtils.ToStringInvariant(obj.score));\n              }\n              else\n              {\n                  cols.Add(string.Empty);\n              }\n            }\n            {\n                var __h = (h != null && h.IndexList != null && __idx < h.IndexList.Count) ? h.IndexList[__idx++] : null;\n              if (__h != null && __h.Index >= 0)\n              {\n                  cols.Add(obj.color.ToString());\n              }\n              else if (__h != null && __h.IndexList != null)\n              {\n                  int pad = HeaderColumnCount(__h);\n                  for (int k = 0; k < pad; k++)\n                  {\n                      cols.Add(string.Empty);\n                  }\n              }\n              else\n              {\n                  cols.Add(string.Empty);\n              }\n            }\n            {\n                var __h = (h != null && h.IndexList != null && __idx < h.IndexList.Count) ? h.IndexList[__idx++] : null;\n              if (__h != null && __h.IndexList != null)\n              {\n                  if (obj.location != null)\n                  {\n                      global::Csv.test.csv.Point.AppendRowWithHeader(__h, obj.location, cols, gap);\n                  }\n                  else\n                  {\n                      int pad = HeaderColumnCount(__h); for (int k=0;k<pad;k++) cols.Add(string.Empty);\n                  }\n              }\n              else\n              {\n                  cols.Add(string.Empty);\n              }\n            }\n            {\n                var __h = (h != null && h.IndexList != null && __idx < h.IndexList.Count) ? h.IndexList[__idx++] : null;\n              int count = (__h != null && __h.IndexList != null) ? __h.IndexList.Count : 0; \n              for (int j=0;j<count;j++)\n              {\n                if (obj.tags != null && j < obj.tags.Count)\n                {\n                    var v = obj.tags[j];\n                    cols.Add(Polygen.Common.CsvUtils.ToStringInvariant(v));\n                }\n                else\n                {\n                    cols.Add(string.Empty);\n                }\n              }\n            }\n            {\n                var __h = (h != null && h.IndexList != null && __idx < h.IndexList.Count) ? h.IndexList[__idx++] : null;\n              int count = (__h != null && __h.IndexList != null) ? __h.IndexList.Count : 0; \n              for (int j=0;j<count;j++)\n              {\n                  var subH = __h.IndexList[j]; \n                  if (obj.history != null && j < obj.history.Count && obj.history[j] != null)\n                  {\n                      var sub = obj.history[j];\n                      global::Csv.test.csv.Point.AppendRowWithHeader(subH, sub, cols, gap);\n                  }\n                  else\n                  {\n                      int pad = HeaderColumnCount(subH); for (int k=0;k<pad;k++) cols.Add(string.Empty);\n                  }\n              }\n            }\n        }\n        public static string[] ToRowWithHeader(Polygen.Common.CsvIndexHeader h, in global::test.csv.TestObject obj, Polygen.Common.CsvUtils.GapMode gap = Polygen.Common.CsvUtils.GapMode.Break) { var list = new List<string>(); AppendRowWithHeader(h, obj, list, gap); return list.ToArray(); }\n\n        public static Polygen.Common.CsvIndexHeader BuildWriteHeaderFromItems(System.Collections.Generic.IEnumerable<global::test.csv.TestObject> items)\n        {\n            var root = new Polygen.Common.CsvIndexHeader { Index = -1, IndexList = new System.Collections.Generic.List<Polygen.Common.CsvIndexHeader>() };\n            var __nonList = new System.Collections.Generic.List<Polygen.Common.CsvIndexHeader>();\n            var __lists = new System.Collections.Generic.List<Polygen.Common.CsvIndexHeader>();\n            __nonList.Add(new Polygen.Common.CsvIndexHeader { Index = 0 });\n            __nonList.Add(new Polygen.Common.CsvIndexHeader { Index = 0 });\n            __nonList.Add(new Polygen.Common.CsvIndexHeader { Index = 0 });\n            __nonList.Add(new Polygen.Common.CsvIndexHeader { Index = 0 });\n            {\n                var ch = new Polygen.Common.CsvIndexHeader { Index = -1, IndexList = new System.Collections.Generic.List<Polygen.Common.CsvIndexHeader>() };\n              int __max = 0; \n              foreach (var __it in items)\n              {\n                  var __lst = __it.tags;\n                  if (__lst != null && __lst.Count > __max)\n                  {\n                      __max = __lst.Count;\n                  }\n              }\n              for (int i=0;i<__max;i++)\n              {\n                  ch.IndexList.Add(new Polygen.Common.CsvIndexHeader { Index = 0 });\n              }\n              __lists.Add(ch);\n            }\n            __nonList.Add(new Polygen.Common.CsvIndexHeader { Index = 0 });\n            {\n              Polygen.Common.CsvIndexHeader best = null;\n              int bestCols = -1;\n              foreach (var __it in items)\n              {\n                  if (__it.location != null)\n                  {\n                      var _single = new System.Collections.Generic.List<global::test.csv.Point>();\n                      _single.Add(__it.location);\n                      var cand = global::Csv.test.csv.Point.BuildWriteHeaderFromItems(_single);\n                      int cols = HeaderColumnCount(cand);\n                      if (cols > bestCols)\n                      {\n                          bestCols = cols;\n                          best = cand;\n                      }\n                  }\n              }\n              var sub = (bestCols >= 0) ? best : new Polygen.Common.CsvIndexHeader();\n              __nonList.Add(sub);\n            }\n            {\n                var ch = new Polygen.Common.CsvIndexHeader { Index = -1, IndexList = new System.Collections.Generic.List<Polygen.Common.CsvIndexHeader>() };\n              int __max = 0; \n              foreach (var __it in items)\n              {\n                  var __lst = __it.history;\n                  if (__lst != null && __lst.Count > __max)\n                  {\n                      __max = __lst.Count;\n                  }\n              }\n              for (int i=0;i<__max;i++)\n              {\n                var coll = new System.Collections.Generic.List<global::test.csv.Point>(); \n                foreach (var __it in items)\n                {\n                    var __lst = __it.history;\n                    if (__lst != null && __lst.Count > i)\n                    {\n                        var cand = __lst[i];\n                        if (cand != null)\n                        {\n                            coll.Add(cand);\n                        }\n                    }\n                } \n                ch.IndexList.Add(coll.Count > 0 ? global::Csv.test.csv.Point.BuildWriteHeaderFromItems(coll) : new Polygen.Common.CsvIndexHeader());\n              }\n              __lists.Add(ch);\n            }\n            foreach (var n in __nonList)\n            {\n                root.IndexList.Add(n);\n            }\n            foreach (var l in __lists)\n            {\n                root.IndexList.Add(l);\n            }\n            return root;\n        }\n\n        public static void CollectWriteHeaderNames(Polygen.Common.CsvIndexHeader h, string prefix, System.Collections.Generic.List<string> names)\n        {\n            int __idx = 0;\n            {\n                var __h = (h != null && h.IndexList != null && __idx < h.IndexList.Count) ? h.IndexList[__idx++] : null;\n              names.Add((prefix==string.Empty? \"id\" : prefix + \"id\"));\n            }\n            {\n                var __h = (h != null && h.IndexList != null && __idx < h.IndexList.Count) ? h.IndexList[__idx++] : null;\n              names.Add((prefix==string.Empty? \"name\" : prefix + \"name\"));\n            }\n            {\n                var __h = (h != null && h.IndexList != null && __idx < h.IndexList.Count) ? h.IndexList[__idx++] : null;\n              names.Add((prefix==string.Empty? \"active\" : prefix + \"active\"));\n            }\n            {\n                var __h = (h != null && h.IndexList != null && __idx < h.IndexList.Count) ? h.IndexList[__idx++] : null;\n              names.Add((prefix==string.Empty? \"score\" : prefix + \"score\"));\n            }\n            {\n                var __h = (h != null && h.IndexList != null && __idx < h.IndexList.Count) ? h.IndexList[__idx++] : null;\n              names.Add((prefix==string.Empty? \"color\" : prefix + \"color\"));\n            }\n            {\n                var __h = (h != null && h.IndexList != null && __idx < h.IndexList.Count) ? h.IndexList[__idx++] : null;\n              if (__h != null)\n              {\n                  global::Csv.test.csv.Point.CollectWriteHeaderNames(__h, \n                  (prefix==string.Empty? \"location.\" : prefix + \"location.\"), names);\n              }\n            }\n            {\n                var __h = (h != null && h.IndexList != null && __idx < h.IndexList.Count) ? h.IndexList[__idx++] : null;\n              int count = (__h != null && __h.IndexList != null) ? __h.IndexList.Count : 0; \n              for (int j=0;j<count;j++)\n              {\n                  names.Add((prefix==string.Empty? \"tags[\" + j + \"]\" : prefix + \"tags[\" + j + \"]\"));\n              }\n            }\n            {\n                var __h = (h != null && h.IndexList != null && __idx < h.IndexList.Count) ? h.IndexList[__idx++] : null;\n              int count = (__h != null && __h.IndexList != null) ? __h.IndexList.Count : 0; \n              for (int j=0;j<count;j++)\n              {\n                  var subH = __h.IndexList[j]; \n                  global::Csv.test.csv.Point.CollectWriteHeaderNames(subH, \n                  (prefix==string.Empty? \"history[\" + j + \"].\" : prefix + \"history[\" + j + \"].\"), names);\n              }\n            }\n        }\n\n        public static void WriteCsv(System.Collections.Generic.IEnumerable<global::test.csv.TestObject> items, string path, char sep = ',', Polygen.Common.CsvUtils.GapMode gap = Polygen.Common.CsvUtils.GapMode.Break)\n        {\n            var list = new System.Collections.Generic.List<global::test.csv.TestObject>(); foreach (var it in items) list.Add(it);\n            var h = BuildWriteHeaderFromItems(list);\n            var names = new System.Collections.Generic.List<string>(); CollectWriteHeaderNames(h, string.Empty, names);\n            using var sw = new StreamWriter(path, false, new UTF8Encoding(false));\n            sw.WriteLine(Polygen.Common.CsvUtils.Join(names, sep));\n            foreach (var it in list)\n            {\n                var row = ToRowWithHeader(h, it, gap);\n                sw.WriteLine(Polygen.Common.CsvUtils.Join(row, sep));\n            }\n        }\n        public static void WriteCsvWithHeader(IEnumerable<global::test.csv.TestObject> items, string path, string[] header, char sep = ',', Polygen.Common.CsvUtils.GapMode gap = Polygen.Common.CsvUtils.GapMode.Break)\n        {\n            var h = BuildHeader(header, string.Empty);\n            using var sw = new StreamWriter(path, false, new UTF8Encoding(false));\n            sw.WriteLine(Polygen.Common.CsvUtils.Join(header, sep));\n            foreach (var it in items)\n            {\n                var row = ToRowWithHeader(h, it, gap);\n                sw.WriteLine(Polygen.Common.CsvUtils.Join(row, sep));\n            }\n        }\n\n        public static global::test.csv.TestObject FromRowWithHeader(Polygen.Common.CsvIndexHeader h, string[] row, Polygen.Common.CsvUtils.GapMode gap)\n        {\n            var obj = new global::test.csv.TestObject();\n            int __i = 0;\n            {\n                var __h = (h != null && h.IndexList != null && __i < h.IndexList.Count) ? h.IndexList[__i++] : null;\n            if (__h != null && __h.Index >= 0 && __h.Index < row.Length)\n            {\n                var __cell = row[__h.Index];\n                obj.id = DataSourceFactory.ConvertValue<uint>(__cell);\n            }\n            }\n            {\n                var __h = (h != null && h.IndexList != null && __i < h.IndexList.Count) ? h.IndexList[__i++] : null;\n            if (__h != null && __h.Index >= 0 && __h.Index < row.Length)\n            {\n                var __cell = row[__h.Index];\n                obj.name = DataSourceFactory.ConvertValue<string>(__cell);\n            }\n            }\n            {\n                var __h = (h != null && h.IndexList != null && __i < h.IndexList.Count) ? h.IndexList[__i++] : null;\n            if (__h != null && __h.Index >= 0 && __h.Index < row.Length)\n            {\n                var __cell = row[__h.Index];\n                obj.active = DataSourceFactory.ConvertValue<bool>(__cell);\n            }\n            }\n            {\n                var __h = (h != null && h.IndexList != null && __i < h.IndexList.Count) ? h.IndexList[__i++] : null;\n            if (__h != null && __h.Index >= 0 && __h.Index < row.Length)\n            {\n                var __cell = row[__h.Index];\n                obj.score = DataSourceFactory.ConvertValue<float>(__cell);\n            }\n            }\n            {\n                var __h = (h != null && h.IndexList != null && __i < h.IndexList.Count) ? h.IndexList[__i++] : null;\n                {\n                    var list = new System.Collections.Generic.List<string>();\n                    if (__h != null && __h.IndexList != null)\n                    {\n                        for (int i = 0; i < __h.IndexList.Count; i++)\n                        {\n                            var subH = __h.IndexList[i];\n                            if (!Polygen.Common.CsvUtils.HeaderHasValues(subH, row))\n                            {\n                                if (i == 0 || gap == Polygen.Common.CsvUtils.GapMode.Break)\n                                {\n                                    break;\n                                }\n                                else\n                                {\n                                    continue;\n                                }\n                            }\n                            var v = DataSourceFactory.ConvertValue<string>(row[subH.Index]);\n                            list.Add(v);\n                        }\n                    }\n                    obj.tags = list;\n                }\n            }\n            {\n                var __h = (h != null && h.IndexList != null && __i < h.IndexList.Count) ? h.IndexList[__i++] : null;\n            if (__h != null && __h.Index >= 0 && __h.Index < row.Length)\n            {\n                var __cell = row[__h.Index];\n                obj.color = DataSourceFactory.ConvertValue<global::test.csv.Color>(__cell);\n            }\n            }\n            {\n                var __h = (h != null && h.IndexList != null && __i < h.IndexList.Count) ? h.IndexList[__i++] : null;\n            if (!Polygen.Common.CsvUtils.HeaderHasValues(__h, row))\n            {\n                obj.location = null;\n            }\n            else\n            {\n                obj.location = global::Csv.test.csv.Point.FromRowWithHeader(__h, row, gap);\n            }\n            }\n            {\n                var __h = (h != null && h.IndexList != null && __i < h.IndexList.Count) ? h.IndexList[__i++] : null;\n                {\n                    var list = new System.Collections.Generic.List<global::test.csv.Point>();\n                    if (__h != null && __h.IndexList != null)\n                    {\n                        for (int i = 0; i < __h.IndexList.Count; i++)\n                        {\n                            var subH = __h.IndexList[i];\n                            if (!Polygen.Common.CsvUtils.HeaderHasValues(subH, row))\n                            {\n                                if (i == 0 || gap == Polygen.Common.CsvUtils.GapMode.Break)\n                                {\n                                    break;\n                                }\n                                else\n                                {\n                                    continue;\n                                }\n                            }\n                            var sub = global::Csv.test.csv.Point.FromRowWithHeader(subH, row, gap);\n                            list.Add(sub);\n                        }\n                    }\n                    obj.history = list;\n                }\n            }\n            return obj;\n        }\n        public static System.Collections.Generic.IEnumerable<global::test.csv.TestObject> ReadRowsWithHeader(string path, char sep = ',', Polygen.Common.CsvUtils.GapMode gap = Polygen.Common.CsvUtils.GapMode.Break)\n        {\n            var lines = File.ReadAllLines(path);\n            if (lines.Length == 0)\n            {\n                yield break;\n            }\n            var header = lines[0].Split(sep);\n            var h = BuildHeader(header, string.Empty);\n            for (int i = 1; i < lines.Length; i++)\n            {\n                var row = lines[i].Split(sep);\n                if (!Polygen.Common.CsvUtils.HeaderHasValues(h, row))\n                {\n                    if (gap == Polygen.Common.CsvUtils.GapMode.Break)\n                    {\n                        break;\n                    }\n                    else\n                    {\n                        continue;\n                    }\n                }\n                yield return FromRowWithHeader(h, row, gap);\n            }\n        }\n        public static System.Collections.Generic.IEnumerable<global::test.csv.TestObject> ReadCsvFast(string path, char sep = ',', Polygen.Common.CsvUtils.GapMode gap = Polygen.Common.CsvUtils.GapMode.Break)\n            => ReadRowsWithHeader(path, sep, gap);\n\n        public static Polygen.Common.CsvIndexHeader BuildHeader(string[] header, string prefix)\n        {\n            var map = Polygen.Common.CsvUtils.CsvIndexHeader(header);\n            var root = new Polygen.Common.CsvIndexHeader();\n            root.IndexList = new System.Collections.Generic.List<Polygen.Common.CsvIndexHeader>();\n            {\n                int __ix;\n                if (map.TryGetValue(prefix + \"id\", out __ix))\n                {\n                    var leaf = new Polygen.Common.CsvIndexHeader();\n                    leaf.Index = __ix;\n                    root.IndexList.Add(leaf);\n                }\n            }\n            {\n                int __ix;\n                if (map.TryGetValue(prefix + \"name\", out __ix))\n                {\n                    var leaf = new Polygen.Common.CsvIndexHeader();\n                    leaf.Index = __ix;\n                    root.IndexList.Add(leaf);\n                }\n            }\n            {\n                int __ix;\n                if (map.TryGetValue(prefix + \"active\", out __ix))\n                {\n                    var leaf = new Polygen.Common.CsvIndexHeader();\n                    leaf.Index = __ix;\n                    root.IndexList.Add(leaf);\n                }\n            }\n            {\n                int __ix;\n                if (map.TryGetValue(prefix + \"score\", out __ix))\n                {\n                    var leaf = new Polygen.Common.CsvIndexHeader();\n                    leaf.Index = __ix;\n                    root.IndexList.Add(leaf);\n                }\n            }\n            {\n                var ch = new Polygen.Common.CsvIndexHeader();\n                ch.Index = -1;\n                ch.IndexList = new System.Collections.Generic.List<Polygen.Common.CsvIndexHeader>();\n                for (int i=0;;i++)\n                {\n                    int __ix;\n                    if (!map.TryGetValue(prefix + \"tags[\" + i + \"]\", out __ix))\n                    {\n                        break;\n                    }\n                    var leaf = new Polygen.Common.CsvIndexHeader();\n                    leaf.Index = __ix;\n                    ch.IndexList.Add(leaf);\n                }\n                root.IndexList.Add(ch);\n            }\n            {\n                int __ix;\n                if (map.TryGetValue(prefix + \"color\", out __ix))\n                {\n                    var leaf = new Polygen.Common.CsvIndexHeader();\n                    leaf.Index = __ix;\n                    root.IndexList.Add(leaf);\n                }\n            }\n            {\n                var sub = global::Csv.test.csv.Point.BuildHeader(header, prefix + \"location.\");\n                if (sub.HasAny()) root.IndexList.Add(sub);\n            }\n            {\n                var ch = new Polygen.Common.CsvIndexHeader();\n                ch.Index = -1;\n                ch.IndexList = new System.Collections.Generic.List<Polygen.Common.CsvIndexHeader>();\n                for (int i=0;;i++)\n                {\n                    var sub = global::Csv.test.csv.Point.BuildHeader(header, prefix + \"history[\"+i+\"].\");\n                    if (!sub.HasAny()) break;\n                    ch.IndexList.Add(sub);\n                }\n                root.IndexList.Add(ch);\n            }\n            return root;\n        }\n\n    }\n}\n"
